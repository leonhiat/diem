// Copyright (c) The Diem Core Contributors
// SPDX-License-Identifier: Apache-2.0

use anyhow::{bail, format_err, Result};
use compiled_stdlib::{stdlib_modules, StdLibOptions};
use diem_crypto::{
    hash::{CryptoHash, CryptoHasher},
    HashValue,
};
use diem_crypto_derive::CryptoHasher;
use diem_types::{
    account_address::AccountAddress,
    chain_id::ChainId,
    transaction::{Transaction, Version, WriteSetPayload},
};
use diem_validator_interface::{DiemValidatorInterface, JsonRpcDebuggerInterface};
use diem_writeset_generator::{
    create_release_writeset, encode_custom_script, encode_halt_network_payload,
    encode_remove_validators_payload, verify_payload_change,
};
use move_core_types::language_storage::ModuleId;
use serde::{Deserialize, Serialize};
use std::{collections::BTreeMap, path::PathBuf};
use structopt::StructOpt;

#[derive(Debug, StructOpt)]
struct Opt {
    /// Path to the output serialized bytes
    #[structopt(long, short, parse(from_os_str))]
    output: Option<PathBuf>,
    /// Output as serialized WriteSet payload. Set this flag if this payload is submitted to AOS portal.
    #[structopt(long)]
    output_payload: bool,
    #[structopt(subcommand)]
    cmd: Command,
}

#[derive(Debug, StructOpt)]
enum Command {
    /// List of addresses to remove from validator set
    #[structopt(name = "remove-validators")]
    RemoveValidators { addresses: Vec<AccountAddress> },
    /// Block the execution of any transaction in the network
    #[structopt(name = "halt-network")]
    HaltNetwork,
    /// Build a custom file in templates into admin script
    #[structopt(name = "build-custom-script")]
    BuildCustomScript {
        script_name: String,
        args: String,
        execute_as: Option<AccountAddress>,
    },
    /// Create a release writeset by comparing local Diem Framework against a remote blockchain state.
    #[structopt(name = "create-release")]
    CreateDiemFrameworkRelease {
        /// ChainID to distinguish the diem network. e.g: PREMAINNET
        chain_id: ChainId,
        /// Public JSON-rpc endpoint URL.
        // TODO: Get rid of this URL argument once we have a stable mapping from ChainId to its url.
        url: String,
        /// Blockchain height
        version: u64,
        /// Set the flag to true in the first release. This will manually create the first release artifact on disk.
        #[structopt(long)]
        first_release: bool,
    },
    /// Verify if a blob is generated by the checked-in artifact.
    #[structopt(name = "verify-release")]
    VerifyDiemFrameworkRelease {
        /// ChainID to distinguish the diem network. e.g: PREMAINNET
        chain_id: ChainId,
        /// Public JSON-rpc endpoint URL.
        url: String,
        /// Path to the serialized bytes of WriteSet.
        #[structopt(parse(from_os_str))]
        writeset_path: PathBuf,
    },
}

/// Checkin the release artifact to a local file to make sure the release process is reproducible
#[derive(Clone, Serialize, Deserialize)]
struct ReleaseArtifact {
    chain_id: ChainId,
    version: Version,
    stdlib_hash: HashValue,
}

const ARTIFACT_PATH: &str = "release";
const ARTIFACT_EXTENSION: &str = "json";

fn artifact_path(chain_id: &ChainId) -> PathBuf {
    let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    path.push(ARTIFACT_PATH.to_string());
    path.push(chain_id.to_string());
    path.with_extension(ARTIFACT_EXTENSION)
}

fn save_release_artifact(artifact: ReleaseArtifact) -> Result<()> {
    std::fs::write(
        artifact_path(&artifact.chain_id).as_path(),
        serde_json::to_vec(&artifact)?.as_slice(),
    )
    .map_err(|_| format_err!("Unable to write to path"))
}

fn load_artifact(chain_id: &ChainId) -> Result<ReleaseArtifact> {
    serde_json::from_slice(std::fs::read(artifact_path(chain_id).as_path())?.as_slice())
        .map_err(|_| format_err!("Unable to read from artifact"))
}

fn create_release(artifact: &ReleaseArtifact, remote_url: &str) -> Result<WriteSetPayload> {
    let remote = JsonRpcDebuggerInterface::new(remote_url)?;
    let remote_modules = remote.get_diem_framework_modules_by_version(artifact.version)?;
    let local_modules = stdlib_modules(StdLibOptions::Compiled).to_vec();
    create_release_writeset(remote_modules, local_modules)
}

fn save_bytes(bytes: Vec<u8>, path: PathBuf) -> Result<()> {
    std::fs::write(path.as_path(), bytes.as_slice())
        .map_err(|_| format_err!("Unable to write to path"))
}

/// Generate a unique hash for the current stdlib files on disk.
fn stdlib_hash() -> Result<HashValue> {
    #[derive(Serialize, Deserialize, CryptoHasher)]
    struct Stdlib {
        modules: BTreeMap<ModuleId, Vec<u8>>,
    }

    impl CryptoHash for Stdlib {
        type Hasher = StdlibHasher;

        fn hash(&self) -> HashValue {
            let mut hasher = Self::Hasher::default();
            let stdlib_blobs = bcs::to_bytes(self).expect("Can't serialize stdlib modules");
            hasher.update(&stdlib_blobs);
            hasher.finish()
        }
    }

    let mut stdlib = Stdlib {
        modules: BTreeMap::new(),
    };
    for module in stdlib_modules(StdLibOptions::Compiled) {
        let id = module.self_id();
        let mut bytes = vec![];
        module.serialize(&mut bytes)?;
        stdlib.modules.insert(id, bytes);
    }
    Ok(stdlib.hash())
}

fn main() -> Result<()> {
    let opt = Opt::from_args();
    let payload = match opt.cmd {
        Command::RemoveValidators { addresses } => encode_remove_validators_payload(addresses),
        Command::HaltNetwork => encode_halt_network_payload(),
        Command::BuildCustomScript {
            script_name,
            args,
            execute_as,
        } => encode_custom_script(
            &script_name,
            &serde_json::from_str::<serde_json::Value>(args.as_str())?,
            execute_as,
        ),
        Command::CreateDiemFrameworkRelease {
            chain_id,
            url,
            version,
            first_release,
        } => {
            let release_artifact = ReleaseArtifact {
                chain_id,
                version,
                stdlib_hash: stdlib_hash()?,
            };

            if first_release {
                if load_artifact(&chain_id).is_ok() {
                    bail!("Previous release existed");
                }
                save_release_artifact(release_artifact.clone())?;
            }
            let artifact = load_artifact(&chain_id)?;

            if artifact.chain_id != chain_id {
                bail!("Artifact mismatch with on disk file");
            }
            if artifact.version > version {
                bail!(
                    "Artifact version is ahead of the argument: old: {:?}, new: {:?}",
                    artifact.version,
                    version
                );
            }

            let remote = Box::new(JsonRpcDebuggerInterface::new(url.as_str())?);
            let payload = create_release(&release_artifact, url.as_str())?;
            verify_payload_change(remote, Some(version), &payload)?;
            save_release_artifact(release_artifact)?;
            payload
        }
        Command::VerifyDiemFrameworkRelease {
            url,
            chain_id,
            writeset_path,
        } => {
            let writeset_payload = {
                let raw_bytes = std::fs::read(writeset_path.as_path()).unwrap();
                bcs::from_bytes::<WriteSetPayload>(raw_bytes.as_slice()).or_else(|_| {
                    let txn: Transaction = bcs::from_bytes(raw_bytes.as_slice())?;
                    match txn {
                        Transaction::GenesisTransaction(ws) => Ok(ws),
                        _ => bail!("Unexpected transacton type"),
                    }
                })?
            };
            let artifact = load_artifact(&chain_id)?;
            if artifact.chain_id != chain_id {
                bail!("Unexpected ChainId");
            }
            if artifact.stdlib_hash != stdlib_hash()? {
                bail!("Build artifact doesn't match local stdlib hash");
            }
            let generated_payload = create_release(&artifact, url.as_str())?;
            if generated_payload != writeset_payload {
                bail!("Payload generated from the artifact doesn't match with input file");
            }
            let remote = Box::new(JsonRpcDebuggerInterface::new(url.as_str())?);
            verify_payload_change(remote, Some(artifact.version), &writeset_payload)?;
            return Ok(());
        }
    };
    let output_path = if let Some(p) = opt.output {
        p
    } else {
        bail!("Empty output path provided");
    };
    if opt.output_payload {
        save_bytes(
            bcs::to_bytes(&payload).map_err(|_| format_err!("Transaction Serialize Error"))?,
            output_path,
        )
    } else {
        save_bytes(
            bcs::to_bytes(&Transaction::GenesisTransaction(payload))
                .map_err(|_| format_err!("Transaction Serialize Error"))?,
            output_path,
        )
    }
}
