
// ** prelude from <inline-prelude>

// ================================================================================
// Notation

// This files contains a Handlebars Rust template for the prover's Boogie prelude.
// The template language constructs allow the prelude to adjust the actual content
// to multiple options. We only use a few selected template constructs which are
// mostly self-explaining. See the handlebars crate documentation for more information.
//
// The object passed in as context for templates is the struct cli::Options and its
// sub-structs.

// ================================================================================
// Domains

// Debug tracking
// --------------

// Debug tracking is used to inject information used for model analysis. The generated code emits statements
// like this:
//
//     assume $DebugTrackLocal(file_id, byte_index, var_idx, $Value);
//
// While those tracking assumptions are trivially true for the provers logic, the solver (at least Z3)
// will construct a function mapping which appears in the model, e.g.:
//
//     $DebugTrackLocal -> {
//         1 440 0 (Vector (ValueArray |T@[Int]$Value!val!0| 0)) -> true
//         1 533 1 ($Integer 1) -> true
//         ...
//         else -> true
//     }
//
// This information can then be read out from the model.


// Tracks debug information for a parameter, local or a return parameter. Return parameter indices start at
// the overall number of locals (including parameters).
function $DebugTrackLocal(file_id: int, byte_index:  int, var_idx: int, $Value: $Value) : bool {
  true
}

// Tracks at which location a function was aborted.
function $DebugTrackAbort(file_id: int, byte_index: int, code: int) : bool {
  true
}

// Tracks the $Value of a specification (sub-)expression.
function $DebugTrackExp(module_id: int, node_id: int, $Value: $Value) : $Value { $Value }


// Path type
// ---------

type {:datatype} $Path;
function {:constructor} $Path(p: [int]int, size: int): $Path;
const $EmptyPath: $Path;
axiom size#$Path($EmptyPath) == 0;

function {:inline} $path_index_at(p: $Path, i: int): int {
    p#$Path(p)[i]
}

// Type Values
// -----------

type $TypeName;
type $FieldName = int;
type $LocalName;
type {:datatype} $TypeValue;
function {:constructor} $BooleanType() : $TypeValue;
function {:constructor} $IntegerType() : $TypeValue;
function {:constructor} $AddressType() : $TypeValue;
function {:constructor} $StrType() : $TypeValue;
function {:constructor} $VectorType(t: $TypeValue) : $TypeValue;
function {:constructor} $StructType(name: $TypeName, ts: $TypeValueArray) : $TypeValue;
function {:constructor} $TypeType(): $TypeValue;
function {:constructor} $ErrorType() : $TypeValue;

function {:inline} $DefaultTypeValue() : $TypeValue { $ErrorType() }
function {:builtin "MapConst"} $MapConstTypeValue(tv: $TypeValue): [int]$TypeValue;

type {:datatype} $TypeValueArray;
function {:constructor} $TypeValueArray(v: [int]$TypeValue, l: int): $TypeValueArray;
const $EmptyTypeValueArray: $TypeValueArray;
axiom l#$TypeValueArray($EmptyTypeValueArray) == 0;
axiom v#$TypeValueArray($EmptyTypeValueArray) == $MapConstTypeValue($DefaultTypeValue());



// Values
// ------

type {:datatype} $Value;

const $MAX_U8: int;
axiom $MAX_U8 == 255;
const $MAX_U64: int;
axiom $MAX_U64 == 18446744073709551615;
const $MAX_U128: int;
axiom $MAX_U128 == 340282366920938463463374607431768211455;

function {:constructor} $Boolean(b: bool): $Value;
function {:constructor} $Integer(i: int): $Value;
function {:constructor} $Address(a: int): $Value;
function {:constructor} $Vector(v: $ValueArray): $Value; // used to both represent Move Struct and Vector
function {:constructor} $Range(lb: $Value, ub: $Value): $Value;
function {:constructor} $Type(t: $TypeValue): $Value;
function {:constructor} $Error(): $Value;

function {:inline} $DefaultValue(): $Value { $Error() }
function {:builtin "MapConst"} $MapConstValue(v: $Value): [int]$Value;

function {:inline} $IsValidU8(v: $Value): bool {
  is#$Integer(v) && i#$Integer(v) >= 0 && i#$Integer(v) <= $MAX_U8
}

function {:inline} $IsValidU8Vector(vec: $Value): bool {
  $Vector_$is_well_formed(vec)
  && (forall i: int :: {$select_vector(vec, i)} 0 <= i && i < $vlen(vec) ==> $IsValidU8($select_vector(vec, i)))
}

function {:inline} $IsValidU64(v: $Value): bool {
  is#$Integer(v) && i#$Integer(v) >= 0 && i#$Integer(v) <= $MAX_U64
}

function {:inline} $IsValidU128(v: $Value): bool {
  is#$Integer(v) && i#$Integer(v) >= 0 && i#$Integer(v) <= $MAX_U128
}

function {:inline} $IsValidNum(v: $Value): bool {
  is#$Integer(v)
}


// Value Array
// -----------





// This is the implementation of $ValueArray using integer maps

type {:datatype} $ValueArray;

function {:constructor} $ValueArray(v: [int]$Value, l: int): $ValueArray;

function $EmptyValueArray(): $ValueArray;
axiom l#$ValueArray($EmptyValueArray()) == 0;
axiom v#$ValueArray($EmptyValueArray()) == $MapConstValue($Error());

function {:inline} $ReadValueArray(a: $ValueArray, i: int): $Value {
    (
        v#$ValueArray(a)[i]
    )
}

function {:inline} $LenValueArray(a: $ValueArray): int {
    (
        l#$ValueArray(a)
    )
}

function {:inline} $RemoveValueArray(a: $ValueArray): $ValueArray {
    (
        var l := l#$ValueArray(a) - 1;
        $ValueArray(
            (lambda i: int ::
                if i >= 0 && i < l then v#$ValueArray(a)[i] else $DefaultValue()),
            l
        )
    )
}

function {:inline} $SingleValueArray(v: $Value): $ValueArray {
    $ValueArray($MapConstValue($DefaultValue())[0 := v], 1)
}

function {:inline} $RemoveIndexValueArray(a: $ValueArray, i: int): $ValueArray {
    (
        var l := l#$ValueArray(a) - 1;
        $ValueArray(
            (lambda j: int ::
                if j >= 0 && j < l then
                    if j < i then v#$ValueArray(a)[j] else v#$ValueArray(a)[j+1]
                else $DefaultValue()),
            l
        )
    )
}

function {:inline} $ConcatValueArray(a1: $ValueArray, a2: $ValueArray): $ValueArray {
    (
        var l1, m1, l2, m2 := l#$ValueArray(a1), v#$ValueArray(a1), l#$ValueArray(a2), v#$ValueArray(a2);
        $ValueArray(
            (lambda i: int ::
                if i >= 0 && i < l1 + l2 then
                    if i < l1 then m1[i] else m2[i - l1]
                else
                    $DefaultValue()),
            l1 + l2)
    )
}

function {:inline} $ReverseValueArray(a: $ValueArray): $ValueArray {
    (
        var l := l#$ValueArray(a);
        $ValueArray(
            (lambda i: int :: if 0 <= i && i < l then v#$ValueArray(a)[l - i - 1] else $DefaultValue()),
            l
        )
    )
}

function {:inline} $SliceValueArray(a: $ValueArray, i: int, j: int): $ValueArray { // return the sliced vector of a for the range [i, j)
    $ValueArray((lambda k:int :: if 0 <= k && k < j-i then v#$ValueArray(a)[i+k] else $DefaultValue()), (if j-i < 0 then 0 else j-i))
}

function {:inline} $ExtendValueArray(a: $ValueArray, elem: $Value): $ValueArray {
    (var len := l#$ValueArray(a);
     $ValueArray(v#$ValueArray(a)[len := elem], len + 1))
}

function {:inline} $UpdateValueArray(a: $ValueArray, i: int, elem: $Value): $ValueArray {
    $ValueArray(v#$ValueArray(a)[i := elem], l#$ValueArray(a))
}

function {:inline} $SwapValueArray(a: $ValueArray, i: int, j: int): $ValueArray {
    $ValueArray(v#$ValueArray(a)[i := v#$ValueArray(a)[j]][j := v#$ValueArray(a)[i]], l#$ValueArray(a))
}

function {:inline} $IsEmpty(a: $ValueArray): bool {
    l#$ValueArray(a) == 0
}

// All invalid elements of array are DefaultValue. This is useful in specialized
// cases. This is used to defined normalization for $Vector
function {:inline} $IsNormalizedValueArray(a: $ValueArray, len: int): bool {
    (forall i: int :: i < 0 || i >= len ==> v#$ValueArray(a)[i] == $DefaultValue())
}


 //end of backend.vector_using_sequences


// Stratified Functions on Values
// ------------------------------

// TODO: templatize this or move it back to the translator. For now we
//   prefer to handcode this so its easier to evolve the model independent of the
//   translator.

const $StratificationDepth: int;
axiom $StratificationDepth == 4;



// Generate a stratified version of IsEqual for depth of 4.

function  $IsEqual_stratified(v1: $Value, v2: $Value): bool {
    (v1 == v2) ||
    (is#$Vector(v1) &&
     is#$Vector(v2) &&
     $vlen(v1) == $vlen(v2) &&
     (forall i: int :: 0 <= i && i < $vlen(v1) ==> $IsEqual_level1($select_vector(v1,i), $select_vector(v2,i))))
}

function  $IsEqual_level1(v1: $Value, v2: $Value): bool {
    (v1 == v2) ||
    (is#$Vector(v1) &&
     is#$Vector(v2) &&
     $vlen(v1) == $vlen(v2) &&
     (forall i: int :: 0 <= i && i < $vlen(v1) ==> $IsEqual_level2($select_vector(v1,i), $select_vector(v2,i))))
}

function  $IsEqual_level2(v1: $Value, v2: $Value): bool {
    (v1 == v2) ||
    (is#$Vector(v1) &&
     is#$Vector(v2) &&
     $vlen(v1) == $vlen(v2) &&
     (forall i: int :: 0 <= i && i < $vlen(v1) ==> $IsEqual_level3($select_vector(v1,i), $select_vector(v2,i))))
}

function {:inline} $IsEqual_level3(v1: $Value, v2: $Value): bool {
    v1 == v2
}


function {:inline} $IsEqual(v1: $Value, v2: $Value): bool {
    $IsEqual_stratified(v1, v2)
}



// Generate stratified ReadValue for the depth of 4.


function  $ReadValue_stratified(p: $Path, v: $Value) : $Value {
    if (0 == size#$Path(p)) then
        v
    else
        $ReadValue_level1(p, $select_vector(v,$path_index_at(p, 0)))
}

function  $ReadValue_level1(p: $Path, v: $Value) : $Value {
    if (1 == size#$Path(p)) then
        v
    else
        $ReadValue_level2(p, $select_vector(v,$path_index_at(p, 1)))
}

function  $ReadValue_level2(p: $Path, v: $Value) : $Value {
    if (2 == size#$Path(p)) then
        v
    else
        $ReadValue_level3(p, $select_vector(v,$path_index_at(p, 2)))
}

function {:inline} $ReadValue_level3(p: $Path, v: $Value): $Value {
    v
}


function {:inline} $ReadValue(p: $Path, v: $Value): $Value {
    $ReadValue_stratified(p, v)
}

// Generate stratified $UpdateValue for the depth of 4.


function  $UpdateValue_stratified(p: $Path, offset: int, v: $Value, new_v: $Value): $Value {
    (var poffset := offset + 0;
    if (poffset == size#$Path(p)) then
        new_v
    else
        $update_vector(v, $path_index_at(p, poffset),
                       $UpdateValue_level1(p, offset, $select_vector(v,$path_index_at(p, poffset)), new_v)))
}

function  $UpdateValue_level1(p: $Path, offset: int, v: $Value, new_v: $Value): $Value {
    (var poffset := offset + 1;
    if (poffset == size#$Path(p)) then
        new_v
    else
        $update_vector(v, $path_index_at(p, poffset),
                       $UpdateValue_level2(p, offset, $select_vector(v,$path_index_at(p, poffset)), new_v)))
}

function  $UpdateValue_level2(p: $Path, offset: int, v: $Value, new_v: $Value): $Value {
    (var poffset := offset + 2;
    if (poffset == size#$Path(p)) then
        new_v
    else
        $update_vector(v, $path_index_at(p, poffset),
                       $UpdateValue_level3(p, offset, $select_vector(v,$path_index_at(p, poffset)), new_v)))
}

function {:inline} $UpdateValue_level3(p: $Path, offset: int, v: $Value, new_v: $Value): $Value {
    new_v
}


function {:inline} $UpdateValue(p: $Path, offset: int, v: $Value, new_v: $Value): $Value {
    $UpdateValue_stratified(p, offset, v, new_v)
}

// Generate stratified $IsPathPrefix for the depth of 4.


function  $IsPathPrefix_stratified(p1: $Path, p2: $Path): bool {
    if (0 == size#$Path(p1)) then
        true
    else if (p#$Path(p1)[0] == p#$Path(p2)[0]) then
        $IsPathPrefix_level1(p1, p2)
    else
        false
}

function  $IsPathPrefix_level1(p1: $Path, p2: $Path): bool {
    if (1 == size#$Path(p1)) then
        true
    else if (p#$Path(p1)[1] == p#$Path(p2)[1]) then
        $IsPathPrefix_level2(p1, p2)
    else
        false
}

function  $IsPathPrefix_level2(p1: $Path, p2: $Path): bool {
    if (2 == size#$Path(p1)) then
        true
    else if (p#$Path(p1)[2] == p#$Path(p2)[2]) then
        $IsPathPrefix_level3(p1, p2)
    else
        false
}

function {:inline} $IsPathPrefix_level3(p1: $Path, p2: $Path): bool {
    true
}


function {:inline} $IsPathPrefix(p1: $Path, p2: $Path): bool {
    $IsPathPrefix_stratified(p1, p2)
}

// Generate stratified $ConcatPath for the depth of 4.


function  $ConcatPath_stratified(p1: $Path, p2: $Path): $Path {
    if (0 == size#$Path(p2)) then
        p1
    else
        $ConcatPath_level1($Path(p#$Path(p1)[size#$Path(p1) := p#$Path(p2)[0]], size#$Path(p1) + 1), p2)
}

function  $ConcatPath_level1(p1: $Path, p2: $Path): $Path {
    if (1 == size#$Path(p2)) then
        p1
    else
        $ConcatPath_level2($Path(p#$Path(p1)[size#$Path(p1) := p#$Path(p2)[1]], size#$Path(p1) + 1), p2)
}

function  $ConcatPath_level2(p1: $Path, p2: $Path): $Path {
    if (2 == size#$Path(p2)) then
        p1
    else
        $ConcatPath_level3($Path(p#$Path(p1)[size#$Path(p1) := p#$Path(p2)[2]], size#$Path(p1) + 1), p2)
}

function {:inline} $ConcatPath_level3(p1: $Path, p2: $Path): $Path {
    p1
}


function {:inline} $ConcatPath(p1: $Path, p2: $Path): $Path {
    $ConcatPath_stratified(p1, p2)
}

// Vector related functions on Values
// ----------------------------------

function {:inline} $vlen(v: $Value): int {
    $LenValueArray(v#$Vector(v))
}

// Check that all invalid elements of vector are DefaultValue
function {:inline} $is_normalized_vector(v: $Value): bool {
    $IsNormalizedValueArray(v#$Vector(v), $vlen(v))
}

// Sometimes, we need the length as a Value, not an int.
function {:inline} $vlen_value(v: $Value): $Value {
    $Integer($vlen(v))
}
function {:inline} $mk_vector(): $Value {
    $Vector($EmptyValueArray())
}
function {:inline} $push_back_vector(v: $Value, elem: $Value): $Value {
    $Vector($ExtendValueArray(v#$Vector(v), elem))
}
function {:inline} $pop_back_vector(v: $Value): $Value {
    $Vector($RemoveValueArray(v#$Vector(v)))
}
function {:inline} $single_vector(v: $Value): $Value {
    $Vector($SingleValueArray(v))
}
function {:inline} $append_vector(v1: $Value, v2: $Value): $Value {
    $Vector($ConcatValueArray(v#$Vector(v1), v#$Vector(v2)))
}
function {:inline} $reverse_vector(v: $Value): $Value {
    $Vector($ReverseValueArray(v#$Vector(v)))
}
function {:inline} $update_vector(v: $Value, i: int, elem: $Value): $Value {
    $Vector($UpdateValueArray(v#$Vector(v), i, elem))
}
// $update_vector_by_value requires index to be a Value, not int.
function {:inline} $update_vector_by_value(v: $Value, i: $Value, elem: $Value): $Value {
    $Vector($UpdateValueArray(v#$Vector(v), i#$Integer(i), elem))
}
function {:inline} $select_vector(v: $Value, i: int) : $Value {
    $ReadValueArray(v#$Vector(v), i)
}
// $select_vector_by_value requires index to be a Value, not int.
function {:inline} $select_vector_by_value(v: $Value, i: $Value) : $Value {
    $select_vector(v, i#$Integer(i))
}
function {:inline} $swap_vector(v: $Value, i: int, j: int): $Value {
    $Vector($SwapValueArray(v#$Vector(v), i, j))
}
function {:inline} $slice_vector(v: $Value, r: $Value) : $Value {
    $Vector($SliceValueArray(v#$Vector(v), i#$Integer(lb#$Range(r)), i#$Integer(ub#$Range(r))))
}
function {:inline} $InVectorRange(v: $Value, i: int): bool {
    i >= 0 && i < $vlen(v)
}
function {:inline} $remove_vector(v: $Value, i:int): $Value {
    $Vector($RemoveIndexValueArray(v#$Vector(v), i))
}
function {:inline} $contains_vector(v: $Value, e: $Value): bool {
    (exists i:int :: 0 <= i && i < $vlen(v) && $IsEqual($select_vector(v,i), e))
}

function {:inline} $InRange(r: $Value, i: int): bool {
   i#$Integer(lb#$Range(r)) <= i && i < i#$Integer(ub#$Range(r))
}


// ============================================================================================
// Memory

type {:datatype} $Location;

// A global resource location within the statically known resource type's memory.
// `ts` are the type parameters for the outer type, and `a` is the address.
function {:constructor} $Global(ts: $TypeValueArray, a: int): $Location;

// A local location. `i` is the unique index of the local.
function {:constructor} $Local(i: int): $Location;

// The location of a reference outside of the verification scope, for example, a `&mut` parameter
// of the function being verified. References with these locations don't need to be written back
// when mutation ends.
function {:constructor} $Param(i: int): $Location;


// A mutable reference which also carries its current value. Since mutable references
// are single threaded in Move, we can keep them together and treat them as a value
// during mutation until the point they are stored back to their original location.
type {:datatype} $Mutation;
function {:constructor} $Mutation(l: $Location, p: $Path, v: $Value): $Mutation;
const $DefaultMutation: $Mutation;

// Representation of memory for a given type. The maps take the content of a Global location.
type {:datatype} $Memory;
function {:constructor} $Memory(domain: [$TypeValueArray, int]bool, contents: [$TypeValueArray, int]$Value): $Memory;

function {:inline} $Memory__is_well_formed(m: $Memory): bool {
    true
}

function {:builtin "MapConst"} $ConstMemoryDomain(v: bool): [$TypeValueArray, int]bool;
function {:builtin "MapConst"} $ConstMemoryContent(v: $Value): [$TypeValueArray, int]$Value;
axiom $ConstMemoryDomain(false) == (lambda ta: $TypeValueArray, i: int :: false);
axiom $ConstMemoryDomain(true) == (lambda ta: $TypeValueArray, i: int :: true);

const $EmptyMemory: $Memory;
axiom domain#$Memory($EmptyMemory) == $ConstMemoryDomain(false);
axiom contents#$Memory($EmptyMemory) == $ConstMemoryContent($DefaultValue());

var $abort_flag: bool;
var $abort_code: int;

const $EXEC_FAILURE_CODE: int;
axiom $EXEC_FAILURE_CODE == -1;

// TODO(wrwg): currently we map aborts of native functions like those for vectors also to
//   execution failure. This may need to be aligned with what the runtime actually does.

procedure {:inline 1} $ExecFailureAbort() {
    $abort_flag := true;
    $abort_code := $EXEC_FAILURE_CODE;
}

procedure {:inline 1} $InitVerification() {
  // Set abort_flag to false, and havoc abort_code
  $abort_flag := false;
  havoc $abort_code;
}

// ============================================================================================
// Functional APIs

// TODO: unify some of this with instruction procedures to avoid duplication

// Tests whether resource exists.
function {:inline} $ResourceExistsRaw(m: $Memory, args: $TypeValueArray, addr: int): bool {
    domain#$Memory(m)[args, addr]
}
function {:inline} $ResourceExists(m: $Memory, args: $TypeValueArray, addr: $Value): $Value {
    $Boolean($ResourceExistsRaw(m, args, a#$Address(addr)))
}

// Obtains Value of given resource.
function {:inline} $ResourceValue(m: $Memory, args: $TypeValueArray, addr: $Value): $Value {
  contents#$Memory(m)[args, a#$Address(addr)]
}

// Applies a field selection to a Value.
function {:inline} $SelectField(val: $Value, field: $FieldName): $Value {
    $select_vector(val, field)
}

// Updates a field.
function {:inline} $UpdateField(val: $Value, field: $FieldName, new_value: $Value): $Value {
    $update_vector(val, field, new_value)
}


// Dereferences a reference.
function {:inline} $Dereference(ref: $Mutation): $Value {
    v#$Mutation(ref)
}

// ============================================================================================
// Instructions

procedure {:inline 1} $MoveToRaw(m: $Memory, ta: $TypeValueArray, a: int, v: $Value) returns (m': $Memory)
{
    if ($ResourceExistsRaw(m, ta, a)) {
        call $ExecFailureAbort();
        return;
    }
    m' := $Memory(domain#$Memory(m)[ta, a := true], contents#$Memory(m)[ta, a := v]);
}

procedure {:inline 1} $MoveTo(m: $Memory, ta: $TypeValueArray, v: $Value, signer: $Value) returns (m': $Memory)
{
    var address: $Value;
    var a: int;

    call address := $Signer_borrow_address(signer);
    a := a#$Address(address);
    call m' := $MoveToRaw(m, ta, a, v);
}

procedure {:inline 1} $MoveFrom(m: $Memory, address: $Value, ta: $TypeValueArray) returns (m': $Memory, dst: $Value)
free requires is#$Address(address);
{
    var a: int;

    a := a#$Address(address);
    if (!$ResourceExistsRaw(m, ta, a)) {
        call $ExecFailureAbort();
        return;
    }
    dst := contents#$Memory(m)[ta, a];
    m' := $Memory(domain#$Memory(m)[ta, a := false], contents#$Memory(m)[ta, a := $DefaultValue()]);
}

procedure {:inline 1} $BorrowGlobal(m: $Memory, address: $Value, ta: $TypeValueArray) returns (dst: $Mutation)
free requires is#$Address(address);
{
    var a: int;

    a := a#$Address(address);
    if (!$ResourceExistsRaw(m, ta, a)) {
        call $ExecFailureAbort();
        return;
    }
    dst := $Mutation($Global(ta, a), $EmptyPath, contents#$Memory(m)[ta, a]);
}

procedure {:inline 1} $BorrowLoc(l: int, v: $Value) returns (dst: $Mutation)
{
    dst := $Mutation($Local(l), $EmptyPath, v);
}

procedure {:inline 1} $BorrowField(src: $Mutation, f: $FieldName) returns (dst: $Mutation)
{
    var p: $Path;
    var size: int;

    p := p#$Mutation(src);
    size := size#$Path(p);
    p := $Path(p#$Path(p)[size := f], size+1);
    dst := $Mutation(l#$Mutation(src), p, $select_vector(v#$Mutation(src), f));
}

procedure {:inline 1} $GetGlobal(m: $Memory, address: $Value, ta: $TypeValueArray) returns (dst: $Value)
free requires is#$Address(address);
{
    var a: int;
    a := a#$Address(address);
    if (!$ResourceExistsRaw(m, ta, a)) {
        call $ExecFailureAbort();
        return;
    }
    dst := $ResourceValue(m, ta, address);
}

procedure {:inline 1} $GetFieldFromReference(src: $Mutation, f: $FieldName) returns (dst: $Value)
{
    var r: $Mutation;

    call r := $BorrowField(src, f);
    call dst := $ReadRef(r);
}

procedure {:inline 1} $GetFieldFromValue(src: $Value, f: $FieldName) returns (dst: $Value)
{
    dst := $select_vector(src, f);
}

procedure {:inline 1} $WriteRef(to: $Mutation, new_v: $Value) returns (to': $Mutation)
{
    to' := $Mutation(l#$Mutation(to), p#$Mutation(to), new_v);
}

procedure {:inline 1} $ReadRef(from: $Mutation) returns (v: $Value)
{
    v := v#$Mutation(from);
}

procedure {:inline 1} $CopyOrMoveRef(local: $Mutation) returns (dst: $Mutation)
{
    dst := local;
}

procedure {:inline 1} $CopyOrMoveValue(local: $Value) returns (dst: $Value)
{
    dst := local;
}

procedure {:inline 1} $WritebackToGlobal(m: $Memory, src: $Mutation) returns (m': $Memory)
{
    var l: $Location;
    var ta: $TypeValueArray;
    var a: int;
    var v: $Value;

    l := l#$Mutation(src);
    if (is#$Global(l)) {
        ta := ts#$Global(l);
        a := a#$Global(l);
        v := $UpdateValue(p#$Mutation(src), 0, contents#$Memory(m)[ta, a], v#$Mutation(src));
        m' := $Memory(domain#$Memory(m), contents#$Memory(m)[ta, a := v]);
    } else {
        m' := m;
    }
}

procedure {:inline 1} $WritebackToValue(src: $Mutation, idx: int, vdst: $Value) returns (vdst': $Value)
{
    if (l#$Mutation(src) == $Local(idx)) {
        vdst' := $UpdateValue(p#$Mutation(src), 0, vdst, v#$Mutation(src));
    } else {
        vdst' := vdst;
    }
}

procedure {:inline 1} $WritebackToReference(src: $Mutation, dst: $Mutation) returns (dst': $Mutation)
{
    var srcPath, dstPath: $Path;

    srcPath := p#$Mutation(src);
    dstPath := p#$Mutation(dst);
    if (l#$Mutation(dst) == l#$Mutation(src) && size#$Path(dstPath) <= size#$Path(srcPath) && $IsPathPrefix(dstPath, srcPath)) {
        dst' := $Mutation(
                    l#$Mutation(dst),
                    dstPath,
                    $UpdateValue(srcPath, size#$Path(dstPath), v#$Mutation(dst), v#$Mutation(src)));
    } else {
        dst' := dst;
    }
}

procedure {:inline 1} $Splice1(idx1: int, src1: $Mutation, dst: $Mutation) returns (dst': $Mutation) {
    dst' := $Mutation(l#$Mutation(src1), $ConcatPath(p#$Mutation(src1), p#$Mutation(dst)), v#$Mutation(dst));
}

procedure {:inline 1} $CastU8(src: $Value) returns (dst: $Value)
free requires is#$Integer(src);
{
    if (i#$Integer(src) > $MAX_U8) {
        call $ExecFailureAbort();
        return;
    }
    dst := src;
}

procedure {:inline 1} $CastU64(src: $Value) returns (dst: $Value)
free requires is#$Integer(src);
{
    if (i#$Integer(src) > $MAX_U64) {
        call $ExecFailureAbort();
        return;
    }
    dst := src;
}

procedure {:inline 1} $CastU128(src: $Value) returns (dst: $Value)
free requires is#$Integer(src);
{
    if (i#$Integer(src) > $MAX_U128) {
        call $ExecFailureAbort();
        return;
    }
    dst := src;
}

procedure {:inline 1} $AddU8(src1: $Value, src2: $Value) returns (dst: $Value)
free requires $IsValidU8(src1) && $IsValidU8(src2);
{
    if (i#$Integer(src1) + i#$Integer(src2) > $MAX_U8) {
        call $ExecFailureAbort();
        return;
    }
    dst := $Integer(i#$Integer(src1) + i#$Integer(src2));
}

procedure {:inline 1} $AddU64(src1: $Value, src2: $Value) returns (dst: $Value)
free requires $IsValidU64(src1) && $IsValidU64(src2);
{
    if (i#$Integer(src1) + i#$Integer(src2) > $MAX_U64) {
        call $ExecFailureAbort();
        return;
    }
    dst := $Integer(i#$Integer(src1) + i#$Integer(src2));
}

procedure {:inline 1} $AddU64_unchecked(src1: $Value, src2: $Value) returns (dst: $Value)
free requires $IsValidU64(src1) && $IsValidU64(src2);
{
    dst := $Integer(i#$Integer(src1) + i#$Integer(src2));
}

procedure {:inline 1} $AddU128(src1: $Value, src2: $Value) returns (dst: $Value)
free requires $IsValidU128(src1) && $IsValidU128(src2);
{
    if (i#$Integer(src1) + i#$Integer(src2) > $MAX_U128) {
        call $ExecFailureAbort();
        return;
    }
    dst := $Integer(i#$Integer(src1) + i#$Integer(src2));
}

procedure {:inline 1} $AddU128_unchecked(src1: $Value, src2: $Value) returns (dst: $Value)
free requires $IsValidU128(src1) && $IsValidU128(src2);
{
    dst := $Integer(i#$Integer(src1) + i#$Integer(src2));
}

procedure {:inline 1} $Sub(src1: $Value, src2: $Value) returns (dst: $Value)
free requires is#$Integer(src1) && is#$Integer(src2);
{
    if (i#$Integer(src1) < i#$Integer(src2)) {
        call $ExecFailureAbort();
        return;
    }
    dst := $Integer(i#$Integer(src1) - i#$Integer(src2));
}

// This deals only with narrow special cases. Src2 must be constant
// 32 or 64, which is what we use now.  Obviously, it could be extended
// to src2 == any integer Value from 0..127.
// Left them out for brevity
function $power_of_2(power: $Value): int {
    (var p := i#$Integer(power);
     if p == 8 then 256
     else if p == 16 then 65536
     else if p == 32 then 4294967296
     else if p == 64 then 18446744073709551616
     // Value is undefined, otherwise.
     else -1
     )
}

function $shl(src1: $Value, src2: $Value): $Value {
   (var po2 := $power_of_2(src2);
    $Integer(i#$Integer(src1) * po2)
   )
}

function $shr(src1: $Value, src2: $Value): $Value {
   (var po2 := $power_of_2(src2);
    $Integer(i#$Integer(src1) div po2)
   )
}

// TODO: fix this and $Shr to drop bits on overflow. Requires $Shl8, $Shl64, and $Shl128
procedure {:inline 1} $Shl(src1: $Value, src2: $Value) returns (dst: $Value)
requires is#$Integer(src1) && is#$Integer(src2);
{
    var po2: int;
    po2 := $power_of_2(src2);
    assert po2 >= 1;   // restriction: shift argument must be 8, 16, 32, or 64
    dst := $Integer(i#$Integer(src1) * po2);
}

procedure {:inline 1} $Shr(src1: $Value, src2: $Value) returns (dst: $Value)
requires is#$Integer(src1) && is#$Integer(src2);
{
    var po2: int;
    po2 := $power_of_2(src2);
    assert po2 >= 1;   // restriction: shift argument must be 8, 16, 32, or 64
    dst := $Integer(i#$Integer(src1) div po2);
}

procedure {:inline 1} $MulU8(src1: $Value, src2: $Value) returns (dst: $Value)
free requires $IsValidU8(src1) && $IsValidU8(src2);
{
    if (i#$Integer(src1) * i#$Integer(src2) > $MAX_U8) {
        call $ExecFailureAbort();
        return;
    }
    dst := $Integer(i#$Integer(src1) * i#$Integer(src2));
}

procedure {:inline 1} $MulU64(src1: $Value, src2: $Value) returns (dst: $Value)
free requires $IsValidU64(src1) && $IsValidU64(src2);
{
    if (i#$Integer(src1) * i#$Integer(src2) > $MAX_U64) {
        call $ExecFailureAbort();
        return;
    }
    dst := $Integer(i#$Integer(src1) * i#$Integer(src2));
}

procedure {:inline 1} $MulU128(src1: $Value, src2: $Value) returns (dst: $Value)
free requires $IsValidU128(src1) && $IsValidU128(src2);
{
    if (i#$Integer(src1) * i#$Integer(src2) > $MAX_U128) {
        call $ExecFailureAbort();
        return;
    }
    dst := $Integer(i#$Integer(src1) * i#$Integer(src2));
}

procedure {:inline 1} $Div(src1: $Value, src2: $Value) returns (dst: $Value)
free requires is#$Integer(src1) && is#$Integer(src2);
{
    if (i#$Integer(src2) == 0) {
        call $ExecFailureAbort();
        return;
    }
    dst := $Integer(i#$Integer(src1) div i#$Integer(src2));
}

procedure {:inline 1} $Mod(src1: $Value, src2: $Value) returns (dst: $Value)
free requires is#$Integer(src1) && is#$Integer(src2);
{
    if (i#$Integer(src2) == 0) {
        call $ExecFailureAbort();
        return;
    }
    dst := $Integer(i#$Integer(src1) mod i#$Integer(src2));
}

procedure {:inline 1} $ArithBinaryUnimplemented(src1: $Value, src2: $Value) returns (dst: $Value);
free requires is#$Integer(src1) && is#$Integer(src2);
ensures is#$Integer(dst);

procedure {:inline 1} $Lt(src1: $Value, src2: $Value) returns (dst: $Value)
free requires is#$Integer(src1) && is#$Integer(src2);
{
    dst := $Boolean(i#$Integer(src1) < i#$Integer(src2));
}

procedure {:inline 1} $Gt(src1: $Value, src2: $Value) returns (dst: $Value)
free requires is#$Integer(src1) && is#$Integer(src2);
{
    dst := $Boolean(i#$Integer(src1) > i#$Integer(src2));
}

procedure {:inline 1} $Le(src1: $Value, src2: $Value) returns (dst: $Value)
free requires is#$Integer(src1) && is#$Integer(src2);
{
    dst := $Boolean(i#$Integer(src1) <= i#$Integer(src2));
}

procedure {:inline 1} $Ge(src1: $Value, src2: $Value) returns (dst: $Value)
free requires is#$Integer(src1) && is#$Integer(src2);
{
    dst := $Boolean(i#$Integer(src1) >= i#$Integer(src2));
}

procedure {:inline 1} $And(src1: $Value, src2: $Value) returns (dst: $Value)
free requires is#$Boolean(src1) && is#$Boolean(src2);
{
    dst := $Boolean(b#$Boolean(src1) && b#$Boolean(src2));
}

procedure {:inline 1} $Or(src1: $Value, src2: $Value) returns (dst: $Value)
free requires is#$Boolean(src1) && is#$Boolean(src2);
{
    dst := $Boolean(b#$Boolean(src1) || b#$Boolean(src2));
}

procedure {:inline 1} $Not(src: $Value) returns (dst: $Value)
free requires is#$Boolean(src);
{
    dst := $Boolean(!b#$Boolean(src));
}

// Pack and Unpack are auto-generated for each type T


// ==================================================================================
// Native Vector Type

function {:inline} $Vector_type_value(tv: $TypeValue): $TypeValue {
    $VectorType(tv)
}



// This is uses the implementation of $ValueArray using integer maps
function {:inline} $Vector_$is_well_formed(v: $Value): bool {
    is#$Vector(v) &&
    (
        var va := v#$Vector(v);
        (
            var l := l#$ValueArray(va);
            0 <= l && l <= $MAX_U64 &&
            (forall x: int :: {v#$ValueArray(va)[x]} x < 0 || x >= l ==> v#$ValueArray(va)[x] == $DefaultValue())
        )
    )
}



procedure {:inline 1} $Vector_empty(ta: $TypeValue) returns (v: $Value) {
    v := $mk_vector();
}

function {:inline 1} $Vector_$empty(ta: $TypeValue): $Value {
    $mk_vector()
}

procedure {:inline 1} $Vector_is_empty(ta: $TypeValue, v: $Value) returns (b: $Value) {
    assume is#$Vector(v);
    b := $Boolean($vlen(v) == 0);
}

procedure {:inline 1} $Vector_push_back(ta: $TypeValue, v: $Value, val: $Value) returns (v': $Value) {
    assume is#$Vector(v);
    v' := $push_back_vector(v, val);
}

function {:inline 1} $Vector_$push_back(ta: $TypeValue, v: $Value, val: $Value): $Value {
    $push_back_vector(v, val)
}

procedure {:inline 1} $Vector_pop_back(ta: $TypeValue, v: $Value) returns (e: $Value, v': $Value) {
    var len: int;
    assume is#$Vector(v);
    len := $vlen(v);
    if (len == 0) {
        call $ExecFailureAbort();
        return;
    }
    e := $select_vector(v, len-1);
    v' := $pop_back_vector(v);
}

function {:inline 1} $Vector_$pop_back(ta: $TypeValue, v: $Value): $Value {
    $select_vector(v, $vlen(v)-1)
}

procedure {:inline 1} $Vector_append(ta: $TypeValue, v: $Value, other: $Value) returns (v': $Value) {
    assume is#$Vector(v);
    assume is#$Vector(other);
    v' := $append_vector(v, other);
}

procedure {:inline 1} $Vector_reverse(ta: $TypeValue, v: $Value) returns (v': $Value) {
    assume is#$Vector(v);
    v' := $reverse_vector(v);
}

procedure {:inline 1} $Vector_length(ta: $TypeValue, v: $Value) returns (l: $Value) {
    assume is#$Vector(v);
    l := $Integer($vlen(v));
}

function {:inline 1} $Vector_$length(ta: $TypeValue, v: $Value): $Value {
    $Integer($vlen(v))
}

procedure {:inline 1} $Vector_borrow(ta: $TypeValue, v: $Value, i: $Value) returns (dst: $Value) {
    var i_ind: int;

    assume is#$Vector(v);
    assume is#$Integer(i);
    i_ind := i#$Integer(i);
    if (i_ind < 0 || i_ind >= $vlen(v)) {
        call $ExecFailureAbort();
        return;
    }
    dst := $select_vector(v, i_ind);
}

function {:inline 1} $Vector_$borrow(ta: $TypeValue, v: $Value, i: $Value): $Value {
    $select_vector(v, i#$Integer(i))
}

procedure {:inline 1} $Vector_borrow_mut(ta: $TypeValue, v: $Value, index: $Value) returns (dst: $Mutation, v': $Value)
free requires is#$Integer(index);
{
    var i_ind: int;

    i_ind := i#$Integer(index);
    assume is#$Vector(v);
    if (i_ind < 0 || i_ind >= $vlen(v)) {
        call $ExecFailureAbort();
        return;
    }
    dst := $Mutation($Local(0), $Path(p#$Path($EmptyPath)[0 := i_ind], 1), $select_vector(v, i_ind));
    v' := v;
}

function {:inline 1} $Vector_$borrow_mut(ta: $TypeValue, v: $Value, i: $Value): $Value {
    $select_vector(v, i#$Integer(i))
}

procedure {:inline 1} $Vector_destroy_empty(ta: $TypeValue, v: $Value) {
    if ($vlen(v) != 0) {
      call $ExecFailureAbort();
    }
}

procedure {:inline 1} $Vector_swap(ta: $TypeValue, v: $Value, i: $Value, j: $Value) returns (v': $Value)
free requires is#$Integer(i) && is#$Integer(j);
{
    var i_ind: int;
    var j_ind: int;
    assume is#$Vector(v);
    i_ind := i#$Integer(i);
    j_ind := i#$Integer(j);
    if (i_ind >= $vlen(v) || j_ind >= $vlen(v) || i_ind < 0 || j_ind < 0) {
        call $ExecFailureAbort();
        return;
    }
    v' := $swap_vector(v, i_ind, j_ind);
}

function {:inline 1} $Vector_$swap(ta: $TypeValue, v: $Value, i: $Value, j: $Value): $Value {
    $swap_vector(v, i#$Integer(i), i#$Integer(j))
}

procedure {:inline 1} $Vector_remove(ta: $TypeValue, v: $Value, i: $Value) returns (e: $Value, v': $Value)
free requires is#$Integer(i);
{
    var i_ind: int;

    assume is#$Vector(v);
    i_ind := i#$Integer(i);
    if (i_ind < 0 || i_ind >= $vlen(v)) {
        call $ExecFailureAbort();
        return;
    }
    e := $select_vector(v, i_ind);
    v' := $remove_vector(v, i_ind);
}

procedure {:inline 1} $Vector_swap_remove(ta: $TypeValue, v: $Value, i: $Value) returns (e: $Value, v': $Value)
free requires is#$Integer(i);
{
    var i_ind: int;
    var len: int;

    assume is#$Vector(v);
    i_ind := i#$Integer(i);
    len := $vlen(v);
    if (i_ind < 0 || i_ind >= len) {
        call $ExecFailureAbort();
        return;
    }
    e := $select_vector(v, i_ind);
    v' := $pop_back_vector($swap_vector(v, i_ind, len-1));
}

procedure {:inline 1} $Vector_contains(ta: $TypeValue, v: $Value, e: $Value) returns (res: $Value)  {
    assume is#$Vector(v);
    res := $Boolean($contains_vector(v, e));
}

// FIXME: This procedure sometimes (not always) make the test (performance_200511) very slow (> 10 mins) or hang
// although this is not used in the test script (performance_200511). The test finishes in 20 secs when it works fine.
procedure {:inline 1} $Vector_index_of(ta: $TypeValue, v: $Value, e: $Value) returns (res1: $Value, res2: $Value);
requires is#$Vector(v);
ensures is#$Boolean(res1);
ensures is#$Integer(res2);
ensures 0 <= i#$Integer(res2) && i#$Integer(res2) < $vlen(v);
ensures res1 == $Boolean($contains_vector(v, e));
ensures b#$Boolean(res1) ==> $IsEqual($select_vector(v,i#$Integer(res2)), e);
ensures b#$Boolean(res1) ==> (forall i:int :: 0<=i && i<i#$Integer(res2) ==> !$IsEqual($select_vector(v,i), e));
ensures !b#$Boolean(res1) ==> i#$Integer(res2) == 0;

// FIXME: This alternative definition has the same issue as the other one above.
// TODO: Delete this when unnecessary
//procedure {:inline 1} $Vector_index_of(ta: $TypeValue, v: $Value, e: $Value) returns (res1: $Value, res2: $Value) {
//    var b: bool;
//    var i: int;
//    assume is#$Vector(v);
//    b := $contains_vector(v, e);
//    if (b) {
//        havoc i;
//        assume 0 <= i && i < $vlen(v);
//        assume $IsEqual($select_vector(v,i), e);
//        assume (forall j:int :: 0<=j && j<i ==> !$IsEqual($select_vector(v,j), e));
//    }
//    else {
//        i := 0;
//    }
//    res1 := $Boolean(b);
//    res2 := $Integer(i);
//}

// ==================================================================================
// Native hash

// Hash is modeled as an otherwise uninterpreted injection.
// In truth, it is not an injection since the domain has greater cardinality
// (arbitrary length vectors) than the co-domain (vectors of length 32).  But it is
// common to assume in code there are no hash collisions in practice.  Fortunately,
// Boogie is not smart enough to recognized that there is an inconsistency.
// FIXME: If we were using a reliable extensional theory of arrays, and if we could use ==
// instead of $IsEqual, we might be able to avoid so many quantified formulas by
// using a sha2_inverse function in the ensures conditions of Hash_sha2_256 to
// assert that sha2/3 are injections without using global quantified axioms.


function {:inline} $Hash_sha2(val: $Value): $Value {
    $Hash_sha2_core(val)
}

function $Hash_sha2_core(val: $Value): $Value;

// This says that Hash_sha2 respects isEquals (this would be automatic if we had an
// extensional theory of arrays and used ==, which has the substitution property
// for functions).
axiom (forall v1,v2: $Value :: $Vector_$is_well_formed(v1) && $Vector_$is_well_formed(v2)
       && $IsEqual(v1, v2) ==> $IsEqual($Hash_sha2_core(v1), $Hash_sha2_core(v2)));

// This says that Hash_sha2 is an injection
axiom (forall v1,v2: $Value :: $Vector_$is_well_formed(v1) && $Vector_$is_well_formed(v2)
        && $IsEqual($Hash_sha2_core(v1), $Hash_sha2_core(v2)) ==> $IsEqual(v1, v2));

// This procedure has no body. We want Boogie to just use its requires
// and ensures properties when verifying code that calls it.
procedure $Hash_sha2_256(val: $Value) returns (res: $Value);
// It will still work without this, but this helps verifier find more reasonable counterexamples.
free requires $IsValidU8Vector(val);
ensures res == $Hash_sha2_core(val);     // returns Hash_sha2 Value
ensures $IsValidU8Vector(res);    // result is a legal vector of U8s.
ensures $vlen(res) == 32;               // result is 32 bytes.

// Spec version of Move native function.
function {:inline} $Hash_$sha2_256(val: $Value): $Value {
    $Hash_sha2_core(val)
}

// similarly for Hash_sha3
function {:inline} $Hash_sha3(val: $Value): $Value {
    $Hash_sha3_core(val)
}
function $Hash_sha3_core(val: $Value): $Value;

axiom (forall v1,v2: $Value :: $Vector_$is_well_formed(v1) && $Vector_$is_well_formed(v2)
       && $IsEqual(v1, v2) ==> $IsEqual($Hash_sha3_core(v1), $Hash_sha3_core(v2)));

axiom (forall v1,v2: $Value :: $Vector_$is_well_formed(v1) && $Vector_$is_well_formed(v2)
        && $IsEqual($Hash_sha3_core(v1), $Hash_sha3_core(v2)) ==> $IsEqual(v1, v2));

procedure $Hash_sha3_256(val: $Value) returns (res: $Value);
ensures res == $Hash_sha3_core(val);     // returns Hash_sha3 Value
ensures $IsValidU8Vector(res);    // result is a legal vector of U8s.
ensures $vlen(res) == 32;               // result is 32 bytes.

// Spec version of Move native function.
function {:inline} $Hash_$sha3_256(val: $Value): $Value {
    $Hash_sha3_core(val)
}

// ==================================================================================
// Native libra_account

procedure {:inline 1} $LibraAccount_create_signer(
  addr: $Value
) returns (signer: $Value) {
    // A signer is currently identical to an address.
    signer := addr;
}

procedure {:inline 1} $LibraAccount_destroy_signer(
  signer: $Value
) {
  return;
}

// ==================================================================================
// Native Signer

procedure {:inline 1} $Signer_borrow_address(signer: $Value) returns (res: $Value)
    free requires is#$Address(signer);
{
    res := signer;
}

// ==================================================================================
// Native signature

// Signature related functionality is handled via uninterpreted functions. This is sound
// currently because we verify every code path based on signature verification with
// an arbitrary interpretation.

function $Signature_$ed25519_validate_pubkey(public_key: $Value): $Value;
function $Signature_$ed25519_verify(signature: $Value, public_key: $Value, message: $Value): $Value;

axiom (forall public_key: $Value ::
        is#$Boolean($Signature_$ed25519_validate_pubkey(public_key)));

axiom (forall signature, public_key, message: $Value ::
        is#$Boolean($Signature_$ed25519_verify(signature, public_key, message)));


procedure {:inline 1} $Signature_ed25519_validate_pubkey(public_key: $Value) returns (res: $Value) {
    res := $Signature_$ed25519_validate_pubkey(public_key);
}

procedure {:inline 1} $Signature_ed25519_verify(
        signature: $Value, public_key: $Value, message: $Value) returns (res: $Value) {
    res := $Signature_$ed25519_verify(signature, public_key, message);
}

// ==================================================================================
// Native LCS::serialize

// native define serialize<MoveValue>(v: &MoveValue): vector<u8>;

// Serialize is modeled as an uninterpreted function, with an additional
// axiom to say it's an injection.

function {:inline} $LCS_serialize(ta: $TypeValue, v: $Value): $Value {
    $LCS_serialize_core(v)
}

function $LCS_serialize_core(v: $Value): $Value;
function $LCS_serialize_core_inv(v: $Value): $Value;
// Needed only because IsEqual(v1, v2) is weaker than v1 == v2 in case there is a vector nested inside v1 or v2.
axiom (forall v1, v2: $Value :: $IsEqual(v1, v2) ==> $LCS_serialize_core(v1) == $LCS_serialize_core(v2));
// Injectivity
axiom (forall v: $Value :: $LCS_serialize_core_inv($LCS_serialize_core(v)) == v);

// This says that serialize returns a non-empty vec<u8>

axiom (forall v: $Value :: ( var r := $LCS_serialize_core(v); $IsValidU8Vector(r) && $vlen(r) > 0 &&
                            $vlen(r) <= 4 ));


// Serialized addresses should have the same length
const $serialized_address_len: int;
axiom (forall v: $Value :: (var r := $LCS_serialize_core(v); is#$Address(v) ==> $vlen(r) == $serialized_address_len));

procedure $LCS_to_bytes(ta: $TypeValue, v: $Value) returns (res: $Value);
ensures res == $LCS_serialize(ta, v);
ensures $IsValidU8Vector(res);    // result is a legal vector of U8s.

function {:inline} $LCS_$to_bytes(ta: $TypeValue, v: $Value): $Value {
    $LCS_serialize_core(v)
}

// ==================================================================================
// Native Signer::spec_address_of

function {:inline} $Signer_spec_address_of(signer: $Value): $Value
{
    // A signer is currently identical to an address.
    signer
}

function {:inline} $Signer_$borrow_address(signer: $Value): $Value
{
    // A signer is currently identical to an address.
    signer
}

// ==================================================================================
// Mocked out Event module

procedure {:inline 1} $Event_new_event_handle(t: $TypeValue, signer: $Value) returns (res: $Value) {
}

procedure {:inline 1} $Event_publish_generator(account: $Value) {
}

procedure {:inline 1} $Event_emit_event(t: $TypeValue, handler: $Value, msg: $Value) returns (res: $Value) {
    res := handler;
}



// ** spec vars of module Signer



// ** spec funs of module Signer

function {:inline} $Signer_$address_of(s: $Value): $Value {
    $Signer_$borrow_address(s)
}



// ** structs of module Signer



// ** functions of module Signer

procedure {:inline 1} $Signer_address_of_$def(s: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $AddressType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(24, 407, 0, s); }

    // bytecode translation starts here
    // $t1 := move(s)
    call $t1 := $CopyOrMoveValue(s);

    // $t2 := Signer::borrow_address($t1)
    call $t2 := $Signer_borrow_address($t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(24, 324, $abort_code);
      goto Abort;
    }

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(24, 460, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Signer_address_of_$direct_inter(s: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Signer_spec_address_of(s)))));
ensures is#$Address($ret0);

procedure {:inline 1} $Signer_address_of_$direct_intra(s: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Signer_spec_address_of(s)))));
ensures is#$Address($ret0);

procedure {:inline 1} $Signer_address_of(s: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Signer_spec_address_of(s)))));
ensures is#$Address($ret0);



// ** spec vars of module Errors



// ** spec funs of module Errors



// ** structs of module Errors



// ** functions of module Errors

procedure {:inline 1} $Errors_already_published_$def(reason: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $IntegerType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(9, 3920, 0, reason); }

    // bytecode translation starts here
    // $t1 := move(reason)
    call $t1 := $CopyOrMoveValue(reason);

    // $t2 := 6
    $t2 := $Integer(6);

    // $t3 := Errors::make($t2, $t1)
    call $t3 := $Errors_make($t2, $t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(9, 1022, $abort_code);
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(9, 3969, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Errors_already_published_$direct_inter(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(6)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_already_published_$direct_intra(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(6)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_already_published(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(6)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_custom_$def(reason: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $IntegerType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(9, 4776, 0, reason); }

    // bytecode translation starts here
    // $t1 := move(reason)
    call $t1 := $CopyOrMoveValue(reason);

    // $t2 := 255
    $t2 := $Integer(255);

    // $t3 := Errors::make($t2, $t1)
    call $t3 := $Errors_make($t2, $t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(9, 1022, $abort_code);
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(9, 4814, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Errors_custom_$direct_inter(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(255)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_custom_$direct_intra(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(255)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_custom(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(255)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_internal_$def(reason: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $IntegerType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(9, 4585, 0, reason); }

    // bytecode translation starts here
    // $t1 := move(reason)
    call $t1 := $CopyOrMoveValue(reason);

    // $t2 := 10
    $t2 := $Integer(10);

    // $t3 := Errors::make($t2, $t1)
    call $t3 := $Errors_make($t2, $t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(9, 1022, $abort_code);
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(9, 4625, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Errors_internal_$direct_inter(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(10)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_internal_$direct_intra(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(10)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_internal(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(10)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_invalid_argument_$def(reason: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $IntegerType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(9, 4147, 0, reason); }

    // bytecode translation starts here
    // $t1 := move(reason)
    call $t1 := $CopyOrMoveValue(reason);

    // $t2 := 7
    $t2 := $Integer(7);

    // $t3 := Errors::make($t2, $t1)
    call $t3 := $Errors_make($t2, $t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(9, 1022, $abort_code);
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(9, 4195, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Errors_invalid_argument_$direct_inter(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(7)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_invalid_argument_$direct_intra(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(7)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_invalid_argument(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(7)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_invalid_state_$def(reason: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $IntegerType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(9, 2829, 0, reason); }

    // bytecode translation starts here
    // $t1 := move(reason)
    call $t1 := $CopyOrMoveValue(reason);

    // $t2 := 1
    $t2 := $Integer(1);

    // $t3 := Errors::make($t2, $t1)
    call $t3 := $Errors_make($t2, $t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(9, 1022, $abort_code);
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(9, 2874, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Errors_invalid_state_$direct_inter(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(1)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_invalid_state_$direct_intra(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(1)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_invalid_state(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(1)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_limit_exceeded_$def(reason: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $IntegerType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(9, 4370, 0, reason); }

    // bytecode translation starts here
    // $t1 := move(reason)
    call $t1 := $CopyOrMoveValue(reason);

    // $t2 := 8
    $t2 := $Integer(8);

    // $t3 := Errors::make($t2, $t1)
    call $t3 := $Errors_make($t2, $t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(9, 1022, $abort_code);
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(9, 4416, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Errors_limit_exceeded_$direct_inter(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(8)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_limit_exceeded_$direct_intra(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(8)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_limit_exceeded(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(8)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_make_$def(category: $Value, reason: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(9, 1018, 0, category); }
    if (true) { assume $DebugTrackLocal(9, 1018, 1, reason); }

    // bytecode translation starts here
    // $t2 := move(category)
    call $t2 := $CopyOrMoveValue(category);

    // $t3 := move(reason)
    call $t3 := $CopyOrMoveValue(reason);

    // $t4 := (u64)($t2)
    call $t4 := $CastU64($t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(9, 1069, $abort_code);
      goto Abort;
    }

    // $t5 := 8
    $t5 := $Integer(8);

    // $t6 := <<($t3, $t5)
    call $t6 := $Shl($t3, $t5);

    // $t7 := +($t4, $t6)
    call $t7 := $AddU64($t4, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(9, 1087, $abort_code);
      goto Abort;
    }

    // return $t7
    $ret0 := $t7;
    if (true) { assume $DebugTrackLocal(9, 1069, 8, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Errors_make_$direct_intra(category: $Value, reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, category))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_make(category: $Value, reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, category))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_not_published_$def(reason: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $IntegerType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(9, 3709, 0, reason); }

    // bytecode translation starts here
    // $t1 := move(reason)
    call $t1 := $CopyOrMoveValue(reason);

    // $t2 := 5
    $t2 := $Integer(5);

    // $t3 := Errors::make($t2, $t1)
    call $t3 := $Errors_make($t2, $t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(9, 1022, $abort_code);
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(9, 3754, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Errors_not_published_$direct_inter(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(5)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_not_published_$direct_intra(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(5)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_not_published(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(5)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_requires_address_$def(reason: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $IntegerType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(9, 3040, 0, reason); }

    // bytecode translation starts here
    // $t1 := move(reason)
    call $t1 := $CopyOrMoveValue(reason);

    // $t2 := 2
    $t2 := $Integer(2);

    // $t3 := Errors::make($t2, $t1)
    call $t3 := $Errors_make($t2, $t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(9, 1022, $abort_code);
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(9, 3088, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Errors_requires_address_$direct_inter(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(2)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_requires_address_$direct_intra(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(2)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_requires_address(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(2)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_requires_capability_$def(reason: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $IntegerType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(9, 3474, 0, reason); }

    // bytecode translation starts here
    // $t1 := move(reason)
    call $t1 := $CopyOrMoveValue(reason);

    // $t2 := 4
    $t2 := $Integer(4);

    // $t3 := Errors::make($t2, $t1)
    call $t3 := $Errors_make($t2, $t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(9, 1022, $abort_code);
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(9, 3525, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Errors_requires_capability_$direct_inter(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(4)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_requires_capability_$direct_intra(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(4)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_requires_capability(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(4)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_requires_role_$def(reason: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $IntegerType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(9, 3263, 0, reason); }

    // bytecode translation starts here
    // $t1 := move(reason)
    call $t1 := $CopyOrMoveValue(reason);

    // $t2 := 3
    $t2 := $Integer(3);

    // $t3 := Errors::make($t2, $t1)
    call $t3 := $Errors_make($t2, $t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(9, 1022, $abort_code);
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(9, 3308, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Errors_requires_role_$direct_inter(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(3)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_requires_role_$direct_intra(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(3)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Errors_requires_role(reason: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(3)))));
ensures $IsValidU64($ret0);



// ** spec vars of module CoreAddresses



// ** spec funs of module CoreAddresses

function {:inline} $CoreAddresses_$CURRENCY_INFO_ADDRESS(): $Value {
    $Address(173345816)
}

function {:inline} $CoreAddresses_$LIBRA_ROOT_ADDRESS(): $Value {
    $Address(173345816)
}

function {:inline} $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS(): $Value {
    $Address(186537453)
}

function {:inline} $CoreAddresses_$VM_RESERVED_ADDRESS(): $Value {
    $Address(0)
}



// ** structs of module CoreAddresses



// ** functions of module CoreAddresses

procedure {:inline 1} $CoreAddresses_CURRENCY_INFO_ADDRESS_$def() returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $AddressType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := 0xa550c18
    $t0 := $Address(173345816);

    // return $t0
    $ret0 := $t0;
    if (true) { assume $DebugTrackLocal(6, 1127, 1, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $CoreAddresses_CURRENCY_INFO_ADDRESS_$direct_inter() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_CURRENCY_INFO_ADDRESS_$def();
}


procedure {:inline 1} $CoreAddresses_CURRENCY_INFO_ADDRESS_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_CURRENCY_INFO_ADDRESS_$def();
}


procedure {:inline 1} $CoreAddresses_CURRENCY_INFO_ADDRESS() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_CURRENCY_INFO_ADDRESS_$def();
}


procedure {:inline 1} $CoreAddresses_LIBRA_ROOT_ADDRESS_$def() returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $AddressType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := 0xa550c18
    $t0 := $Address(173345816);

    // return $t0
    $ret0 := $t0;
    if (true) { assume $DebugTrackLocal(6, 737, 1, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $CoreAddresses_LIBRA_ROOT_ADDRESS_$direct_inter() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_LIBRA_ROOT_ADDRESS_$def();
}


procedure {:inline 1} $CoreAddresses_LIBRA_ROOT_ADDRESS_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_LIBRA_ROOT_ADDRESS_$def();
}


procedure {:inline 1} $CoreAddresses_LIBRA_ROOT_ADDRESS() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_LIBRA_ROOT_ADDRESS_$def();
}


procedure {:inline 1} $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS_$def() returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $AddressType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := 0xb1e55ed
    $t0 := $Address(186537453);

    // return $t0
    $ret0 := $t0;
    if (true) { assume $DebugTrackLocal(6, 1419, 1, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS_$direct_inter() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS_$def();
}


procedure {:inline 1} $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS_$def();
}


procedure {:inline 1} $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS_$def();
}


procedure {:inline 1} $CoreAddresses_VM_RESERVED_ADDRESS_$def() returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $AddressType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := 0x0
    $t0 := $Address(0);

    // return $t0
    $ret0 := $t0;
    if (true) { assume $DebugTrackLocal(6, 1767, 1, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $CoreAddresses_VM_RESERVED_ADDRESS_$direct_inter() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_VM_RESERVED_ADDRESS_$def();
}


procedure {:inline 1} $CoreAddresses_VM_RESERVED_ADDRESS_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_VM_RESERVED_ADDRESS_$def();
}


procedure {:inline 1} $CoreAddresses_VM_RESERVED_ADDRESS() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_VM_RESERVED_ADDRESS_$def();
}


procedure {:inline 1} $CoreAddresses_assert_currency_info_$def(account: $Value) returns ()
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(6, 4250, 0, account); }

    // bytecode translation starts here
    // $t3 := move(account)
    call $t3 := $CopyOrMoveValue(account);

    // $t4 := Signer::address_of($t3)
    call $t4 := $Signer_address_of($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 4325, $abort_code);
      goto Abort;
    }

    // $t5 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t5 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t6 := ==($t4, $t5)
    $t6 := $Boolean($IsEqual($t4, $t5));

    // $t7 := 4
    $t7 := $Integer(4);

    // $t8 := Errors::requires_address($t7)
    call $t8 := $Errors_requires_address($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 4381, $abort_code);
      goto Abort;
    }

    // if ($t6) goto L0 else goto L1
    if (b#$Boolean($t6)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t8)
    if (true) { assume $DebugTrackAbort(6, 4310, i#$Integer($t8)); }
    $abort_code := i#$Integer($t8);
    goto Abort;

    // L0:
L0:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $CoreAddresses_assert_currency_info_$direct_inter(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$CURRENCY_INFO_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$CURRENCY_INFO_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$CURRENCY_INFO_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));

procedure {:inline 1} $CoreAddresses_assert_currency_info_$direct_intra(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$CURRENCY_INFO_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$CURRENCY_INFO_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$CURRENCY_INFO_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));

procedure {:inline 1} $CoreAddresses_assert_currency_info(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$CURRENCY_INFO_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$CURRENCY_INFO_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$CURRENCY_INFO_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));

procedure {:inline 1} $CoreAddresses_assert_libra_root_$def(account: $Value) returns ()
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(6, 2357, 0, account); }

    // bytecode translation starts here
    // $t3 := move(account)
    call $t3 := $CopyOrMoveValue(account);

    // $t4 := Signer::address_of($t3)
    call $t4 := $Signer_address_of($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 2429, $abort_code);
      goto Abort;
    }

    // $t5 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t5 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t6 := ==($t4, $t5)
    $t6 := $Boolean($IsEqual($t4, $t5));

    // $t7 := 0
    $t7 := $Integer(0);

    // $t8 := Errors::requires_address($t7)
    call $t8 := $Errors_requires_address($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 2482, $abort_code);
      goto Abort;
    }

    // if ($t6) goto L0 else goto L1
    if (b#$Boolean($t6)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t8)
    if (true) { assume $DebugTrackAbort(6, 2414, i#$Integer($t8)); }
    $abort_code := i#$Integer($t8);
    goto Abort;

    // L0:
L0:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $CoreAddresses_assert_libra_root_$direct_inter(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));

procedure {:inline 1} $CoreAddresses_assert_libra_root_$direct_intra(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));

procedure {:inline 1} $CoreAddresses_assert_libra_root(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));

procedure {:inline 1} $CoreAddresses_assert_treasury_compliance_$def(account: $Value) returns ()
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(6, 2969, 0, account); }

    // bytecode translation starts here
    // $t3 := move(account)
    call $t3 := $CopyOrMoveValue(account);

    // $t4 := Signer::address_of($t3)
    call $t4 := $Signer_address_of($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 3063, $abort_code);
      goto Abort;
    }

    // $t5 := CoreAddresses::TREASURY_COMPLIANCE_ADDRESS()
    call $t5 := $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t6 := ==($t4, $t5)
    $t6 := $Boolean($IsEqual($t4, $t5));

    // $t7 := 1
    $t7 := $Integer(1);

    // $t8 := Errors::requires_address($t7)
    call $t8 := $Errors_requires_address($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 3137, $abort_code);
      goto Abort;
    }

    // if ($t6) goto L0 else goto L1
    if (b#$Boolean($t6)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t8)
    if (true) { assume $DebugTrackAbort(6, 3035, i#$Integer($t8)); }
    $abort_code := i#$Integer($t8);
    goto Abort;

    // L0:
L0:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $CoreAddresses_assert_treasury_compliance_$direct_inter(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));

procedure {:inline 1} $CoreAddresses_assert_treasury_compliance_$direct_intra(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));

procedure {:inline 1} $CoreAddresses_assert_treasury_compliance(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));

procedure {:inline 1} $CoreAddresses_assert_vm_$def(account: $Value) returns ()
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(6, 3679, 0, account); }

    // bytecode translation starts here
    // $t3 := move(account)
    call $t3 := $CopyOrMoveValue(account);

    // $t4 := Signer::address_of($t3)
    call $t4 := $Signer_address_of($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 3743, $abort_code);
      goto Abort;
    }

    // $t5 := CoreAddresses::VM_RESERVED_ADDRESS()
    call $t5 := $CoreAddresses_VM_RESERVED_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t6 := ==($t4, $t5)
    $t6 := $Boolean($IsEqual($t4, $t5));

    // $t7 := 2
    $t7 := $Integer(2);

    // $t8 := Errors::requires_address($t7)
    call $t8 := $Errors_requires_address($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 3797, $abort_code);
      goto Abort;
    }

    // if ($t6) goto L0 else goto L1
    if (b#$Boolean($t6)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t8)
    if (true) { assume $DebugTrackAbort(6, 3728, i#$Integer($t8)); }
    $abort_code := i#$Integer($t8);
    goto Abort;

    // L0:
L0:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $CoreAddresses_assert_vm_$direct_inter(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$VM_RESERVED_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$VM_RESERVED_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$VM_RESERVED_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));

procedure {:inline 1} $CoreAddresses_assert_vm_$direct_intra(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$VM_RESERVED_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$VM_RESERVED_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$VM_RESERVED_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));

procedure {:inline 1} $CoreAddresses_assert_vm(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$VM_RESERVED_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$VM_RESERVED_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$VM_RESERVED_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));



// ** spec vars of module LibraTimestamp



// ** spec funs of module LibraTimestamp

function {:inline} $LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory): $Value {
    $Boolean(!b#$Boolean($ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $CoreAddresses_$LIBRA_ROOT_ADDRESS())))
}

function {:inline} $LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory): $Value {
    $ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $CoreAddresses_$LIBRA_ROOT_ADDRESS())
}

function {:inline} $LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory): $Value {
    $SelectField($ResourceValue($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $CoreAddresses_$LIBRA_ROOT_ADDRESS()), $LibraTimestamp_CurrentTimeMicroseconds_microseconds)
}

function {:inline} $LibraTimestamp_spec_now_seconds($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory): $Value {
    $Integer(i#$Integer($SelectField($ResourceValue($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $CoreAddresses_$LIBRA_ROOT_ADDRESS()), $LibraTimestamp_CurrentTimeMicroseconds_microseconds)) div i#$Integer($Integer(1000000)))
}

function {:inline} $LibraTimestamp_now$10($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory): $Value {
    $LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)
}



// ** structs of module LibraTimestamp

const unique $LibraTimestamp_CurrentTimeMicroseconds: $TypeName;
const $LibraTimestamp_CurrentTimeMicroseconds_microseconds: $FieldName;
axiom $LibraTimestamp_CurrentTimeMicroseconds_microseconds == 0;
function $LibraTimestamp_CurrentTimeMicroseconds_type_value(): $TypeValue {
    $StructType($LibraTimestamp_CurrentTimeMicroseconds, $EmptyTypeValueArray)
}
var $LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory;
var $LibraTimestamp_CurrentTimeMicroseconds_$memory_$old: $Memory;
function {:inline} $LibraTimestamp_CurrentTimeMicroseconds_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $LibraTimestamp_CurrentTimeMicroseconds_microseconds))
}
function {:inline} $LibraTimestamp_CurrentTimeMicroseconds_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $LibraTimestamp_CurrentTimeMicroseconds_$is_well_formed($this: $Value): bool {
    $LibraTimestamp_CurrentTimeMicroseconds_$is_well_typed($this) && $LibraTimestamp_CurrentTimeMicroseconds_$invariant_holds($this)}

procedure {:inline 1} $LibraTimestamp_CurrentTimeMicroseconds_pack($file_id: int, $byte_index: int, $var_idx: int, microseconds: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(microseconds);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := microseconds], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraTimestamp_CurrentTimeMicroseconds_unpack($struct: $Value) returns (microseconds: $Value)
{
    assume is#$Vector($struct);
    microseconds := $SelectField($struct, $LibraTimestamp_CurrentTimeMicroseconds_microseconds);
    assume $IsValidU64(microseconds);
}



// ** functions of module LibraTimestamp

procedure {:inline 1} $LibraTimestamp_assert_genesis_$def() returns ()
{
    // declare local variables
    var tmp#$0: $Value; // $BooleanType()
    var tmp#$1: $Value; // $IntegerType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t2 := LibraTimestamp::is_genesis()
    call $t2 := $LibraTimestamp_is_genesis();
    if ($abort_flag) {
      goto Abort;
    }

    // $t3 := 0
    $t3 := $Integer(0);

    // $t4 := Errors::invalid_state($t3)
    call $t4 := $Errors_invalid_state($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(18, 4968, $abort_code);
      goto Abort;
    }

    // if ($t2) goto L0 else goto L1
    if (b#$Boolean($t2)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t4)
    if (true) { assume $DebugTrackAbort(18, 4939, i#$Integer($t4)); }
    $abort_code := i#$Integer($t4);
    goto Abort;

    // L0:
L0:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraTimestamp_assert_genesis_$direct_inter() returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1))));

procedure {:inline 1} $LibraTimestamp_assert_genesis_$direct_intra() returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1))));

procedure {:inline 1} $LibraTimestamp_assert_genesis() returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1))));

procedure {:inline 1} $LibraTimestamp_assert_operating_$def() returns ()
{
    // declare local variables
    var tmp#$0: $Value; // $BooleanType()
    var tmp#$1: $Value; // $IntegerType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t2 := LibraTimestamp::is_operating()
    call $t2 := $LibraTimestamp_is_operating();
    if ($abort_flag) {
      goto Abort;
    }

    // $t3 := 1
    $t3 := $Integer(1);

    // $t4 := Errors::invalid_state($t3)
    call $t4 := $Errors_invalid_state($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(18, 5745, $abort_code);
      goto Abort;
    }

    // if ($t2) goto L0 else goto L1
    if (b#$Boolean($t2)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t4)
    if (true) { assume $DebugTrackAbort(18, 5714, i#$Integer($t4)); }
    $abort_code := i#$Integer($t4);
    goto Abort;

    // L0:
L0:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraTimestamp_assert_operating_$direct_inter() returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1))));

procedure {:inline 1} $LibraTimestamp_assert_operating_$direct_intra() returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1))));

procedure {:inline 1} $LibraTimestamp_assert_operating() returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1))));

procedure {:inline 1} $LibraTimestamp_is_genesis_$def() returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $BooleanType()
    var $t2: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t0 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t1 := exists<LibraTimestamp::CurrentTimeMicroseconds>($t0)
    $t1 := $ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $t0);

    // $t2 := !($t1)
    call $t2 := $Not($t1);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(18, 4771, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraTimestamp_is_genesis_$direct_inter() returns ($ret0: $Value)
{
    call $ret0 := $LibraTimestamp_is_genesis_$def();
}


procedure {:inline 1} $LibraTimestamp_is_genesis_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $LibraTimestamp_is_genesis_$def();
}


procedure {:inline 1} $LibraTimestamp_is_genesis() returns ($ret0: $Value)
{
    call $ret0 := $LibraTimestamp_is_genesis_$def();
}


procedure {:inline 1} $LibraTimestamp_is_operating_$def() returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t0 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t1 := exists<LibraTimestamp::CurrentTimeMicroseconds>($t0)
    $t1 := $ResourceExists($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $t0);

    // return $t1
    $ret0 := $t1;
    if (true) { assume $DebugTrackLocal(18, 5532, 2, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraTimestamp_is_operating_$direct_inter() returns ($ret0: $Value)
{
    call $ret0 := $LibraTimestamp_is_operating_$def();
}


procedure {:inline 1} $LibraTimestamp_is_operating_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $LibraTimestamp_is_operating_$def();
}


procedure {:inline 1} $LibraTimestamp_is_operating() returns ($ret0: $Value)
{
    call $ret0 := $LibraTimestamp_is_operating_$def();
}


procedure {:inline 1} $LibraTimestamp_now_microseconds_$def() returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $LibraTimestamp_CurrentTimeMicroseconds_type_value()
    var $t2: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // LibraTimestamp::assert_operating()
    call $LibraTimestamp_assert_operating();
    if ($abort_flag) {
      assume $DebugTrackAbort(18, 5685, $abort_code);
      goto Abort;
    }

    // $t0 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t0 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t1 := get_global<LibraTimestamp::CurrentTimeMicroseconds>($t0)
    call $t1 := $GetGlobal($LibraTimestamp_CurrentTimeMicroseconds_$memory, $t0, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(18, 3764, $abort_code);
      goto Abort;
    }

    // $t2 := get_field<LibraTimestamp::CurrentTimeMicroseconds>.microseconds($t1)
    call $t2 := $GetFieldFromValue($t1, $LibraTimestamp_CurrentTimeMicroseconds_microseconds);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(18, 3764, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraTimestamp_now_microseconds_$direct_inter() returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $LibraTimestamp_now_microseconds_$direct_intra() returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $LibraTimestamp_now_microseconds() returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $LibraTimestamp_now_seconds_$def() returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $IntegerType()
    var $t1: $Value; // $IntegerType()
    var $t2: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := LibraTimestamp::now_microseconds()
    call $t0 := $LibraTimestamp_now_microseconds();
    if ($abort_flag) {
      assume $DebugTrackAbort(18, 3669, $abort_code);
      goto Abort;
    }

    // $t1 := 1000000
    $t1 := $Integer(1000000);

    // $t2 := /($t0, $t1)
    call $t2 := $Div($t0, $t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(18, 4291, $abort_code);
      goto Abort;
    }

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(18, 4272, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraTimestamp_now_seconds_$direct_inter() returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) div i#$Integer($Integer(1000000)))))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $LibraTimestamp_now_seconds_$direct_intra() returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) div i#$Integer($Integer(1000000)))))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $LibraTimestamp_now_seconds() returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Integer(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) div i#$Integer($Integer(1000000)))))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $LibraTimestamp_set_time_has_started_$def(lr_account: $Value) returns ()
{
    // declare local variables
    var timer: $Value; // $LibraTimestamp_CurrentTimeMicroseconds_type_value()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $LibraTimestamp_CurrentTimeMicroseconds_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(18, 1644, 0, lr_account); }

    // bytecode translation starts here
    // $t2 := move(lr_account)
    call $t2 := $CopyOrMoveValue(lr_account);

    // LibraTimestamp::assert_genesis()
    call $LibraTimestamp_assert_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(18, 4912, $abort_code);
      goto Abort;
    }

    // CoreAddresses::assert_libra_root($t2)
    call $CoreAddresses_assert_libra_root($t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(18, 1748, $abort_code);
      goto Abort;
    }

    // $t3 := 0
    $t3 := $Integer(0);

    // $t4 := pack LibraTimestamp::CurrentTimeMicroseconds($t3)
    call $t4 := $LibraTimestamp_CurrentTimeMicroseconds_pack(0, 0, 0, $t3);

    // move_to<LibraTimestamp::CurrentTimeMicroseconds>($t4, $t2)
    call $LibraTimestamp_CurrentTimeMicroseconds_$memory := $MoveTo($LibraTimestamp_CurrentTimeMicroseconds_$memory, $EmptyTypeValueArray, $t4, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(18, 1852, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraTimestamp_set_time_has_started_$direct_inter(lr_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    call $LibraTimestamp_set_time_has_started_$def(lr_account);
}


procedure {:inline 1} $LibraTimestamp_set_time_has_started_$direct_intra(lr_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    call $LibraTimestamp_set_time_has_started_$def(lr_account);
}


procedure {:inline 1} $LibraTimestamp_set_time_has_started(lr_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    call $LibraTimestamp_set_time_has_started_$def(lr_account);
}


procedure {:inline 1} $LibraTimestamp_update_global_time_$def(account: $Value, proposer: $Value, timestamp: $Value) returns ()
{
    // declare local variables
    var global_timer: $Mutation; // ReferenceType($LibraTimestamp_CurrentTimeMicroseconds_type_value())
    var now: $Value; // $IntegerType()
    var tmp#$5: $Value; // $BooleanType()
    var tmp#$6: $Value; // $IntegerType()
    var tmp#$7: $Value; // $BooleanType()
    var tmp#$8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Mutation; // ReferenceType($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(18, 2190, 0, account); }
    if (true) { assume $DebugTrackLocal(18, 2190, 1, proposer); }
    if (true) { assume $DebugTrackLocal(18, 2190, 2, timestamp); }

    // bytecode translation starts here
    // $t9 := move(account)
    call $t9 := $CopyOrMoveValue(account);

    // $t10 := move(proposer)
    call $t10 := $CopyOrMoveValue(proposer);

    // $t11 := move(timestamp)
    call $t11 := $CopyOrMoveValue(timestamp);

    // LibraTimestamp::assert_operating()
    call $LibraTimestamp_assert_operating();
    if ($abort_flag) {
      assume $DebugTrackAbort(18, 5685, $abort_code);
      goto Abort;
    }

    // CoreAddresses::assert_vm($t9)
    call $CoreAddresses_assert_vm($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(18, 2439, $abort_code);
      goto Abort;
    }

    // $t12 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t12 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // global_timer := borrow_global<LibraTimestamp::CurrentTimeMicroseconds>($t12)
    call global_timer := $BorrowGlobal($LibraTimestamp_CurrentTimeMicroseconds_$memory, $t12, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(18, 2487, $abort_code);
      goto Abort;
    }

    // unpack_ref(global_timer)

    // $t13 := get_field<LibraTimestamp::CurrentTimeMicroseconds>.microseconds(global_timer)
    call $t13 := $GetFieldFromReference(global_timer, $LibraTimestamp_CurrentTimeMicroseconds_microseconds);

    // now := $t13
    call now := $CopyOrMoveValue($t13);
    if (true) { assume $DebugTrackLocal(18, 2580, 4, now); }

    // $t14 := CoreAddresses::VM_RESERVED_ADDRESS()
    call $t14 := $CoreAddresses_VM_RESERVED_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t15 := ==($t10, $t14)
    $t15 := $Boolean($IsEqual($t10, $t14));

    // if ($t15) goto L0 else goto L1
    if (b#$Boolean($t15)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t16 := ==(now, $t11)
    $t16 := $Boolean($IsEqual(now, $t11));

    // $t17 := 2
    $t17 := $Integer(2);

    // $t18 := Errors::invalid_argument($t17)
    call $t18 := $Errors_invalid_argument($t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(18, 2803, $abort_code);
      goto Abort;
    }

    // if ($t16) goto L3 else goto L4
    if (b#$Boolean($t16)) { goto L3; } else { goto L4; }

    // L4:
L4:

    // destroy(global_timer)

    // pack_ref(global_timer)

    // abort($t18)
    if (true) { assume $DebugTrackAbort(18, 2770, i#$Integer($t18)); }
    $abort_code := i#$Integer($t18);
    goto Abort;

    // L3:
L3:

    // goto L5
    goto L5;

    // L2:
L2:

    // $t19 := <(now, $t11)
    call $t19 := $Lt(now, $t11);

    // $t20 := 2
    $t20 := $Integer(2);

    // $t21 := Errors::invalid_argument($t20)
    call $t21 := $Errors_invalid_argument($t20);
    if ($abort_flag) {
      assume $DebugTrackAbort(18, 2942, $abort_code);
      goto Abort;
    }

    // if ($t19) goto L5 else goto L6
    if (b#$Boolean($t19)) { goto L5; } else { goto L6; }

    // L6:
L6:

    // destroy(global_timer)

    // pack_ref(global_timer)

    // abort($t21)
    if (true) { assume $DebugTrackAbort(18, 2910, i#$Integer($t21)); }
    $abort_code := i#$Integer($t21);
    goto Abort;

    // L5:
L5:

    // $t22 := borrow_field<LibraTimestamp::CurrentTimeMicroseconds>.microseconds(global_timer)
    call $t22 := $BorrowField(global_timer, $LibraTimestamp_CurrentTimeMicroseconds_microseconds);

    // unpack_ref($t22)

    // write_ref($t22, $t11)
    call $t22 := $WriteRef($t22, $t11);
    if (true) { assume $DebugTrackLocal(18, 2992, 3, $Dereference(global_timer)); }

    // pack_ref($t22)

    // write_back[Reference(global_timer)]($t22)
    call global_timer := $WritebackToReference($t22, global_timer);

    // pack_ref(global_timer)

    // write_back[LibraTimestamp::CurrentTimeMicroseconds](global_timer)
    call $LibraTimestamp_CurrentTimeMicroseconds_$memory := $WritebackToGlobal($LibraTimestamp_CurrentTimeMicroseconds_$memory, global_timer);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraTimestamp_update_global_time_$direct_inter(account: $Value, proposer: $Value, timestamp: $Value) returns ()
{
    assume is#$Address(account);

    assume is#$Address(proposer);

    assume $IsValidU64(timestamp);

    assume !b#$Boolean(if (b#$Boolean($Boolean($IsEqual(proposer, $CoreAddresses_$VM_RESERVED_ADDRESS())))) then ($Boolean(!$IsEqual($LibraTimestamp_now$10($LibraTimestamp_CurrentTimeMicroseconds_$memory), timestamp))) else ($Boolean(i#$Integer($LibraTimestamp_now$10($LibraTimestamp_CurrentTimeMicroseconds_$memory)) >= i#$Integer(timestamp))));
    call $LibraTimestamp_update_global_time_$def(account, proposer, timestamp);
}


procedure {:inline 1} $LibraTimestamp_update_global_time_$direct_intra(account: $Value, proposer: $Value, timestamp: $Value) returns ()
{
    assume is#$Address(account);

    assume is#$Address(proposer);

    assume $IsValidU64(timestamp);

    assume !b#$Boolean(if (b#$Boolean($Boolean($IsEqual(proposer, $CoreAddresses_$VM_RESERVED_ADDRESS())))) then ($Boolean(!$IsEqual($LibraTimestamp_now$10($LibraTimestamp_CurrentTimeMicroseconds_$memory), timestamp))) else ($Boolean(i#$Integer($LibraTimestamp_now$10($LibraTimestamp_CurrentTimeMicroseconds_$memory)) >= i#$Integer(timestamp))));
    call $LibraTimestamp_update_global_time_$def(account, proposer, timestamp);
}


procedure {:inline 1} $LibraTimestamp_update_global_time(account: $Value, proposer: $Value, timestamp: $Value) returns ()
{
    assume is#$Address(account);

    assume is#$Address(proposer);

    assume $IsValidU64(timestamp);

    assume !b#$Boolean(if (b#$Boolean($Boolean($IsEqual(proposer, $CoreAddresses_$VM_RESERVED_ADDRESS())))) then ($Boolean(!$IsEqual($LibraTimestamp_now$10($LibraTimestamp_CurrentTimeMicroseconds_$memory), timestamp))) else ($Boolean(i#$Integer($LibraTimestamp_now$10($LibraTimestamp_CurrentTimeMicroseconds_$memory)) >= i#$Integer(timestamp))));
    call $LibraTimestamp_update_global_time_$def(account, proposer, timestamp);
}




// ** spec vars of module Roles



// ** spec funs of module Roles

function {:inline} $Roles_$can_hold_balance($Roles_RoleId_$memory: $Memory, account: $Value): $Value {
    $Boolean(b#$Boolean($Boolean(b#$Boolean($Roles_$has_parent_VASP_role($Roles_RoleId_$memory, account)) || b#$Boolean($Roles_$has_child_VASP_role($Roles_RoleId_$memory, account)))) || b#$Boolean($Roles_$has_designated_dealer_role($Roles_RoleId_$memory, account)))
}

function {:inline} $Roles_$has_child_VASP_role($Roles_RoleId_$memory: $Memory, account: $Value): $Value {
    $Roles_$has_role($Roles_RoleId_$memory, account, $Integer(6))
}

function {:inline} $Roles_$has_designated_dealer_role($Roles_RoleId_$memory: $Memory, account: $Value): $Value {
    $Roles_$has_role($Roles_RoleId_$memory, account, $Integer(2))
}

function {:inline} $Roles_$has_libra_root_role($Roles_RoleId_$memory: $Memory, account: $Value): $Value {
    $Roles_$has_role($Roles_RoleId_$memory, account, $Integer(0))
}

function {:inline} $Roles_$has_parent_VASP_role($Roles_RoleId_$memory: $Memory, account: $Value): $Value {
    $Roles_$has_role($Roles_RoleId_$memory, account, $Integer(5))
}

function {:inline} $Roles_$has_role($Roles_RoleId_$memory: $Memory, account: $Value, role_id: $Value): $Value {
    (var addr := $Signer_$address_of(account); $Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), role_id)))))
}

function {:inline} $Roles_spec_get_role_id($Roles_RoleId_$memory: $Memory, account: $Value): $Value {
    (var addr := $Signer_spec_address_of(account); $SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id))
}

function {:inline} $Roles_spec_has_role_id_addr($Roles_RoleId_$memory: $Memory, addr: $Value, role_id: $Value): $Value {
    $Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), role_id))))
}

function {:inline} $Roles_spec_has_libra_root_role_addr($Roles_RoleId_$memory: $Memory, addr: $Value): $Value {
    $Roles_spec_has_role_id_addr($Roles_RoleId_$memory, addr, $Integer(0))
}

function {:inline} $Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory: $Memory, addr: $Value): $Value {
    $Roles_spec_has_role_id_addr($Roles_RoleId_$memory, addr, $Integer(1))
}

function {:inline} $Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory: $Memory, addr: $Value): $Value {
    $Roles_spec_has_role_id_addr($Roles_RoleId_$memory, addr, $Integer(2))
}

function {:inline} $Roles_spec_has_validator_role_addr($Roles_RoleId_$memory: $Memory, addr: $Value): $Value {
    $Roles_spec_has_role_id_addr($Roles_RoleId_$memory, addr, $Integer(3))
}

function {:inline} $Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory: $Memory, addr: $Value): $Value {
    $Roles_spec_has_role_id_addr($Roles_RoleId_$memory, addr, $Integer(4))
}

function {:inline} $Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory: $Memory, addr: $Value): $Value {
    $Roles_spec_has_role_id_addr($Roles_RoleId_$memory, addr, $Integer(5))
}

function {:inline} $Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory: $Memory, addr: $Value): $Value {
    $Roles_spec_has_role_id_addr($Roles_RoleId_$memory, addr, $Integer(6))
}

function {:inline} $Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory: $Memory, addr: $Value): $Value {
    $Boolean(b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr)) || b#$Boolean($Roles_spec_has_child_VASP_role_addr($Roles_RoleId_$memory, addr)))) || b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)))
}

function {:inline} $Roles_addr$36(account: $Value): $Value {
    $Signer_spec_address_of(account)
}

function {:inline} $Roles_addr$37(account: $Value): $Value {
    $Signer_spec_address_of(account)
}

function {:inline} $Roles_addr$38(account: $Value): $Value {
    $Signer_spec_address_of(account)
}

function {:inline} $Roles_addr$39(account: $Value): $Value {
    $Signer_spec_address_of(account)
}

function {:inline} $Roles_addr$40(account: $Value): $Value {
    $Signer_spec_address_of(account)
}

function {:inline} $Roles_role_id$41($Roles_RoleId_$memory: $Memory, account: $Value): $Value {
    $SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$40(account)), $Roles_RoleId_role_id)
}

function {:inline} $Roles_addr$42(account: $Value): $Value {
    $Signer_spec_address_of(account)
}

function {:inline} $Roles_role_id$43($Roles_RoleId_$memory: $Memory, account: $Value): $Value {
    $SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$42(account)), $Roles_RoleId_role_id)
}

function {:inline} $Roles_addr$44(account: $Value): $Value {
    $Signer_spec_address_of(account)
}



// ** structs of module Roles

const unique $Roles_RoleId: $TypeName;
const $Roles_RoleId_role_id: $FieldName;
axiom $Roles_RoleId_role_id == 0;
function $Roles_RoleId_type_value(): $TypeValue {
    $StructType($Roles_RoleId, $EmptyTypeValueArray)
}
var $Roles_RoleId_$memory: $Memory;
var $Roles_RoleId_$memory_$old: $Memory;
function {:inline} $Roles_RoleId_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $Roles_RoleId_role_id))
}
function {:inline} $Roles_RoleId_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $Roles_RoleId_$is_well_formed($this: $Value): bool {
    $Roles_RoleId_$is_well_typed($this) && $Roles_RoleId_$invariant_holds($this)}

procedure {:inline 1} $Roles_RoleId_pack($file_id: int, $byte_index: int, $var_idx: int, role_id: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(role_id);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := role_id], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Roles_RoleId_unpack($struct: $Value) returns (role_id: $Value)
{
    assume is#$Vector($struct);
    role_id := $SelectField($struct, $Roles_RoleId_role_id);
    assume $IsValidU64(role_id);
}



// ** functions of module Roles

procedure {:inline 1} $Roles_assert_libra_root_$def(account: $Value) returns ()
{
    // declare local variables
    var addr: $Value; // $AddressType()
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $Roles_RoleId_type_value()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 11491, 0, account); }

    // bytecode translation starts here
    // $t6 := move(account)
    call $t6 := $CopyOrMoveValue(account);

    // CoreAddresses::assert_libra_root($t6)
    call $CoreAddresses_assert_libra_root($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 11579, $abort_code);
      goto Abort;
    }

    // addr := Signer::address_of($t6)
    call addr := $Signer_address_of($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 11634, $abort_code);
      goto Abort;
    }

    // $t7 := exists<Roles::RoleId>(addr)
    $t7 := $ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr);

    // $t8 := 0
    $t8 := $Integer(0);

    // $t9 := Errors::not_published($t8)
    call $t9 := $Errors_not_published($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 11700, $abort_code);
      goto Abort;
    }

    // if ($t7) goto L0 else goto L1
    if (b#$Boolean($t7)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t9)
    if (true) { assume $DebugTrackAbort(22, 11663, i#$Integer($t9)); }
    $abort_code := i#$Integer($t9);
    goto Abort;

    // L0:
L0:

    // $t10 := get_global<Roles::RoleId>(addr)
    call $t10 := $GetGlobal($Roles_RoleId_$memory, addr, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 11741, $abort_code);
      goto Abort;
    }

    // $t11 := get_field<Roles::RoleId>.role_id($t10)
    call $t11 := $GetFieldFromValue($t10, $Roles_RoleId_role_id);

    // $t12 := 0
    $t12 := $Integer(0);

    // $t13 := ==($t11, $t12)
    $t13 := $Boolean($IsEqual($t11, $t12));

    // $t14 := 1
    $t14 := $Integer(1);

    // $t15 := Errors::requires_role($t14)
    call $t15 := $Errors_requires_role($t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 11808, $abort_code);
      goto Abort;
    }

    // if ($t13) goto L2 else goto L3
    if (b#$Boolean($t13)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t15)
    if (true) { assume $DebugTrackAbort(22, 11734, i#$Integer($t15)); }
    $abort_code := i#$Integer($t15);
    goto Abort;

    // L2:
L2:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Roles_assert_libra_root_$direct_inter(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(account)), $Roles_RoleId_role_id), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(account)), $Roles_RoleId_role_id), $Integer(0)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(account)), $Roles_RoleId_role_id), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));

procedure {:inline 1} $Roles_assert_libra_root_$direct_intra(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(account)), $Roles_RoleId_role_id), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(account)), $Roles_RoleId_role_id), $Integer(0)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(account)), $Roles_RoleId_role_id), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(0)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(0))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(1)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(1))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(3)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(3))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(4)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(4))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(2)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(2))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(5)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(5))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(6)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(6))))))))))));

procedure {:inline 1} $Roles_assert_libra_root(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(account)), $Roles_RoleId_role_id), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(account)), $Roles_RoleId_role_id), $Integer(0)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(account)), $Roles_RoleId_role_id), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));

procedure {:inline 1} $Roles_assert_treasury_compliance_$def(account: $Value) returns ()
{
    // declare local variables
    var addr: $Value; // $AddressType()
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $Roles_RoleId_type_value()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 12124, 0, account); }

    // bytecode translation starts here
    // $t6 := move(account)
    call $t6 := $CopyOrMoveValue(account);

    // CoreAddresses::assert_treasury_compliance($t6)
    call $CoreAddresses_assert_treasury_compliance($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 12221, $abort_code);
      goto Abort;
    }

    // addr := Signer::address_of($t6)
    call addr := $Signer_address_of($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 12285, $abort_code);
      goto Abort;
    }

    // $t7 := exists<Roles::RoleId>(addr)
    $t7 := $ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr);

    // $t8 := 0
    $t8 := $Integer(0);

    // $t9 := Errors::not_published($t8)
    call $t9 := $Errors_not_published($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 12351, $abort_code);
      goto Abort;
    }

    // if ($t7) goto L0 else goto L1
    if (b#$Boolean($t7)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t9)
    if (true) { assume $DebugTrackAbort(22, 12314, i#$Integer($t9)); }
    $abort_code := i#$Integer($t9);
    goto Abort;

    // L0:
L0:

    // $t10 := get_global<Roles::RoleId>(addr)
    call $t10 := $GetGlobal($Roles_RoleId_$memory, addr, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 12405, $abort_code);
      goto Abort;
    }

    // $t11 := get_field<Roles::RoleId>.role_id($t10)
    call $t11 := $GetFieldFromValue($t10, $Roles_RoleId_role_id);

    // $t12 := 1
    $t12 := $Integer(1);

    // $t13 := ==($t11, $t12)
    $t13 := $Boolean($IsEqual($t11, $t12));

    // $t14 := 2
    $t14 := $Integer(2);

    // $t15 := Errors::requires_role($t14)
    call $t15 := $Errors_requires_role($t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 12493, $abort_code);
      goto Abort;
    }

    // if ($t13) goto L2 else goto L3
    if (b#$Boolean($t13)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t15)
    if (true) { assume $DebugTrackAbort(22, 12385, i#$Integer($t15)); }
    $abort_code := i#$Integer($t15);
    goto Abort;

    // L2:
L2:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Roles_assert_treasury_compliance_$direct_inter(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));

procedure {:inline 1} $Roles_assert_treasury_compliance_$direct_intra(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(0)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(0))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(1)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(1))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(3)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(3))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(4)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(4))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(2)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(2))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(5)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(5))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(6)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(6))))))))))));

procedure {:inline 1} $Roles_assert_treasury_compliance(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));

procedure {:inline 1} $Roles_assert_designated_dealer_$def(account: $Value) returns ()
{
    // declare local variables
    var addr: $Value; // $AddressType()
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $Roles_RoleId_type_value()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 13244, 0, account); }

    // bytecode translation starts here
    // $t6 := move(account)
    call $t6 := $CopyOrMoveValue(account);

    // addr := Signer::address_of($t6)
    call addr := $Signer_address_of($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 13343, $abort_code);
      goto Abort;
    }

    // $t7 := exists<Roles::RoleId>(addr)
    $t7 := $ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr);

    // $t8 := 0
    $t8 := $Integer(0);

    // $t9 := Errors::not_published($t8)
    call $t9 := $Errors_not_published($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 13409, $abort_code);
      goto Abort;
    }

    // if ($t7) goto L0 else goto L1
    if (b#$Boolean($t7)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t9)
    if (true) { assume $DebugTrackAbort(22, 13372, i#$Integer($t9)); }
    $abort_code := i#$Integer($t9);
    goto Abort;

    // L0:
L0:

    // $t10 := get_global<Roles::RoleId>(addr)
    call $t10 := $GetGlobal($Roles_RoleId_$memory, addr, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 13463, $abort_code);
      goto Abort;
    }

    // $t11 := get_field<Roles::RoleId>.role_id($t10)
    call $t11 := $GetFieldFromValue($t10, $Roles_RoleId_role_id);

    // $t12 := 2
    $t12 := $Integer(2);

    // $t13 := ==($t11, $t12)
    $t13 := $Boolean($IsEqual($t11, $t12));

    // $t14 := 6
    $t14 := $Integer(6);

    // $t15 := Errors::requires_role($t14)
    call $t15 := $Errors_requires_role($t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 13549, $abort_code);
      goto Abort;
    }

    // if ($t13) goto L2 else goto L3
    if (b#$Boolean($t13)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t15)
    if (true) { assume $DebugTrackAbort(22, 13443, i#$Integer($t15)); }
    $abort_code := i#$Integer($t15);
    goto Abort;

    // L2:
L2:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Roles_assert_designated_dealer_$direct_inter(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(account)), $Roles_RoleId_role_id), $Integer(2))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(account)), $Roles_RoleId_role_id), $Integer(2))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(account)), $Roles_RoleId_role_id), $Integer(2))))) &&
       $abort_code == i#$Integer($Integer(3))));

procedure {:inline 1} $Roles_assert_designated_dealer_$direct_intra(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(account)), $Roles_RoleId_role_id), $Integer(2))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(account)), $Roles_RoleId_role_id), $Integer(2))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(account)), $Roles_RoleId_role_id), $Integer(2))))) &&
       $abort_code == i#$Integer($Integer(3))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(0)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(0))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(1)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(1))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(3)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(3))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(4)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(4))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(2)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(2))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(5)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(5))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(6)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(6))))))))))));

procedure {:inline 1} $Roles_assert_designated_dealer(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(account)), $Roles_RoleId_role_id), $Integer(2))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(account)), $Roles_RoleId_role_id), $Integer(2))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(account)), $Roles_RoleId_role_id), $Integer(2))))) &&
       $abort_code == i#$Integer($Integer(3))));

procedure {:inline 1} $Roles_assert_parent_vasp_or_child_vasp_$def(account: $Value) returns ()
{
    // declare local variables
    var addr: $Value; // $AddressType()
    var role_id: $Value; // $IntegerType()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var tmp#$5: $Value; // $BooleanType()
    var tmp#$6: $Value; // $IntegerType()
    var tmp#$7: $Value; // $BooleanType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $Roles_RoleId_type_value()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 15714, 0, account); }

    // bytecode translation starts here
    // $t8 := move(account)
    call $t8 := $CopyOrMoveValue(account);

    // addr := Signer::address_of($t8)
    call addr := $Signer_address_of($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 15821, $abort_code);
      goto Abort;
    }

    // $t9 := exists<Roles::RoleId>(addr)
    $t9 := $ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr);

    // $t10 := 0
    $t10 := $Integer(0);

    // $t11 := Errors::not_published($t10)
    call $t11 := $Errors_not_published($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 15887, $abort_code);
      goto Abort;
    }

    // if ($t9) goto L0 else goto L1
    if (b#$Boolean($t9)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t11)
    if (true) { assume $DebugTrackAbort(22, 15850, i#$Integer($t11)); }
    $abort_code := i#$Integer($t11);
    goto Abort;

    // L0:
L0:

    // $t12 := get_global<Roles::RoleId>(addr)
    call $t12 := $GetGlobal($Roles_RoleId_$memory, addr, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 15935, $abort_code);
      goto Abort;
    }

    // $t13 := get_field<Roles::RoleId>.role_id($t12)
    call $t13 := $GetFieldFromValue($t12, $Roles_RoleId_role_id);

    // role_id := $t13
    call role_id := $CopyOrMoveValue($t13);
    if (true) { assume $DebugTrackLocal(22, 15925, 2, role_id); }

    // $t14 := 5
    $t14 := $Integer(5);

    // $t15 := ==(role_id, $t14)
    $t15 := $Boolean($IsEqual(role_id, $t14));

    // if ($t15) goto L2 else goto L3
    if (b#$Boolean($t15)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // goto L4
    goto L4;

    // L2:
L2:

    // $t16 := true
    $t16 := $Boolean(true);

    // tmp#$7 := $t16
    call tmp#$7 := $CopyOrMoveValue($t16);
    if (true) { assume $DebugTrackLocal(22, 16000, 7, tmp#$7); }

    // goto L5
    goto L5;

    // L4:
L4:

    // $t17 := 6
    $t17 := $Integer(6);

    // tmp#$7 := ==(role_id, $t17)
    tmp#$7 := $Boolean($IsEqual(role_id, $t17));
    if (true) { assume $DebugTrackLocal(22, 16042, 7, tmp#$7); }

    // goto L5
    goto L5;

    // L5:
L5:

    // $t18 := 4
    $t18 := $Integer(4);

    // $t19 := Errors::requires_role($t18)
    call $t19 := $Errors_requires_role($t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 16085, $abort_code);
      goto Abort;
    }

    // if (tmp#$7) goto L6 else goto L7
    if (b#$Boolean(tmp#$7)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // abort($t19)
    if (true) { assume $DebugTrackAbort(22, 15980, i#$Integer($t19)); }
    $abort_code := i#$Integer($t19);
    goto Abort;

    // L6:
L6:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Roles_assert_parent_vasp_or_child_vasp_$direct_inter(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$42(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($Roles_role_id$43($Roles_RoleId_$memory, account), $Integer(5)))) && b#$Boolean($Boolean(!$IsEqual($Roles_role_id$43($Roles_RoleId_$memory, account), $Integer(6))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$42(account))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($Roles_role_id$43($Roles_RoleId_$memory, account), $Integer(5)))) && b#$Boolean($Boolean(!$IsEqual($Roles_role_id$43($Roles_RoleId_$memory, account), $Integer(6))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$42(account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($Roles_role_id$43($Roles_RoleId_$memory, account), $Integer(5)))) && b#$Boolean($Boolean(!$IsEqual($Roles_role_id$43($Roles_RoleId_$memory, account), $Integer(6))))))) &&
       $abort_code == i#$Integer($Integer(3))));

procedure {:inline 1} $Roles_assert_parent_vasp_or_child_vasp_$direct_intra(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$42(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($Roles_role_id$43($Roles_RoleId_$memory, account), $Integer(5)))) && b#$Boolean($Boolean(!$IsEqual($Roles_role_id$43($Roles_RoleId_$memory, account), $Integer(6))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$42(account))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($Roles_role_id$43($Roles_RoleId_$memory, account), $Integer(5)))) && b#$Boolean($Boolean(!$IsEqual($Roles_role_id$43($Roles_RoleId_$memory, account), $Integer(6))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$42(account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($Roles_role_id$43($Roles_RoleId_$memory, account), $Integer(5)))) && b#$Boolean($Boolean(!$IsEqual($Roles_role_id$43($Roles_RoleId_$memory, account), $Integer(6))))))) &&
       $abort_code == i#$Integer($Integer(3))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(0)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(0))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(1)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(1))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(3)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(3))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(4)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(4))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(2)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(2))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(5)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(5))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(6)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(6))))))))))));

procedure {:inline 1} $Roles_assert_parent_vasp_or_child_vasp(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$42(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($Roles_role_id$43($Roles_RoleId_$memory, account), $Integer(5)))) && b#$Boolean($Boolean(!$IsEqual($Roles_role_id$43($Roles_RoleId_$memory, account), $Integer(6))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$42(account))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($Roles_role_id$43($Roles_RoleId_$memory, account), $Integer(5)))) && b#$Boolean($Boolean(!$IsEqual($Roles_role_id$43($Roles_RoleId_$memory, account), $Integer(6))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$42(account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($Roles_role_id$43($Roles_RoleId_$memory, account), $Integer(5)))) && b#$Boolean($Boolean(!$IsEqual($Roles_role_id$43($Roles_RoleId_$memory, account), $Integer(6))))))) &&
       $abort_code == i#$Integer($Integer(3))));

procedure {:inline 1} $Roles_assert_parent_vasp_or_designated_dealer_$def(account: $Value) returns ()
{
    // declare local variables
    var addr: $Value; // $AddressType()
    var role_id: $Value; // $IntegerType()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var tmp#$5: $Value; // $BooleanType()
    var tmp#$6: $Value; // $IntegerType()
    var tmp#$7: $Value; // $BooleanType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $Roles_RoleId_type_value()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 15117, 0, account); }

    // bytecode translation starts here
    // $t8 := move(account)
    call $t8 := $CopyOrMoveValue(account);

    // addr := Signer::address_of($t8)
    call addr := $Signer_address_of($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 15231, $abort_code);
      goto Abort;
    }

    // $t9 := exists<Roles::RoleId>(addr)
    $t9 := $ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr);

    // $t10 := 0
    $t10 := $Integer(0);

    // $t11 := Errors::not_published($t10)
    call $t11 := $Errors_not_published($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 15297, $abort_code);
      goto Abort;
    }

    // if ($t9) goto L0 else goto L1
    if (b#$Boolean($t9)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t11)
    if (true) { assume $DebugTrackAbort(22, 15260, i#$Integer($t11)); }
    $abort_code := i#$Integer($t11);
    goto Abort;

    // L0:
L0:

    // $t12 := get_global<Roles::RoleId>(addr)
    call $t12 := $GetGlobal($Roles_RoleId_$memory, addr, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 15345, $abort_code);
      goto Abort;
    }

    // $t13 := get_field<Roles::RoleId>.role_id($t12)
    call $t13 := $GetFieldFromValue($t12, $Roles_RoleId_role_id);

    // role_id := $t13
    call role_id := $CopyOrMoveValue($t13);
    if (true) { assume $DebugTrackLocal(22, 15335, 2, role_id); }

    // $t14 := 5
    $t14 := $Integer(5);

    // $t15 := ==(role_id, $t14)
    $t15 := $Boolean($IsEqual(role_id, $t14));

    // if ($t15) goto L2 else goto L3
    if (b#$Boolean($t15)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // goto L4
    goto L4;

    // L2:
L2:

    // $t16 := true
    $t16 := $Boolean(true);

    // tmp#$7 := $t16
    call tmp#$7 := $CopyOrMoveValue($t16);
    if (true) { assume $DebugTrackLocal(22, 15410, 7, tmp#$7); }

    // goto L5
    goto L5;

    // L4:
L4:

    // $t17 := 2
    $t17 := $Integer(2);

    // tmp#$7 := ==(role_id, $t17)
    tmp#$7 := $Boolean($IsEqual(role_id, $t17));
    if (true) { assume $DebugTrackLocal(22, 15452, 7, tmp#$7); }

    // goto L5
    goto L5;

    // L5:
L5:

    // $t18 := 5
    $t18 := $Integer(5);

    // $t19 := Errors::requires_role($t18)
    call $t19 := $Errors_requires_role($t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 15502, $abort_code);
      goto Abort;
    }

    // if (tmp#$7) goto L6 else goto L7
    if (b#$Boolean(tmp#$7)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // abort($t19)
    if (true) { assume $DebugTrackAbort(22, 15390, i#$Integer($t19)); }
    $abort_code := i#$Integer($t19);
    goto Abort;

    // L6:
L6:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Roles_assert_parent_vasp_or_designated_dealer_$direct_inter(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$40(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($Roles_role_id$41($Roles_RoleId_$memory, account), $Integer(5)))) && b#$Boolean($Boolean(!$IsEqual($Roles_role_id$41($Roles_RoleId_$memory, account), $Integer(2))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$40(account))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($Roles_role_id$41($Roles_RoleId_$memory, account), $Integer(5)))) && b#$Boolean($Boolean(!$IsEqual($Roles_role_id$41($Roles_RoleId_$memory, account), $Integer(2))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$40(account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($Roles_role_id$41($Roles_RoleId_$memory, account), $Integer(5)))) && b#$Boolean($Boolean(!$IsEqual($Roles_role_id$41($Roles_RoleId_$memory, account), $Integer(2))))))) &&
       $abort_code == i#$Integer($Integer(3))));

procedure {:inline 1} $Roles_assert_parent_vasp_or_designated_dealer_$direct_intra(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$40(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($Roles_role_id$41($Roles_RoleId_$memory, account), $Integer(5)))) && b#$Boolean($Boolean(!$IsEqual($Roles_role_id$41($Roles_RoleId_$memory, account), $Integer(2))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$40(account))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($Roles_role_id$41($Roles_RoleId_$memory, account), $Integer(5)))) && b#$Boolean($Boolean(!$IsEqual($Roles_role_id$41($Roles_RoleId_$memory, account), $Integer(2))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$40(account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($Roles_role_id$41($Roles_RoleId_$memory, account), $Integer(5)))) && b#$Boolean($Boolean(!$IsEqual($Roles_role_id$41($Roles_RoleId_$memory, account), $Integer(2))))))) &&
       $abort_code == i#$Integer($Integer(3))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(0)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(0))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(1)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(1))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(3)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(3))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(4)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(4))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(2)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(2))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(5)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(5))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(6)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(6))))))))))));

procedure {:inline 1} $Roles_assert_parent_vasp_or_designated_dealer(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$40(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($Roles_role_id$41($Roles_RoleId_$memory, account), $Integer(5)))) && b#$Boolean($Boolean(!$IsEqual($Roles_role_id$41($Roles_RoleId_$memory, account), $Integer(2))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$40(account))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($Roles_role_id$41($Roles_RoleId_$memory, account), $Integer(5)))) && b#$Boolean($Boolean(!$IsEqual($Roles_role_id$41($Roles_RoleId_$memory, account), $Integer(2))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$40(account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($Roles_role_id$41($Roles_RoleId_$memory, account), $Integer(5)))) && b#$Boolean($Boolean(!$IsEqual($Roles_role_id$41($Roles_RoleId_$memory, account), $Integer(2))))))) &&
       $abort_code == i#$Integer($Integer(3))));

procedure {:inline 1} $Roles_assert_parent_vasp_role_$def(account: $Value) returns ()
{
    // declare local variables
    var addr: $Value; // $AddressType()
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $Roles_RoleId_type_value()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 12726, 0, account); }

    // bytecode translation starts here
    // $t6 := move(account)
    call $t6 := $CopyOrMoveValue(account);

    // addr := Signer::address_of($t6)
    call addr := $Signer_address_of($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 12824, $abort_code);
      goto Abort;
    }

    // $t7 := exists<Roles::RoleId>(addr)
    $t7 := $ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr);

    // $t8 := 0
    $t8 := $Integer(0);

    // $t9 := Errors::not_published($t8)
    call $t9 := $Errors_not_published($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 12890, $abort_code);
      goto Abort;
    }

    // if ($t7) goto L0 else goto L1
    if (b#$Boolean($t7)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t9)
    if (true) { assume $DebugTrackAbort(22, 12853, i#$Integer($t9)); }
    $abort_code := i#$Integer($t9);
    goto Abort;

    // L0:
L0:

    // $t10 := get_global<Roles::RoleId>(addr)
    call $t10 := $GetGlobal($Roles_RoleId_$memory, addr, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 12944, $abort_code);
      goto Abort;
    }

    // $t11 := get_field<Roles::RoleId>.role_id($t10)
    call $t11 := $GetFieldFromValue($t10, $Roles_RoleId_role_id);

    // $t12 := 5
    $t12 := $Integer(5);

    // $t13 := ==($t11, $t12)
    $t13 := $Boolean($IsEqual($t11, $t12));

    // $t14 := 3
    $t14 := $Integer(3);

    // $t15 := Errors::requires_role($t14)
    call $t15 := $Errors_requires_role($t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 13024, $abort_code);
      goto Abort;
    }

    // if ($t13) goto L2 else goto L3
    if (b#$Boolean($t13)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t15)
    if (true) { assume $DebugTrackAbort(22, 12924, i#$Integer($t15)); }
    $abort_code := i#$Integer($t15);
    goto Abort;

    // L2:
L2:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Roles_assert_parent_vasp_role_$direct_inter(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$38(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$38(account)), $Roles_RoleId_role_id), $Integer(5))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$38(account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$38(account)), $Roles_RoleId_role_id), $Integer(5))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$38(account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$38(account)), $Roles_RoleId_role_id), $Integer(5))))) &&
       $abort_code == i#$Integer($Integer(3))));

procedure {:inline 1} $Roles_assert_parent_vasp_role_$direct_intra(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$38(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$38(account)), $Roles_RoleId_role_id), $Integer(5))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$38(account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$38(account)), $Roles_RoleId_role_id), $Integer(5))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$38(account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$38(account)), $Roles_RoleId_role_id), $Integer(5))))) &&
       $abort_code == i#$Integer($Integer(3))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(0)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(0))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(1)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(1))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(3)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(3))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(4)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(4))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(2)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(2))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(5)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(5))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(6)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(6))))))))))));

procedure {:inline 1} $Roles_assert_parent_vasp_role(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$38(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$38(account)), $Roles_RoleId_role_id), $Integer(5))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$38(account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$38(account)), $Roles_RoleId_role_id), $Integer(5))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$38(account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$38(account)), $Roles_RoleId_role_id), $Integer(5))))) &&
       $abort_code == i#$Integer($Integer(3))));

procedure {:inline 1} $Roles_assert_validator_$def(validator_account: $Value) returns ()
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var validator_addr: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $Roles_RoleId_type_value()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 13774, 0, validator_account); }

    // bytecode translation starts here
    // $t6 := move(validator_account)
    call $t6 := $CopyOrMoveValue(validator_account);

    // validator_addr := Signer::address_of($t6)
    call validator_addr := $Signer_address_of($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 13885, $abort_code);
      goto Abort;
    }

    // $t7 := exists<Roles::RoleId>(validator_addr)
    $t7 := $ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, validator_addr);

    // $t8 := 0
    $t8 := $Integer(0);

    // $t9 := Errors::not_published($t8)
    call $t9 := $Errors_not_published($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 13971, $abort_code);
      goto Abort;
    }

    // if ($t7) goto L0 else goto L1
    if (b#$Boolean($t7)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t9)
    if (true) { assume $DebugTrackAbort(22, 13924, i#$Integer($t9)); }
    $abort_code := i#$Integer($t9);
    goto Abort;

    // L0:
L0:

    // $t10 := get_global<Roles::RoleId>(validator_addr)
    call $t10 := $GetGlobal($Roles_RoleId_$memory, validator_addr, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 14025, $abort_code);
      goto Abort;
    }

    // $t11 := get_field<Roles::RoleId>.role_id($t10)
    call $t11 := $GetFieldFromValue($t10, $Roles_RoleId_role_id);

    // $t12 := 3
    $t12 := $Integer(3);

    // $t13 := ==($t11, $t12)
    $t13 := $Boolean($IsEqual($t11, $t12));

    // $t14 := 7
    $t14 := $Integer(7);

    // $t15 := Errors::requires_role($t14)
    call $t15 := $Errors_requires_role($t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 14113, $abort_code);
      goto Abort;
    }

    // if ($t13) goto L2 else goto L3
    if (b#$Boolean($t13)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t15)
    if (true) { assume $DebugTrackAbort(22, 14005, i#$Integer($t15)); }
    $abort_code := i#$Integer($t15);
    goto Abort;

    // L2:
L2:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Roles_assert_validator_$direct_inter(validator_account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(validator_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(validator_account)), $Roles_RoleId_role_id), $Integer(3))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(validator_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(validator_account)), $Roles_RoleId_role_id), $Integer(3))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(validator_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(validator_account)), $Roles_RoleId_role_id), $Integer(3))))) &&
       $abort_code == i#$Integer($Integer(3))));

procedure {:inline 1} $Roles_assert_validator_$direct_intra(validator_account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(validator_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(validator_account)), $Roles_RoleId_role_id), $Integer(3))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(validator_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(validator_account)), $Roles_RoleId_role_id), $Integer(3))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(validator_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(validator_account)), $Roles_RoleId_role_id), $Integer(3))))) &&
       $abort_code == i#$Integer($Integer(3))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(0)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(0))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(1)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(1))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(3)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(3))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(4)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(4))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(2)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(2))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(5)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(5))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(6)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(6))))))))))));

procedure {:inline 1} $Roles_assert_validator(validator_account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(validator_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(validator_account)), $Roles_RoleId_role_id), $Integer(3))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(validator_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(validator_account)), $Roles_RoleId_role_id), $Integer(3))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(validator_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(validator_account)), $Roles_RoleId_role_id), $Integer(3))))) &&
       $abort_code == i#$Integer($Integer(3))));

procedure {:inline 1} $Roles_assert_validator_operator_$def(validator_operator_account: $Value) returns ()
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var validator_operator_addr: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $Roles_RoleId_type_value()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 14379, 0, validator_operator_account); }

    // bytecode translation starts here
    // $t6 := move(validator_operator_account)
    call $t6 := $CopyOrMoveValue(validator_operator_account);

    // validator_operator_addr := Signer::address_of($t6)
    call validator_operator_addr := $Signer_address_of($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 14517, $abort_code);
      goto Abort;
    }

    // $t7 := exists<Roles::RoleId>(validator_operator_addr)
    $t7 := $ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, validator_operator_addr);

    // $t8 := 0
    $t8 := $Integer(0);

    // $t9 := Errors::not_published($t8)
    call $t9 := $Errors_not_published($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 14621, $abort_code);
      goto Abort;
    }

    // if ($t7) goto L0 else goto L1
    if (b#$Boolean($t7)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t9)
    if (true) { assume $DebugTrackAbort(22, 14565, i#$Integer($t9)); }
    $abort_code := i#$Integer($t9);
    goto Abort;

    // L0:
L0:

    // $t10 := get_global<Roles::RoleId>(validator_operator_addr)
    call $t10 := $GetGlobal($Roles_RoleId_$memory, validator_operator_addr, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 14675, $abort_code);
      goto Abort;
    }

    // $t11 := get_field<Roles::RoleId>.role_id($t10)
    call $t11 := $GetFieldFromValue($t10, $Roles_RoleId_role_id);

    // $t12 := 4
    $t12 := $Integer(4);

    // $t13 := ==($t11, $t12)
    $t13 := $Boolean($IsEqual($t11, $t12));

    // $t14 := 8
    $t14 := $Integer(8);

    // $t15 := Errors::requires_role($t14)
    call $t15 := $Errors_requires_role($t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 14781, $abort_code);
      goto Abort;
    }

    // if ($t13) goto L2 else goto L3
    if (b#$Boolean($t13)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t15)
    if (true) { assume $DebugTrackAbort(22, 14655, i#$Integer($t15)); }
    $abort_code := i#$Integer($t15);
    goto Abort;

    // L2:
L2:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Roles_assert_validator_operator_$direct_inter(validator_operator_account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(validator_operator_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(validator_operator_account)), $Roles_RoleId_role_id), $Integer(4))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(validator_operator_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(validator_operator_account)), $Roles_RoleId_role_id), $Integer(4))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(validator_operator_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(validator_operator_account)), $Roles_RoleId_role_id), $Integer(4))))) &&
       $abort_code == i#$Integer($Integer(3))));

procedure {:inline 1} $Roles_assert_validator_operator_$direct_intra(validator_operator_account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(validator_operator_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(validator_operator_account)), $Roles_RoleId_role_id), $Integer(4))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(validator_operator_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(validator_operator_account)), $Roles_RoleId_role_id), $Integer(4))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(validator_operator_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(validator_operator_account)), $Roles_RoleId_role_id), $Integer(4))))) &&
       $abort_code == i#$Integer($Integer(3))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(0)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(0))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(1)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(1))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(3)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(3))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(4)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(4))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(2)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(2))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(5)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(5))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id), $Integer(6)))))) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, addr), $Roles_RoleId_role_id)), $Integer(6))))))))))));

procedure {:inline 1} $Roles_assert_validator_operator(validator_operator_account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(validator_operator_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(validator_operator_account)), $Roles_RoleId_role_id), $Integer(4))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(validator_operator_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(validator_operator_account)), $Roles_RoleId_role_id), $Integer(4))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(validator_operator_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(validator_operator_account)), $Roles_RoleId_role_id), $Integer(4))))) &&
       $abort_code == i#$Integer($Integer(3))));

procedure {:inline 1} $Roles_can_hold_balance_$def(account: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $BooleanType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 10587, 0, account); }

    // bytecode translation starts here
    // $t3 := move(account)
    call $t3 := $CopyOrMoveValue(account);

    // $t4 := Roles::has_parent_VASP_role($t3)
    call $t4 := $Roles_has_parent_VASP_role($t3);
    if ($abort_flag) {
      goto Abort;
    }

    // if ($t4) goto L0 else goto L1
    if (b#$Boolean($t4)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t5 := true
    $t5 := $Boolean(true);

    // tmp#$1 := $t5
    call tmp#$1 := $CopyOrMoveValue($t5);
    if (true) { assume $DebugTrackLocal(22, 10860, 1, tmp#$1); }

    // goto L3
    goto L3;

    // L2:
L2:

    // tmp#$1 := Roles::has_child_VASP_role($t3)
    call tmp#$1 := $Roles_has_child_VASP_role($t3);
    if ($abort_flag) {
      goto Abort;
    }

    // goto L3
    goto L3;

    // L3:
L3:

    // if (tmp#$1) goto L4 else goto L5
    if (b#$Boolean(tmp#$1)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // goto L6
    goto L6;

    // L4:
L4:

    // destroy($t3)

    // $t6 := true
    $t6 := $Boolean(true);

    // tmp#$2 := $t6
    call tmp#$2 := $CopyOrMoveValue($t6);
    if (true) { assume $DebugTrackLocal(22, 10860, 2, tmp#$2); }

    // goto L7
    goto L7;

    // L6:
L6:

    // tmp#$2 := Roles::has_designated_dealer_role($t3)
    call tmp#$2 := $Roles_has_designated_dealer_role($t3);
    if ($abort_flag) {
      goto Abort;
    }

    // goto L7
    goto L7;

    // L7:
L7:

    // return tmp#$2
    $ret0 := tmp#$2;
    if (true) { assume $DebugTrackLocal(22, 10860, 7, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Roles_can_hold_balance_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_can_hold_balance_$def(account);
}


procedure {:inline 1} $Roles_can_hold_balance_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_can_hold_balance_$def(account);
}


procedure {:inline 1} $Roles_can_hold_balance(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_can_hold_balance_$def(account);
}


procedure {:inline 1} $Roles_get_role_id_$def(a: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $Roles_RoleId_type_value()
    var $t8: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 10327, 0, a); }

    // bytecode translation starts here
    // $t3 := move(a)
    call $t3 := $CopyOrMoveValue(a);

    // $t4 := exists<Roles::RoleId>($t3)
    $t4 := $ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $t3);

    // $t5 := 0
    $t5 := $Integer(0);

    // $t6 := Errors::not_published($t5)
    call $t6 := $Errors_not_published($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 10427, $abort_code);
      goto Abort;
    }

    // if ($t4) goto L0 else goto L1
    if (b#$Boolean($t4)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t6)
    if (true) { assume $DebugTrackAbort(22, 10393, i#$Integer($t6)); }
    $abort_code := i#$Integer($t6);
    goto Abort;

    // L0:
L0:

    // $t7 := get_global<Roles::RoleId>($t3)
    call $t7 := $GetGlobal($Roles_RoleId_$memory, $t3, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 10461, $abort_code);
      goto Abort;
    }

    // $t8 := get_field<Roles::RoleId>.role_id($t7)
    call $t8 := $GetFieldFromValue($t7, $Roles_RoleId_role_id);

    // return $t8
    $ret0 := $t8;
    if (true) { assume $DebugTrackLocal(22, 10461, 9, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Roles_get_role_id_$direct_inter(a: $Value) returns ($ret0: $Value)
{
    assume is#$Address(a);

    call $ret0 := $Roles_get_role_id_$def(a);
}


procedure {:inline 1} $Roles_get_role_id_$direct_intra(a: $Value) returns ($ret0: $Value)
{
    assume is#$Address(a);

    call $ret0 := $Roles_get_role_id_$def(a);
}


procedure {:inline 1} $Roles_get_role_id(a: $Value) returns ($ret0: $Value)
{
    assume is#$Address(a);

    call $ret0 := $Roles_get_role_id_$def(a);
}


procedure {:inline 1} $Roles_grant_libra_root_role_$def(lr_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $IntegerType()
    var $Roles_RoleId_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 2743, 0, lr_account); }
    $Roles_RoleId_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address($Signer_$address_of(lr_account)) := true];

    // bytecode translation starts here
    // $t1 := move(lr_account)
    call $t1 := $CopyOrMoveValue(lr_account);

    // LibraTimestamp::assert_genesis()
    call $LibraTimestamp_assert_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 2838, $abort_code);
      goto Abort;
    }

    // CoreAddresses::assert_libra_root($t1)
    call $CoreAddresses_assert_libra_root($t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 2986, $abort_code);
      goto Abort;
    }

    // $t2 := 0
    $t2 := $Integer(0);

    // Roles::grant_role($t1, $t2)
    call $Roles_grant_role($t1, $t2, $Roles_RoleId_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 7476, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Roles_grant_libra_root_role_$direct_inter(lr_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(lr_account))];
{
    assume is#$Address(lr_account);

    call $Roles_grant_libra_root_role_$def(lr_account, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $Roles_grant_libra_root_role_$direct_intra(lr_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(lr_account))];
{
    assume is#$Address(lr_account);

    call $Roles_grant_libra_root_role_$def(lr_account, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $Roles_grant_libra_root_role(lr_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(lr_account))];
{
    assume is#$Address(lr_account);

    call $Roles_grant_libra_root_role_$def(lr_account, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $Roles_grant_role_$def(account: $Value, role_id: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $Roles_RoleId_type_value()
    var $Roles_RoleId_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 7472, 0, account); }
    if (true) { assume $DebugTrackLocal(22, 7472, 1, role_id); }
    $Roles_RoleId_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address($Signer_$address_of(account)) := true];

    // bytecode translation starts here
    // $t4 := move(account)
    call $t4 := $CopyOrMoveValue(account);

    // $t5 := move(role_id)
    call $t5 := $CopyOrMoveValue(role_id);

    // $t6 := Signer::address_of($t4)
    call $t6 := $Signer_address_of($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 7560, $abort_code);
      goto Abort;
    }

    // $t7 := exists<Roles::RoleId>($t6)
    $t7 := $ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $t6);

    // $t8 := !($t7)
    call $t8 := $Not($t7);

    // $t9 := 0
    $t9 := $Integer(0);

    // $t10 := Errors::already_published($t9)
    call $t10 := $Errors_already_published($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 7590, $abort_code);
      goto Abort;
    }

    // if ($t8) goto L0 else goto L1
    if (b#$Boolean($t8)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t4)

    // abort($t10)
    if (true) { assume $DebugTrackAbort(22, 7529, i#$Integer($t10)); }
    $abort_code := i#$Integer($t10);
    goto Abort;

    // L0:
L0:

    // $t11 := pack Roles::RoleId($t5)
    call $t11 := $Roles_RoleId_pack(0, 0, 0, $t5);

    // move_to<Roles::RoleId>($t11, $t4)
    assert $Roles_RoleId_$SelfDomain[$EmptyTypeValueArray, a#$Address($Signer_spec_address_of($t4))];
    call $Roles_RoleId_$memory := $MoveTo($Roles_RoleId_$memory, $EmptyTypeValueArray, $t11, $t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 7628, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Roles_grant_role_$direct_intra(account: $Value, role_id: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(account))];
requires b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual(role_id, $Integer(0)))) ==> b#$Boolean($Boolean($IsEqual($Roles_addr$44(account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))));
requires b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual(role_id, $Integer(1)))) ==> b#$Boolean($Boolean($IsEqual($Roles_addr$44(account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))));
ensures b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(account)))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(account)))));
ensures $abort_flag ==> ((b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(account)))) &&
       $abort_code == i#$Integer($Integer(6))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(account))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(account)), $Roles_RoleId_role_id), role_id))));
modifies $Roles_RoleId_$memory;
ensures contents#$Memory($Roles_RoleId_$memory) == old(contents#$Memory($Roles_RoleId_$memory))[$EmptyTypeValueArray, a#$Address($Signer_$address_of(account)) := contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, a#$Address($Signer_$address_of(account))]];
ensures domain#$Memory($Roles_RoleId_$memory) == old(domain#$Memory($Roles_RoleId_$memory))[$EmptyTypeValueArray, a#$Address($Signer_$address_of(account)) := domain#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, a#$Address($Signer_$address_of(account))]];

procedure {:inline 1} $Roles_grant_role(account: $Value, role_id: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(account))];
ensures b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(account)))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(account)))));
ensures $abort_flag ==> ((b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(account)))) &&
       $abort_code == i#$Integer($Integer(6))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(account))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Signer_$address_of(account)), $Roles_RoleId_role_id), role_id))));
modifies $Roles_RoleId_$memory;
ensures contents#$Memory($Roles_RoleId_$memory) == old(contents#$Memory($Roles_RoleId_$memory))[$EmptyTypeValueArray, a#$Address($Signer_$address_of(account)) := contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, a#$Address($Signer_$address_of(account))]];
ensures domain#$Memory($Roles_RoleId_$memory) == old(domain#$Memory($Roles_RoleId_$memory))[$EmptyTypeValueArray, a#$Address($Signer_$address_of(account)) := domain#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, a#$Address($Signer_$address_of(account))]];

procedure {:inline 1} $Roles_grant_treasury_compliance_role_$def(treasury_compliance_account: $Value, lr_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $IntegerType()
    var $Roles_RoleId_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 3564, 0, treasury_compliance_account); }
    if (true) { assume $DebugTrackLocal(22, 3564, 1, lr_account); }
    $Roles_RoleId_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address($Signer_$address_of(treasury_compliance_account)) := true];

    // bytecode translation starts here
    // $t2 := move(treasury_compliance_account)
    call $t2 := $CopyOrMoveValue(treasury_compliance_account);

    // $t3 := move(lr_account)
    call $t3 := $CopyOrMoveValue(lr_account);

    // LibraTimestamp::assert_genesis()
    call $LibraTimestamp_assert_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 3730, $abort_code);
      goto Abort;
    }

    // CoreAddresses::assert_treasury_compliance($t2)
    call $CoreAddresses_assert_treasury_compliance($t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 3771, $abort_code);
      goto Abort;
    }

    // Roles::assert_libra_root($t3)
    call $Roles_assert_libra_root($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 11502, $abort_code);
      goto Abort;
    }

    // $t4 := 1
    $t4 := $Integer(1);

    // Roles::grant_role($t2, $t4)
    call $Roles_grant_role($t2, $t4, $Roles_RoleId_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 7476, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Roles_grant_treasury_compliance_role_$direct_inter(treasury_compliance_account: $Value, lr_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(treasury_compliance_account))];
{
    assume is#$Address(treasury_compliance_account);

    assume is#$Address(lr_account);

    call $Roles_grant_treasury_compliance_role_$def(treasury_compliance_account, lr_account, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $Roles_grant_treasury_compliance_role_$direct_intra(treasury_compliance_account: $Value, lr_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(treasury_compliance_account))];
{
    assume is#$Address(treasury_compliance_account);

    assume is#$Address(lr_account);

    call $Roles_grant_treasury_compliance_role_$def(treasury_compliance_account, lr_account, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $Roles_grant_treasury_compliance_role(treasury_compliance_account: $Value, lr_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(treasury_compliance_account))];
{
    assume is#$Address(treasury_compliance_account);

    assume is#$Address(lr_account);

    call $Roles_grant_treasury_compliance_role_$def(treasury_compliance_account, lr_account, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $Roles_has_child_VASP_role_$def(account: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 10197, 0, account); }

    // bytecode translation starts here
    // $t1 := move(account)
    call $t1 := $CopyOrMoveValue(account);

    // $t2 := 6
    $t2 := $Integer(6);

    // $t3 := Roles::has_role($t1, $t2)
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag) {
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(22, 10278, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Roles_has_child_VASP_role_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_child_VASP_role_$def(account);
}


procedure {:inline 1} $Roles_has_child_VASP_role_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_child_VASP_role_$def(account);
}


procedure {:inline 1} $Roles_has_child_VASP_role(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_child_VASP_role_$def(account);
}


procedure {:inline 1} $Roles_has_designated_dealer_role_$def(account: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 9647, 0, account); }

    // bytecode translation starts here
    // $t1 := move(account)
    call $t1 := $CopyOrMoveValue(account);

    // $t2 := 2
    $t2 := $Integer(2);

    // $t3 := Roles::has_role($t1, $t2)
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag) {
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(22, 9735, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Roles_has_designated_dealer_role_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_designated_dealer_role_$def(account);
}


procedure {:inline 1} $Roles_has_designated_dealer_role_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_designated_dealer_role_$def(account);
}


procedure {:inline 1} $Roles_has_designated_dealer_role(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_designated_dealer_role_$def(account);
}


procedure {:inline 1} $Roles_has_libra_root_role_$def(account: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 9369, 0, account); }

    // bytecode translation starts here
    // $t1 := move(account)
    call $t1 := $CopyOrMoveValue(account);

    // $t2 := 0
    $t2 := $Integer(0);

    // $t3 := Roles::has_role($t1, $t2)
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag) {
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(22, 9450, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Roles_has_libra_root_role_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_libra_root_role_$def(account);
}


procedure {:inline 1} $Roles_has_libra_root_role_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_libra_root_role_$def(account);
}


procedure {:inline 1} $Roles_has_libra_root_role(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_libra_root_role_$def(account);
}


procedure {:inline 1} $Roles_has_parent_VASP_role_$def(account: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 10065, 0, account); }

    // bytecode translation starts here
    // $t1 := move(account)
    call $t1 := $CopyOrMoveValue(account);

    // $t2 := 5
    $t2 := $Integer(5);

    // $t3 := Roles::has_role($t1, $t2)
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag) {
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(22, 10147, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Roles_has_parent_VASP_role_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_parent_VASP_role_$def(account);
}


procedure {:inline 1} $Roles_has_parent_VASP_role_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_parent_VASP_role_$def(account);
}


procedure {:inline 1} $Roles_has_parent_VASP_role(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_parent_VASP_role_$def(account);
}


procedure {:inline 1} $Roles_has_role_$def(account: $Value, role_id: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var addr: $Value; // $AddressType()
    var tmp#$3: $Value; // $BooleanType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $Roles_RoleId_type_value()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 9153, 0, account); }
    if (true) { assume $DebugTrackLocal(22, 9153, 1, role_id); }

    // bytecode translation starts here
    // $t4 := move(account)
    call $t4 := $CopyOrMoveValue(account);

    // $t5 := move(role_id)
    call $t5 := $CopyOrMoveValue(role_id);

    // addr := Signer::address_of($t4)
    call addr := $Signer_address_of($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 9248, $abort_code);
      goto Abort;
    }

    // $t6 := exists<Roles::RoleId>(addr)
    $t6 := $ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr);

    // if ($t6) goto L0 else goto L1
    if (b#$Boolean($t6)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t7 := get_global<Roles::RoleId>(addr)
    call $t7 := $GetGlobal($Roles_RoleId_$memory, addr, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 9311, $abort_code);
      goto Abort;
    }

    // $t8 := get_field<Roles::RoleId>.role_id($t7)
    call $t8 := $GetFieldFromValue($t7, $Roles_RoleId_role_id);

    // tmp#$3 := ==($t8, $t5)
    tmp#$3 := $Boolean($IsEqual($t8, $t5));
    if (true) { assume $DebugTrackLocal(22, 9347, 3, tmp#$3); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t9 := false
    $t9 := $Boolean(false);

    // tmp#$3 := $t9
    call tmp#$3 := $CopyOrMoveValue($t9);
    if (true) { assume $DebugTrackLocal(22, 9276, 3, tmp#$3); }

    // goto L3
    goto L3;

    // L3:
L3:

    // return tmp#$3
    $ret0 := tmp#$3;
    if (true) { assume $DebugTrackLocal(22, 9276, 10, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Roles_has_role_$direct_intra(account: $Value, role_id: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    assume $IsValidU64(role_id);

    call $ret0 := $Roles_has_role_$def(account, role_id);
}


procedure {:inline 1} $Roles_has_role(account: $Value, role_id: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    assume $IsValidU64(role_id);

    call $ret0 := $Roles_has_role_$def(account, role_id);
}


procedure {:inline 1} $Roles_has_treasury_compliance_role_$def(account: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 9499, 0, account); }

    // bytecode translation starts here
    // $t1 := move(account)
    call $t1 := $CopyOrMoveValue(account);

    // $t2 := 1
    $t2 := $Integer(1);

    // $t3 := Roles::has_role($t1, $t2)
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag) {
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(22, 9589, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Roles_has_treasury_compliance_role_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_treasury_compliance_role_$def(account);
}


procedure {:inline 1} $Roles_has_treasury_compliance_role_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_treasury_compliance_role_$def(account);
}


procedure {:inline 1} $Roles_has_treasury_compliance_role(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_treasury_compliance_role_$def(account);
}


procedure {:inline 1} $Roles_has_validator_operator_role_$def(account: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 9919, 0, account); }

    // bytecode translation starts here
    // $t1 := move(account)
    call $t1 := $CopyOrMoveValue(account);

    // $t2 := 4
    $t2 := $Integer(4);

    // $t3 := Roles::has_role($t1, $t2)
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag) {
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(22, 10008, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Roles_has_validator_operator_role_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_validator_operator_role_$def(account);
}


procedure {:inline 1} $Roles_has_validator_operator_role_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_validator_operator_role_$def(account);
}


procedure {:inline 1} $Roles_has_validator_operator_role(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_validator_operator_role_$def(account);
}


procedure {:inline 1} $Roles_has_validator_role_$def(account: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 9791, 0, account); }

    // bytecode translation starts here
    // $t1 := move(account)
    call $t1 := $CopyOrMoveValue(account);

    // $t2 := 3
    $t2 := $Integer(3);

    // $t3 := Roles::has_role($t1, $t2)
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag) {
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(22, 9871, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Roles_has_validator_role_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_validator_role_$def(account);
}


procedure {:inline 1} $Roles_has_validator_role_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_validator_role_$def(account);
}


procedure {:inline 1} $Roles_has_validator_role(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Roles_has_validator_role_$def(account);
}


procedure {:inline 1} $Roles_new_child_vasp_role_$def(creating_account: $Value, new_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $IntegerType()
    var $Roles_RoleId_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 6993, 0, creating_account); }
    if (true) { assume $DebugTrackLocal(22, 6993, 1, new_account); }
    $Roles_RoleId_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address($Signer_$address_of(new_account)) := true];

    // bytecode translation starts here
    // $t2 := move(creating_account)
    call $t2 := $CopyOrMoveValue(creating_account);

    // $t3 := move(new_account)
    call $t3 := $CopyOrMoveValue(new_account);

    // Roles::assert_parent_vasp_role($t2)
    call $Roles_assert_parent_vasp_role($t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 12737, $abort_code);
      goto Abort;
    }

    // $t4 := 6
    $t4 := $Integer(6);

    // Roles::grant_role($t3, $t4)
    call $Roles_grant_role($t3, $t4, $Roles_RoleId_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 7476, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Roles_new_child_vasp_role_$direct_inter(creating_account: $Value, new_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(new_account))];
{
    assume is#$Address(creating_account);

    assume is#$Address(new_account);

    call $Roles_new_child_vasp_role_$def(creating_account, new_account, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $Roles_new_child_vasp_role_$direct_intra(creating_account: $Value, new_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(new_account))];
{
    assume is#$Address(creating_account);

    assume is#$Address(new_account);

    call $Roles_new_child_vasp_role_$def(creating_account, new_account, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $Roles_new_child_vasp_role(creating_account: $Value, new_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(new_account))];
{
    assume is#$Address(creating_account);

    assume is#$Address(new_account);

    call $Roles_new_child_vasp_role_$def(creating_account, new_account, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $Roles_new_designated_dealer_role_$def(creating_account: $Value, new_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $IntegerType()
    var $Roles_RoleId_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 4725, 0, creating_account); }
    if (true) { assume $DebugTrackLocal(22, 4725, 1, new_account); }
    $Roles_RoleId_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address($Signer_$address_of(new_account)) := true];

    // bytecode translation starts here
    // $t2 := move(creating_account)
    call $t2 := $CopyOrMoveValue(creating_account);

    // $t3 := move(new_account)
    call $t3 := $CopyOrMoveValue(new_account);

    // Roles::assert_treasury_compliance($t2)
    call $Roles_assert_treasury_compliance($t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 12135, $abort_code);
      goto Abort;
    }

    // $t4 := 2
    $t4 := $Integer(2);

    // Roles::grant_role($t3, $t4)
    call $Roles_grant_role($t3, $t4, $Roles_RoleId_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 7476, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Roles_new_designated_dealer_role_$direct_inter(creating_account: $Value, new_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(new_account))];
{
    assume is#$Address(creating_account);

    assume is#$Address(new_account);

    call $Roles_new_designated_dealer_role_$def(creating_account, new_account, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $Roles_new_designated_dealer_role_$direct_intra(creating_account: $Value, new_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(new_account))];
{
    assume is#$Address(creating_account);

    assume is#$Address(new_account);

    call $Roles_new_designated_dealer_role_$def(creating_account, new_account, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $Roles_new_designated_dealer_role(creating_account: $Value, new_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(new_account))];
{
    assume is#$Address(creating_account);

    assume is#$Address(new_account);

    call $Roles_new_designated_dealer_role_$def(creating_account, new_account, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $Roles_new_parent_vasp_role_$def(creating_account: $Value, new_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $IntegerType()
    var $Roles_RoleId_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 6430, 0, creating_account); }
    if (true) { assume $DebugTrackLocal(22, 6430, 1, new_account); }
    $Roles_RoleId_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address($Signer_$address_of(new_account)) := true];

    // bytecode translation starts here
    // $t2 := move(creating_account)
    call $t2 := $CopyOrMoveValue(creating_account);

    // $t3 := move(new_account)
    call $t3 := $CopyOrMoveValue(new_account);

    // Roles::assert_treasury_compliance($t2)
    call $Roles_assert_treasury_compliance($t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 12135, $abort_code);
      goto Abort;
    }

    // $t4 := 5
    $t4 := $Integer(5);

    // Roles::grant_role($t3, $t4)
    call $Roles_grant_role($t3, $t4, $Roles_RoleId_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 7476, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Roles_new_parent_vasp_role_$direct_inter(creating_account: $Value, new_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(new_account))];
{
    assume is#$Address(creating_account);

    assume is#$Address(new_account);

    call $Roles_new_parent_vasp_role_$def(creating_account, new_account, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $Roles_new_parent_vasp_role_$direct_intra(creating_account: $Value, new_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(new_account))];
{
    assume is#$Address(creating_account);

    assume is#$Address(new_account);

    call $Roles_new_parent_vasp_role_$def(creating_account, new_account, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $Roles_new_parent_vasp_role(creating_account: $Value, new_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(new_account))];
{
    assume is#$Address(creating_account);

    assume is#$Address(new_account);

    call $Roles_new_parent_vasp_role_$def(creating_account, new_account, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $Roles_new_validator_operator_role_$def(creating_account: $Value, new_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $IntegerType()
    var $Roles_RoleId_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 5850, 0, creating_account); }
    if (true) { assume $DebugTrackLocal(22, 5850, 1, new_account); }
    $Roles_RoleId_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address($Signer_$address_of(new_account)) := true];

    // bytecode translation starts here
    // $t2 := move(creating_account)
    call $t2 := $CopyOrMoveValue(creating_account);

    // $t3 := move(new_account)
    call $t3 := $CopyOrMoveValue(new_account);

    // Roles::assert_libra_root($t2)
    call $Roles_assert_libra_root($t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 11502, $abort_code);
      goto Abort;
    }

    // $t4 := 4
    $t4 := $Integer(4);

    // Roles::grant_role($t3, $t4)
    call $Roles_grant_role($t3, $t4, $Roles_RoleId_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 7476, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Roles_new_validator_operator_role_$direct_inter(creating_account: $Value, new_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(new_account))];
{
    assume is#$Address(creating_account);

    assume is#$Address(new_account);

    call $Roles_new_validator_operator_role_$def(creating_account, new_account, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $Roles_new_validator_operator_role_$direct_intra(creating_account: $Value, new_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(new_account))];
{
    assume is#$Address(creating_account);

    assume is#$Address(new_account);

    call $Roles_new_validator_operator_role_$def(creating_account, new_account, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $Roles_new_validator_operator_role(creating_account: $Value, new_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(new_account))];
{
    assume is#$Address(creating_account);

    assume is#$Address(new_account);

    call $Roles_new_validator_operator_role_$def(creating_account, new_account, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $Roles_new_validator_role_$def(creating_account: $Value, new_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $IntegerType()
    var $Roles_RoleId_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(22, 5309, 0, creating_account); }
    if (true) { assume $DebugTrackLocal(22, 5309, 1, new_account); }
    $Roles_RoleId_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address($Signer_$address_of(new_account)) := true];

    // bytecode translation starts here
    // $t2 := move(creating_account)
    call $t2 := $CopyOrMoveValue(creating_account);

    // $t3 := move(new_account)
    call $t3 := $CopyOrMoveValue(new_account);

    // Roles::assert_libra_root($t2)
    call $Roles_assert_libra_root($t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 11502, $abort_code);
      goto Abort;
    }

    // $t4 := 3
    $t4 := $Integer(3);

    // Roles::grant_role($t3, $t4)
    call $Roles_grant_role($t3, $t4, $Roles_RoleId_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(22, 7476, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Roles_new_validator_role_$direct_inter(creating_account: $Value, new_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(new_account))];
{
    assume is#$Address(creating_account);

    assume is#$Address(new_account);

    call $Roles_new_validator_role_$def(creating_account, new_account, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $Roles_new_validator_role_$direct_intra(creating_account: $Value, new_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(new_account))];
{
    assume is#$Address(creating_account);

    assume is#$Address(new_account);

    call $Roles_new_validator_role_$def(creating_account, new_account, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $Roles_new_validator_role(creating_account: $Value, new_account: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address($Signer_$address_of(new_account))];
{
    assume is#$Address(creating_account);

    assume is#$Address(new_account);

    call $Roles_new_validator_role_$def(creating_account, new_account, $Roles_RoleId_$CallerDomain);
}




// ** spec vars of module Vector



// ** spec funs of module Vector

function {:inline} $Vector_$is_empty($tv0: $TypeValue, v: $Value): $Value {
    $Boolean($IsEqual($Vector_$length($tv0, v), $Integer(0)))
}

function {:inline} $Vector_spec_singleton($tv0: $TypeValue, e: $Value): $Value {
    $single_vector(e)
}

function {:inline} $Vector_spec_contains($tv0: $TypeValue, v: $Value, e: $Value): $Value {
    $Boolean((var $range_1 := v; (exists $i_0: int :: $InVectorRange($range_1, $i_0) && (var x := $select_vector($range_1, $i_0); b#$Boolean($Boolean($IsEqual(x, e)))))))
}

function {:inline} $Vector_eq_push_back($tv0: $TypeValue, v1: $Value, v2: $Value, e: $Value): $Value {
    $Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(v1), $Integer(i#$Integer($vlen_value(v2)) + i#$Integer($Integer(1)))))) && b#$Boolean($Boolean($IsEqual($select_vector_by_value(v1, $Integer(i#$Integer($vlen_value(v1)) - i#$Integer($Integer(1)))), e))))) && b#$Boolean($Boolean($IsEqual($slice_vector(v1, $Range($Integer(0), $Integer(i#$Integer($vlen_value(v1)) - i#$Integer($Integer(1))))), $slice_vector(v2, $Range($Integer(0), $vlen_value(v2)))))))
}

function {:inline} $Vector_eq_append($tv0: $TypeValue, v: $Value, v1: $Value, v2: $Value): $Value {
    $Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(v), $Integer(i#$Integer($vlen_value(v1)) + i#$Integer($vlen_value(v2)))))) && b#$Boolean($Boolean($IsEqual($slice_vector(v, $Range($Integer(0), $vlen_value(v1))), v1))))) && b#$Boolean($Boolean($IsEqual($slice_vector(v, $Range($vlen_value(v1), $vlen_value(v))), v2))))
}

function {:inline} $Vector_eq_pop_front($tv0: $TypeValue, v1: $Value, v2: $Value): $Value {
    $Boolean(b#$Boolean($Boolean($IsEqual($Integer(i#$Integer($vlen_value(v1)) + i#$Integer($Integer(1))), $vlen_value(v2)))) && b#$Boolean($Boolean($IsEqual(v1, $slice_vector(v2, $Range($Integer(1), $vlen_value(v2)))))))
}



// ** structs of module Vector



// ** functions of module Vector

procedure {:inline 1} $Vector_singleton_$def($tv0: $TypeValue, e: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var v: $Value; // $Vector_type_value($tv0)
    var $t2: $Value; // $tv0
    var $t3: $Mutation; // ReferenceType($Vector_type_value($tv0))
    var $t4: $Value; // $Vector_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(30, 1505, 0, e); }

    // bytecode translation starts here
    // $t2 := move(e)
    call $t2 := $CopyOrMoveValue(e);

    // v := Vector::empty<#0>()
    call v := $Vector_empty($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(30, 263, $abort_code);
      goto Abort;
    }

    // $t3 := borrow_local(v)
    call $t3 := $BorrowLoc(1, v);

    // unpack_ref($t3)

    // $t4 := read_ref($t3)
    call $t4 := $ReadRef($t3);

    // $t4 := Vector::push_back<#0>($t4, $t2)
    call $t4 := $Vector_push_back($tv0, $t4, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(30, 680, $abort_code);
      goto Abort;
    }

    // write_ref($t3, $t4)
    call $t3 := $WriteRef($t3, $t4);

    // pack_ref($t3)

    // write_back[LocalRoot(v)]($t3)
    call v := $WritebackToValue($t3, 1, v);

    // return v
    $ret0 := v;
    if (true) { assume $DebugTrackLocal(30, 1629, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Vector_singleton_$direct_inter($tv0: $TypeValue, e: $Value) returns ($ret0: $Value)
{
    call $ret0 := $Vector_singleton_$def($tv0, e);
}


procedure {:inline 1} $Vector_singleton_$direct_intra($tv0: $TypeValue, e: $Value) returns ($ret0: $Value)
{
    call $ret0 := $Vector_singleton_$def($tv0, e);
}


procedure {:inline 1} $Vector_singleton($tv0: $TypeValue, e: $Value) returns ($ret0: $Value)
{
    call $ret0 := $Vector_singleton_$def($tv0, e);
}




// ** spec vars of module LCS



// ** spec funs of module LCS



// ** structs of module LCS



// ** functions of module LCS



// ** spec vars of module Event



// ** spec funs of module Event



// ** structs of module Event

const unique $Event_EventHandle: $TypeName;
const $Event_EventHandle_counter: $FieldName;
axiom $Event_EventHandle_counter == 0;
const $Event_EventHandle_guid: $FieldName;
axiom $Event_EventHandle_guid == 1;
function $Event_EventHandle_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($Event_EventHandle, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1))
}
var $Event_EventHandle_$memory: $Memory;
var $Event_EventHandle_$memory_$old: $Memory;
function {:inline} $Event_EventHandle_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 2
      && $IsValidU64($SelectField($this, $Event_EventHandle_counter))
      && $Vector_$is_well_formed($SelectField($this, $Event_EventHandle_guid)) && (forall $$0: int :: {$select_vector($SelectField($this, $Event_EventHandle_guid),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Event_EventHandle_guid)) ==> $IsValidU8($select_vector($SelectField($this, $Event_EventHandle_guid),$$0)))
}
function {:inline} $Event_EventHandle_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $Event_EventHandle_$is_well_formed($this: $Value): bool {
    $Event_EventHandle_$is_well_typed($this) && $Event_EventHandle_$invariant_holds($this)}

procedure {:inline 1} $Event_EventHandle_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, counter: $Value, guid: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(counter);
    assume $Vector_$is_well_formed(guid) && (forall $$0: int :: {$select_vector(guid,$$0)} $$0 >= 0 && $$0 < $vlen(guid) ==> $IsValidU8($select_vector(guid,$$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := counter][1 := guid], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Event_EventHandle_unpack($tv0: $TypeValue, $struct: $Value) returns (counter: $Value, guid: $Value)
{
    assume is#$Vector($struct);
    counter := $SelectField($struct, $Event_EventHandle_counter);
    assume $IsValidU64(counter);
    guid := $SelectField($struct, $Event_EventHandle_guid);
    assume $Vector_$is_well_formed(guid) && (forall $$0: int :: {$select_vector(guid,$$0)} $$0 >= 0 && $$0 < $vlen(guid) ==> $IsValidU8($select_vector(guid,$$0)));
}

const unique $Event_EventHandleGenerator: $TypeName;
const $Event_EventHandleGenerator_counter: $FieldName;
axiom $Event_EventHandleGenerator_counter == 0;
const $Event_EventHandleGenerator_addr: $FieldName;
axiom $Event_EventHandleGenerator_addr == 1;
function $Event_EventHandleGenerator_type_value(): $TypeValue {
    $StructType($Event_EventHandleGenerator, $EmptyTypeValueArray)
}
var $Event_EventHandleGenerator_$memory: $Memory;
var $Event_EventHandleGenerator_$memory_$old: $Memory;
function {:inline} $Event_EventHandleGenerator_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 2
      && $IsValidU64($SelectField($this, $Event_EventHandleGenerator_counter))
      && is#$Address($SelectField($this, $Event_EventHandleGenerator_addr))
}
function {:inline} $Event_EventHandleGenerator_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $Event_EventHandleGenerator_$is_well_formed($this: $Value): bool {
    $Event_EventHandleGenerator_$is_well_typed($this) && $Event_EventHandleGenerator_$invariant_holds($this)}

procedure {:inline 1} $Event_EventHandleGenerator_pack($file_id: int, $byte_index: int, $var_idx: int, counter: $Value, addr: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(counter);
    assume is#$Address(addr);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := counter][1 := addr], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Event_EventHandleGenerator_unpack($struct: $Value) returns (counter: $Value, addr: $Value)
{
    assume is#$Vector($struct);
    counter := $SelectField($struct, $Event_EventHandleGenerator_counter);
    assume $IsValidU64(counter);
    addr := $SelectField($struct, $Event_EventHandleGenerator_addr);
    assume is#$Address(addr);
}



// ** functions of module Event



// ** spec vars of module AccountFreezing



// ** spec funs of module AccountFreezing

function {:inline} $AccountFreezing_$account_is_frozen($AccountFreezing_FreezingBit_$memory: $Memory, addr: $Value): $Value {
    $Boolean(b#$Boolean($ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($SelectField($ResourceValue($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, addr), $AccountFreezing_FreezingBit_is_frozen)))
}

function {:inline} $AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory: $Memory, addr: $Value): $Value {
    $Boolean(b#$Boolean($ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($SelectField($ResourceValue($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, addr), $AccountFreezing_FreezingBit_is_frozen)))
}

function {:inline} $AccountFreezing_spec_account_is_not_frozen($AccountFreezing_FreezingBit_$memory: $Memory, addr: $Value): $Value {
    $Boolean(b#$Boolean($ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Boolean(!b#$Boolean($SelectField($ResourceValue($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, addr), $AccountFreezing_FreezingBit_is_frozen)))))
}

function {:inline} $AccountFreezing_addr$8(lr_account: $Value): $Value {
    $Signer_spec_address_of(lr_account)
}

function {:inline} $AccountFreezing_addr$9(account: $Value): $Value {
    $Signer_spec_address_of(account)
}



// ** structs of module AccountFreezing

const unique $AccountFreezing_FreezeAccountEvent: $TypeName;
const $AccountFreezing_FreezeAccountEvent_initiator_address: $FieldName;
axiom $AccountFreezing_FreezeAccountEvent_initiator_address == 0;
const $AccountFreezing_FreezeAccountEvent_frozen_address: $FieldName;
axiom $AccountFreezing_FreezeAccountEvent_frozen_address == 1;
function $AccountFreezing_FreezeAccountEvent_type_value(): $TypeValue {
    $StructType($AccountFreezing_FreezeAccountEvent, $EmptyTypeValueArray)
}
var $AccountFreezing_FreezeAccountEvent_$memory: $Memory;
var $AccountFreezing_FreezeAccountEvent_$memory_$old: $Memory;
function {:inline} $AccountFreezing_FreezeAccountEvent_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 2
      && is#$Address($SelectField($this, $AccountFreezing_FreezeAccountEvent_initiator_address))
      && is#$Address($SelectField($this, $AccountFreezing_FreezeAccountEvent_frozen_address))
}
function {:inline} $AccountFreezing_FreezeAccountEvent_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $AccountFreezing_FreezeAccountEvent_$is_well_formed($this: $Value): bool {
    $AccountFreezing_FreezeAccountEvent_$is_well_typed($this) && $AccountFreezing_FreezeAccountEvent_$invariant_holds($this)}

procedure {:inline 1} $AccountFreezing_FreezeAccountEvent_pack($file_id: int, $byte_index: int, $var_idx: int, initiator_address: $Value, frozen_address: $Value) returns ($struct: $Value)
{
    assume is#$Address(initiator_address);
    assume is#$Address(frozen_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := initiator_address][1 := frozen_address], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $AccountFreezing_FreezeAccountEvent_unpack($struct: $Value) returns (initiator_address: $Value, frozen_address: $Value)
{
    assume is#$Vector($struct);
    initiator_address := $SelectField($struct, $AccountFreezing_FreezeAccountEvent_initiator_address);
    assume is#$Address(initiator_address);
    frozen_address := $SelectField($struct, $AccountFreezing_FreezeAccountEvent_frozen_address);
    assume is#$Address(frozen_address);
}

const unique $AccountFreezing_FreezeEventsHolder: $TypeName;
const $AccountFreezing_FreezeEventsHolder_freeze_event_handle: $FieldName;
axiom $AccountFreezing_FreezeEventsHolder_freeze_event_handle == 0;
const $AccountFreezing_FreezeEventsHolder_unfreeze_event_handle: $FieldName;
axiom $AccountFreezing_FreezeEventsHolder_unfreeze_event_handle == 1;
function $AccountFreezing_FreezeEventsHolder_type_value(): $TypeValue {
    $StructType($AccountFreezing_FreezeEventsHolder, $EmptyTypeValueArray)
}
var $AccountFreezing_FreezeEventsHolder_$memory: $Memory;
var $AccountFreezing_FreezeEventsHolder_$memory_$old: $Memory;
function {:inline} $AccountFreezing_FreezeEventsHolder_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 2
      && $Event_EventHandle_$is_well_typed($SelectField($this, $AccountFreezing_FreezeEventsHolder_freeze_event_handle))
      && $Event_EventHandle_$is_well_typed($SelectField($this, $AccountFreezing_FreezeEventsHolder_unfreeze_event_handle))
}
function {:inline} $AccountFreezing_FreezeEventsHolder_$invariant_holds($this: $Value): bool {
    $Event_EventHandle_$invariant_holds($SelectField($this, $AccountFreezing_FreezeEventsHolder_freeze_event_handle))
      && $Event_EventHandle_$invariant_holds($SelectField($this, $AccountFreezing_FreezeEventsHolder_unfreeze_event_handle))
}

function {:inline} $AccountFreezing_FreezeEventsHolder_$is_well_formed($this: $Value): bool {
    $AccountFreezing_FreezeEventsHolder_$is_well_typed($this) && $AccountFreezing_FreezeEventsHolder_$invariant_holds($this)}

procedure {:inline 1} $AccountFreezing_FreezeEventsHolder_pack($file_id: int, $byte_index: int, $var_idx: int, freeze_event_handle: $Value, unfreeze_event_handle: $Value) returns ($struct: $Value)
{
    assume $Event_EventHandle_$is_well_formed(freeze_event_handle);
    assume $Event_EventHandle_$is_well_formed(unfreeze_event_handle);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := freeze_event_handle][1 := unfreeze_event_handle], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $AccountFreezing_FreezeEventsHolder_unpack($struct: $Value) returns (freeze_event_handle: $Value, unfreeze_event_handle: $Value)
{
    assume is#$Vector($struct);
    freeze_event_handle := $SelectField($struct, $AccountFreezing_FreezeEventsHolder_freeze_event_handle);
    assume $Event_EventHandle_$is_well_formed(freeze_event_handle);
    unfreeze_event_handle := $SelectField($struct, $AccountFreezing_FreezeEventsHolder_unfreeze_event_handle);
    assume $Event_EventHandle_$is_well_formed(unfreeze_event_handle);
}

const unique $AccountFreezing_FreezingBit: $TypeName;
const $AccountFreezing_FreezingBit_is_frozen: $FieldName;
axiom $AccountFreezing_FreezingBit_is_frozen == 0;
function $AccountFreezing_FreezingBit_type_value(): $TypeValue {
    $StructType($AccountFreezing_FreezingBit, $EmptyTypeValueArray)
}
var $AccountFreezing_FreezingBit_$memory: $Memory;
var $AccountFreezing_FreezingBit_$memory_$old: $Memory;
function {:inline} $AccountFreezing_FreezingBit_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $AccountFreezing_FreezingBit_is_frozen))
}
function {:inline} $AccountFreezing_FreezingBit_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $AccountFreezing_FreezingBit_$is_well_formed($this: $Value): bool {
    $AccountFreezing_FreezingBit_$is_well_typed($this) && $AccountFreezing_FreezingBit_$invariant_holds($this)}

procedure {:inline 1} $AccountFreezing_FreezingBit_pack($file_id: int, $byte_index: int, $var_idx: int, is_frozen: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(is_frozen);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := is_frozen], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $AccountFreezing_FreezingBit_unpack($struct: $Value) returns (is_frozen: $Value)
{
    assume is#$Vector($struct);
    is_frozen := $SelectField($struct, $AccountFreezing_FreezingBit_is_frozen);
    assume is#$Boolean(is_frozen);
}

const unique $AccountFreezing_UnfreezeAccountEvent: $TypeName;
const $AccountFreezing_UnfreezeAccountEvent_initiator_address: $FieldName;
axiom $AccountFreezing_UnfreezeAccountEvent_initiator_address == 0;
const $AccountFreezing_UnfreezeAccountEvent_unfrozen_address: $FieldName;
axiom $AccountFreezing_UnfreezeAccountEvent_unfrozen_address == 1;
function $AccountFreezing_UnfreezeAccountEvent_type_value(): $TypeValue {
    $StructType($AccountFreezing_UnfreezeAccountEvent, $EmptyTypeValueArray)
}
var $AccountFreezing_UnfreezeAccountEvent_$memory: $Memory;
var $AccountFreezing_UnfreezeAccountEvent_$memory_$old: $Memory;
function {:inline} $AccountFreezing_UnfreezeAccountEvent_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 2
      && is#$Address($SelectField($this, $AccountFreezing_UnfreezeAccountEvent_initiator_address))
      && is#$Address($SelectField($this, $AccountFreezing_UnfreezeAccountEvent_unfrozen_address))
}
function {:inline} $AccountFreezing_UnfreezeAccountEvent_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $AccountFreezing_UnfreezeAccountEvent_$is_well_formed($this: $Value): bool {
    $AccountFreezing_UnfreezeAccountEvent_$is_well_typed($this) && $AccountFreezing_UnfreezeAccountEvent_$invariant_holds($this)}

procedure {:inline 1} $AccountFreezing_UnfreezeAccountEvent_pack($file_id: int, $byte_index: int, $var_idx: int, initiator_address: $Value, unfrozen_address: $Value) returns ($struct: $Value)
{
    assume is#$Address(initiator_address);
    assume is#$Address(unfrozen_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := initiator_address][1 := unfrozen_address], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $AccountFreezing_UnfreezeAccountEvent_unpack($struct: $Value) returns (initiator_address: $Value, unfrozen_address: $Value)
{
    assume is#$Vector($struct);
    initiator_address := $SelectField($struct, $AccountFreezing_UnfreezeAccountEvent_initiator_address);
    assume is#$Address(initiator_address);
    unfrozen_address := $SelectField($struct, $AccountFreezing_UnfreezeAccountEvent_unfrozen_address);
    assume is#$Address(unfrozen_address);
}



// ** functions of module AccountFreezing

procedure {:inline 1} $AccountFreezing_account_is_frozen_$def(addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $AccountFreezing_FreezingBit_type_value()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 5660, 0, addr); }

    // bytecode translation starts here
    // $t2 := move(addr)
    call $t2 := $CopyOrMoveValue(addr);

    // $t3 := exists<AccountFreezing::FreezingBit>($t2)
    $t3 := $ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, $t2);

    // if ($t3) goto L0 else goto L1
    if (b#$Boolean($t3)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t4 := get_global<AccountFreezing::FreezingBit>($t2)
    call $t4 := $GetGlobal($AccountFreezing_FreezingBit_$memory, $t2, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 5774, $abort_code);
      goto Abort;
    }

    // $t5 := get_field<AccountFreezing::FreezingBit>.is_frozen($t4)
    call $t5 := $GetFieldFromValue($t4, $AccountFreezing_FreezingBit_is_frozen);

    // tmp#$1 := $t5
    call tmp#$1 := $CopyOrMoveValue($t5);
    if (true) { assume $DebugTrackLocal(2, 5745, 1, tmp#$1); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t6 := false
    $t6 := $Boolean(false);

    // tmp#$1 := $t6
    call tmp#$1 := $CopyOrMoveValue($t6);
    if (true) { assume $DebugTrackLocal(2, 5745, 1, tmp#$1); }

    // goto L3
    goto L3;

    // L3:
L3:

    // return tmp#$1
    $ret0 := tmp#$1;
    if (true) { assume $DebugTrackLocal(2, 5745, 7, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $AccountFreezing_account_is_frozen_$direct_inter(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, addr)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $AccountFreezing_account_is_frozen_$direct_intra(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, addr)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, a))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, a), $AccountFreezing_FreezingBit_is_frozen), old($SelectField($ResourceValue($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, a), $AccountFreezing_FreezingBit_is_frozen)))))))))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $AccountFreezing_account_is_frozen(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, addr)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $AccountFreezing_assert_not_frozen_$def(account: $Value) returns ()
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 6025, 0, account); }

    // bytecode translation starts here
    // $t3 := move(account)
    call $t3 := $CopyOrMoveValue(account);

    // $t4 := AccountFreezing::account_is_frozen($t3)
    call $t4 := $AccountFreezing_account_is_frozen($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 5671, $abort_code);
      goto Abort;
    }

    // $t5 := !($t4)
    call $t5 := $Not($t4);

    // $t6 := 5
    $t6 := $Integer(5);

    // $t7 := Errors::invalid_state($t6)
    call $t7 := $Errors_invalid_state($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 6147, $abort_code);
      goto Abort;
    }

    // if ($t5) goto L0 else goto L1
    if (b#$Boolean($t5)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t7)
    if (true) { assume $DebugTrackAbort(2, 6103, i#$Integer($t7)); }
    $abort_code := i#$Integer($t7);
    goto Abort;

    // L0:
L0:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $AccountFreezing_assert_not_frozen_$direct_inter(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, account))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, account))));
ensures $abort_flag ==> ((b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, account))) &&
       $abort_code == i#$Integer($Integer(1))));

procedure {:inline 1} $AccountFreezing_assert_not_frozen_$direct_intra(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, account))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, account))));
ensures $abort_flag ==> ((b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, account))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, a))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, a), $AccountFreezing_FreezingBit_is_frozen), old($SelectField($ResourceValue($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, a), $AccountFreezing_FreezingBit_is_frozen)))))))))));

procedure {:inline 1} $AccountFreezing_assert_not_frozen(account: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, account))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, account))));
ensures $abort_flag ==> ((b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, account))) &&
       $abort_code == i#$Integer($Integer(1))));

procedure {:inline 1} $AccountFreezing_create_$def(account: $Value) returns ()
{
    // declare local variables
    var addr: $Value; // $AddressType()
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $AccountFreezing_FreezingBit_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 2457, 0, account); }

    // bytecode translation starts here
    // $t4 := move(account)
    call $t4 := $CopyOrMoveValue(account);

    // addr := Signer::address_of($t4)
    call addr := $Signer_address_of($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 2522, $abort_code);
      goto Abort;
    }

    // $t5 := exists<AccountFreezing::FreezingBit>(addr)
    $t5 := $ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, addr);

    // $t6 := !($t5)
    call $t6 := $Not($t5);

    // $t7 := 2
    $t7 := $Integer(2);

    // $t8 := Errors::already_published($t7)
    call $t8 := $Errors_already_published($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 2594, $abort_code);
      goto Abort;
    }

    // if ($t6) goto L0 else goto L1
    if (b#$Boolean($t6)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t4)

    // abort($t8)
    if (true) { assume $DebugTrackAbort(2, 2551, i#$Integer($t8)); }
    $abort_code := i#$Integer($t8);
    goto Abort;

    // L0:
L0:

    // $t9 := false
    $t9 := $Boolean(false);

    // $t10 := pack AccountFreezing::FreezingBit($t9)
    call $t10 := $AccountFreezing_FreezingBit_pack(0, 0, 0, $t9);

    // move_to<AccountFreezing::FreezingBit>($t10, $t4)
    call $AccountFreezing_FreezingBit_$memory := $MoveTo($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, $t10, $t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 2637, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $AccountFreezing_create_$direct_inter(account: $Value) returns ()
{
    assume is#$Address(account);

    call $AccountFreezing_create_$def(account);
}


procedure {:inline 1} $AccountFreezing_create_$direct_intra(account: $Value) returns ()
{
    assume is#$Address(account);

    call $AccountFreezing_create_$def(account);
}


procedure {:inline 1} $AccountFreezing_create(account: $Value) returns ()
{
    assume is#$Address(account);

    call $AccountFreezing_create_$def(account);
}


procedure {:inline 1} $AccountFreezing_freeze_account_$def(account: $Value, frozen_address: $Value) returns ()
{
    // declare local variables
    var initiator_address: $Value; // $AddressType()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var tmp#$5: $Value; // $BooleanType()
    var tmp#$6: $Value; // $IntegerType()
    var tmp#$7: $Value; // $BooleanType()
    var tmp#$8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $BooleanType()
    var $t23: $Mutation; // ReferenceType($AccountFreezing_FreezingBit_type_value())
    var $t24: $Mutation; // ReferenceType($BooleanType())
    var $t25: $Value; // $AddressType()
    var $t26: $Mutation; // ReferenceType($AccountFreezing_FreezeEventsHolder_type_value())
    var $t27: $Mutation; // ReferenceType($Event_EventHandle_type_value($AccountFreezing_FreezeAccountEvent_type_value()))
    var $t28: $Value; // $AccountFreezing_FreezeAccountEvent_type_value()
    var $t29: $Value; // $Event_EventHandle_type_value($AccountFreezing_FreezeAccountEvent_type_value())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 2944, 0, account); }
    if (true) { assume $DebugTrackLocal(2, 2944, 1, frozen_address); }

    // bytecode translation starts here
    // $t9 := move(account)
    call $t9 := $CopyOrMoveValue(account);

    // $t10 := move(frozen_address)
    call $t10 := $CopyOrMoveValue(frozen_address);

    // LibraTimestamp::assert_operating()
    call $LibraTimestamp_assert_operating();
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 3107, $abort_code);
      goto Abort;
    }

    // Roles::assert_treasury_compliance($t9)
    call $Roles_assert_treasury_compliance($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 3142, $abort_code);
      goto Abort;
    }

    // $t11 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t11 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t12 := !=($t10, $t11)
    $t12 := $Boolean(!$IsEqual($t10, $t11));

    // $t13 := 3
    $t13 := $Integer(3);

    // $t14 := Errors::invalid_argument($t13)
    call $t14 := $Errors_invalid_argument($t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 3315, $abort_code);
      goto Abort;
    }

    // if ($t12) goto L0 else goto L1
    if (b#$Boolean($t12)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t9)

    // abort($t14)
    if (true) { assume $DebugTrackAbort(2, 3245, i#$Integer($t14)); }
    $abort_code := i#$Integer($t14);
    goto Abort;

    // L0:
L0:

    // $t15 := CoreAddresses::TREASURY_COMPLIANCE_ADDRESS()
    call $t15 := $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t16 := !=($t10, $t15)
    $t16 := $Boolean(!$IsEqual($t10, $t15));

    // $t17 := 4
    $t17 := $Integer(4);

    // $t18 := Errors::invalid_argument($t17)
    call $t18 := $Errors_invalid_argument($t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 3448, $abort_code);
      goto Abort;
    }

    // if ($t16) goto L2 else goto L3
    if (b#$Boolean($t16)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // destroy($t9)

    // abort($t18)
    if (true) { assume $DebugTrackAbort(2, 3369, i#$Integer($t18)); }
    $abort_code := i#$Integer($t18);
    goto Abort;

    // L2:
L2:

    // $t19 := exists<AccountFreezing::FreezingBit>($t10)
    $t19 := $ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, $t10);

    // $t20 := 2
    $t20 := $Integer(2);

    // $t21 := Errors::not_published($t20)
    call $t21 := $Errors_not_published($t20);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 3546, $abort_code);
      goto Abort;
    }

    // if ($t19) goto L4 else goto L5
    if (b#$Boolean($t19)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // destroy($t9)

    // abort($t21)
    if (true) { assume $DebugTrackAbort(2, 3494, i#$Integer($t21)); }
    $abort_code := i#$Integer($t21);
    goto Abort;

    // L4:
L4:

    // $t22 := true
    $t22 := $Boolean(true);

    // $t23 := borrow_global<AccountFreezing::FreezingBit>($t10)
    call $t23 := $BorrowGlobal($AccountFreezing_FreezingBit_$memory, $t10, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 3585, $abort_code);
      goto Abort;
    }

    // unpack_ref($t23)

    // $t24 := borrow_field<AccountFreezing::FreezingBit>.is_frozen($t23)
    call $t24 := $BorrowField($t23, $AccountFreezing_FreezingBit_is_frozen);

    // unpack_ref($t24)

    // write_ref($t24, $t22)
    call $t24 := $WriteRef($t24, $t22);

    // pack_ref($t24)

    // write_back[Reference($t23)]($t24)
    call $t23 := $WritebackToReference($t24, $t23);

    // pack_ref($t23)

    // write_back[AccountFreezing::FreezingBit]($t23)
    call $AccountFreezing_FreezingBit_$memory := $WritebackToGlobal($AccountFreezing_FreezingBit_$memory, $t23);

    // initiator_address := Signer::address_of($t9)
    call initiator_address := $Signer_address_of($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 3690, $abort_code);
      goto Abort;
    }

    // $t25 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t25 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t26 := borrow_global<AccountFreezing::FreezeEventsHolder>($t25)
    call $t26 := $BorrowGlobal($AccountFreezing_FreezeEventsHolder_$memory, $t25, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 3775, $abort_code);
      goto Abort;
    }

    // unpack_ref($t26)

    // $t27 := borrow_field<AccountFreezing::FreezeEventsHolder>.freeze_event_handle($t26)
    call $t27 := $BorrowField($t26, $AccountFreezing_FreezeEventsHolder_freeze_event_handle);

    // unpack_ref($t27)

    // $t28 := pack AccountFreezing::FreezeAccountEvent(initiator_address, $t10)
    call $t28 := $AccountFreezing_FreezeAccountEvent_pack(0, 0, 0, initiator_address, $t10);

    // $t29 := read_ref($t27)
    call $t29 := $ReadRef($t27);
    assert $Event_EventHandle_$invariant_holds($t29);

    // $t29 := Event::emit_event<AccountFreezing::FreezeAccountEvent>($t29, $t28)
    call $t29 := $Event_emit_event($AccountFreezing_FreezeAccountEvent_type_value(), $t29, $t28);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 3726, $abort_code);
      goto Abort;
    }

    // write_ref($t27, $t29)
    call $t27 := $WriteRef($t27, $t29);

    // pack_ref($t27)

    // write_back[Reference($t26)]($t27)
    call $t26 := $WritebackToReference($t27, $t26);

    // pack_ref($t26)

    // write_back[AccountFreezing::FreezeEventsHolder]($t26)
    call $AccountFreezing_FreezeEventsHolder_$memory := $WritebackToGlobal($AccountFreezing_FreezeEventsHolder_$memory, $t26);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $AccountFreezing_freeze_account_$direct_inter(account: $Value, frozen_address: $Value) returns ()
{
    assume is#$Address(account);

    assume is#$Address(frozen_address);

    call $AccountFreezing_freeze_account_$def(account, frozen_address);
}


procedure {:inline 1} $AccountFreezing_freeze_account_$direct_intra(account: $Value, frozen_address: $Value) returns ()
{
    assume is#$Address(account);

    assume is#$Address(frozen_address);

    call $AccountFreezing_freeze_account_$def(account, frozen_address);
}


procedure {:inline 1} $AccountFreezing_freeze_account(account: $Value, frozen_address: $Value) returns ()
{
    assume is#$Address(account);

    assume is#$Address(frozen_address);

    call $AccountFreezing_freeze_account_$def(account, frozen_address);
}


procedure {:inline 1} $AccountFreezing_initialize_$def(lr_account: $Value) returns ()
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $Event_EventHandle_type_value($AccountFreezing_FreezeAccountEvent_type_value())
    var $t10: $Value; // $Event_EventHandle_type_value($AccountFreezing_UnfreezeAccountEvent_type_value())
    var $t11: $Value; // $AccountFreezing_FreezeEventsHolder_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 1594, 0, lr_account); }

    // bytecode translation starts here
    // $t3 := move(lr_account)
    call $t3 := $CopyOrMoveValue(lr_account);

    // LibraTimestamp::assert_genesis()
    call $LibraTimestamp_assert_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 1663, $abort_code);
      goto Abort;
    }

    // CoreAddresses::assert_libra_root($t3)
    call $CoreAddresses_assert_libra_root($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 1704, $abort_code);
      goto Abort;
    }

    // $t4 := Signer::address_of($t3)
    call $t4 := $Signer_address_of($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 1799, $abort_code);
      goto Abort;
    }

    // $t5 := exists<AccountFreezing::FreezeEventsHolder>($t4)
    $t5 := $ResourceExists($AccountFreezing_FreezeEventsHolder_$memory, $EmptyTypeValueArray, $t4);

    // $t6 := !($t5)
    call $t6 := $Not($t5);

    // $t7 := 1
    $t7 := $Integer(1);

    // $t8 := Errors::already_published($t7)
    call $t8 := $Errors_already_published($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 1844, $abort_code);
      goto Abort;
    }

    // if ($t6) goto L0 else goto L1
    if (b#$Boolean($t6)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t3)

    // abort($t8)
    if (true) { assume $DebugTrackAbort(2, 1743, i#$Integer($t8)); }
    $abort_code := i#$Integer($t8);
    goto Abort;

    // L0:
L0:

    // $t9 := Event::new_event_handle<AccountFreezing::FreezeAccountEvent>($t3)
    call $t9 := $Event_new_event_handle($AccountFreezing_FreezeAccountEvent_type_value(), $t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 1985, $abort_code);
      goto Abort;
    }

    // $t10 := Event::new_event_handle<AccountFreezing::UnfreezeAccountEvent>($t3)
    call $t10 := $Event_new_event_handle($AccountFreezing_UnfreezeAccountEvent_type_value(), $t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 2057, $abort_code);
      goto Abort;
    }

    // $t11 := pack AccountFreezing::FreezeEventsHolder($t9, $t10)
    call $t11 := $AccountFreezing_FreezeEventsHolder_pack(0, 0, 0, $t9, $t10);

    // move_to<AccountFreezing::FreezeEventsHolder>($t11, $t3)
    call $AccountFreezing_FreezeEventsHolder_$memory := $MoveTo($AccountFreezing_FreezeEventsHolder_$memory, $EmptyTypeValueArray, $t11, $t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 1904, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $AccountFreezing_initialize_$direct_inter(lr_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    call $AccountFreezing_initialize_$def(lr_account);
}


procedure {:inline 1} $AccountFreezing_initialize_$direct_intra(lr_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    call $AccountFreezing_initialize_$def(lr_account);
}


procedure {:inline 1} $AccountFreezing_initialize(lr_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    call $AccountFreezing_initialize_$def(lr_account);
}


procedure {:inline 1} $AccountFreezing_unfreeze_account_$def(account: $Value, unfrozen_address: $Value) returns ()
{
    // declare local variables
    var initiator_address: $Value; // $AddressType()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Mutation; // ReferenceType($AccountFreezing_FreezingBit_type_value())
    var $t12: $Mutation; // ReferenceType($BooleanType())
    var $t13: $Value; // $AddressType()
    var $t14: $Mutation; // ReferenceType($AccountFreezing_FreezeEventsHolder_type_value())
    var $t15: $Mutation; // ReferenceType($Event_EventHandle_type_value($AccountFreezing_UnfreezeAccountEvent_type_value()))
    var $t16: $Value; // $AccountFreezing_UnfreezeAccountEvent_type_value()
    var $t17: $Value; // $Event_EventHandle_type_value($AccountFreezing_UnfreezeAccountEvent_type_value())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 4545, 0, account); }
    if (true) { assume $DebugTrackLocal(2, 4545, 1, unfrozen_address); }

    // bytecode translation starts here
    // $t5 := move(account)
    call $t5 := $CopyOrMoveValue(account);

    // $t6 := move(unfrozen_address)
    call $t6 := $CopyOrMoveValue(unfrozen_address);

    // LibraTimestamp::assert_operating()
    call $LibraTimestamp_assert_operating();
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 4712, $abort_code);
      goto Abort;
    }

    // Roles::assert_treasury_compliance($t5)
    call $Roles_assert_treasury_compliance($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 4747, $abort_code);
      goto Abort;
    }

    // $t7 := exists<AccountFreezing::FreezingBit>($t6)
    $t7 := $ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, $t6);

    // $t8 := 2
    $t8 := $Integer(2);

    // $t9 := Errors::not_published($t8)
    call $t9 := $Errors_not_published($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 4846, $abort_code);
      goto Abort;
    }

    // if ($t7) goto L0 else goto L1
    if (b#$Boolean($t7)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t5)

    // abort($t9)
    if (true) { assume $DebugTrackAbort(2, 4792, i#$Integer($t9)); }
    $abort_code := i#$Integer($t9);
    goto Abort;

    // L0:
L0:

    // $t10 := false
    $t10 := $Boolean(false);

    // $t11 := borrow_global<AccountFreezing::FreezingBit>($t6)
    call $t11 := $BorrowGlobal($AccountFreezing_FreezingBit_$memory, $t6, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 4885, $abort_code);
      goto Abort;
    }

    // unpack_ref($t11)

    // $t12 := borrow_field<AccountFreezing::FreezingBit>.is_frozen($t11)
    call $t12 := $BorrowField($t11, $AccountFreezing_FreezingBit_is_frozen);

    // unpack_ref($t12)

    // write_ref($t12, $t10)
    call $t12 := $WriteRef($t12, $t10);

    // pack_ref($t12)

    // write_back[Reference($t11)]($t12)
    call $t11 := $WritebackToReference($t12, $t11);

    // pack_ref($t11)

    // write_back[AccountFreezing::FreezingBit]($t11)
    call $AccountFreezing_FreezingBit_$memory := $WritebackToGlobal($AccountFreezing_FreezingBit_$memory, $t11);

    // initiator_address := Signer::address_of($t5)
    call initiator_address := $Signer_address_of($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 4993, $abort_code);
      goto Abort;
    }

    // $t13 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t13 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t14 := borrow_global<AccountFreezing::FreezeEventsHolder>($t13)
    call $t14 := $BorrowGlobal($AccountFreezing_FreezeEventsHolder_$memory, $t13, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 5080, $abort_code);
      goto Abort;
    }

    // unpack_ref($t14)

    // $t15 := borrow_field<AccountFreezing::FreezeEventsHolder>.unfreeze_event_handle($t14)
    call $t15 := $BorrowField($t14, $AccountFreezing_FreezeEventsHolder_unfreeze_event_handle);

    // unpack_ref($t15)

    // $t16 := pack AccountFreezing::UnfreezeAccountEvent(initiator_address, $t6)
    call $t16 := $AccountFreezing_UnfreezeAccountEvent_pack(0, 0, 0, initiator_address, $t6);

    // $t17 := read_ref($t15)
    call $t17 := $ReadRef($t15);
    assert $Event_EventHandle_$invariant_holds($t17);

    // $t17 := Event::emit_event<AccountFreezing::UnfreezeAccountEvent>($t17, $t16)
    call $t17 := $Event_emit_event($AccountFreezing_UnfreezeAccountEvent_type_value(), $t17, $t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 5029, $abort_code);
      goto Abort;
    }

    // write_ref($t15, $t17)
    call $t15 := $WriteRef($t15, $t17);

    // pack_ref($t15)

    // write_back[Reference($t14)]($t15)
    call $t14 := $WritebackToReference($t15, $t14);

    // pack_ref($t14)

    // write_back[AccountFreezing::FreezeEventsHolder]($t14)
    call $AccountFreezing_FreezeEventsHolder_$memory := $WritebackToGlobal($AccountFreezing_FreezeEventsHolder_$memory, $t14);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $AccountFreezing_unfreeze_account_$direct_inter(account: $Value, unfrozen_address: $Value) returns ()
{
    assume is#$Address(account);

    assume is#$Address(unfrozen_address);

    call $AccountFreezing_unfreeze_account_$def(account, unfrozen_address);
}


procedure {:inline 1} $AccountFreezing_unfreeze_account_$direct_intra(account: $Value, unfrozen_address: $Value) returns ()
{
    assume is#$Address(account);

    assume is#$Address(unfrozen_address);

    call $AccountFreezing_unfreeze_account_$def(account, unfrozen_address);
}


procedure {:inline 1} $AccountFreezing_unfreeze_account(account: $Value, unfrozen_address: $Value) returns ()
{
    assume is#$Address(account);

    assume is#$Address(unfrozen_address);

    call $AccountFreezing_unfreeze_account_$def(account, unfrozen_address);
}




// ** spec vars of module AccountLimits



// ** spec funs of module AccountLimits

function {:inline} $AccountLimits_$has_window_published($AccountLimits_Window_$memory: $Memory, $tv0: $TypeValue, addr: $Value): $Value {
    $ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)
}

function {:inline} $AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory, $AccountLimits_LimitsDefinition_$memory: $Memory, $AccountLimits_Window_$memory: $Memory, $tv0: $TypeValue, amount: $Value, addr: $Value): $Value {
    $AccountLimits_spec_receiving_limits_ok($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), amount)
}

function {:inline} $AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory, $AccountLimits_LimitsDefinition_$memory: $Memory, $AccountLimits_Window_$memory: $Memory, $tv0: $TypeValue, amount: $Value, addr: $Value): $Value {
    $AccountLimits_spec_withdrawal_limits_ok($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), amount)
}

function {:inline} $AccountLimits_spec_window_expired($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory, $tv0: $TypeValue, window: $Value, limits_definition: $Value): $Value {
    $Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(i#$Integer($SelectField(window, $AccountLimits_Window_window_start)) + i#$Integer($SelectField(limits_definition, $AccountLimits_LimitsDefinition_time_period)))))
}

function {:inline} $AccountLimits_spec_window_reset_with_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory, $tv0: $TypeValue, window: $Value, limits_definition: $Value): $Value {
    if (b#$Boolean($AccountLimits_spec_window_expired($LibraTimestamp_CurrentTimeMicroseconds_$memory, $tv0, window, limits_definition))) then ($Vector($ExtendValueArray($ExtendValueArray($ExtendValueArray($ExtendValueArray($ExtendValueArray($EmptyValueArray(), $LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)), $Integer(0)), $Integer(0)), $SelectField(window, $AccountLimits_Window_tracked_balance)), $SelectField(window, $AccountLimits_Window_limit_address)))) else (window)
}

function {:inline} $AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory: $Memory, $tv0: $TypeValue, window: $Value): $Value {
    $ResourceValue($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField(window, $AccountLimits_Window_limit_address))
}

function {:inline} $AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory: $Memory, $tv0: $TypeValue, window: $Value): $Value {
    $AccountLimits_spec_is_unrestricted($tv0, $AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, window))
}

function {:inline} $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory, $AccountLimits_LimitsDefinition_$memory: $Memory, $tv0: $TypeValue, window: $Value): $Value {
    $AccountLimits_spec_window_reset_with_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $tv0, window, $AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, window))
}

function {:inline} $AccountLimits_spec_receiving_limits_ok($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory, $AccountLimits_LimitsDefinition_$memory: $Memory, $tv0: $TypeValue, receiving: $Value, amount: $Value): $Value {
    $Boolean(b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)) || b#$Boolean($Boolean(b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) <= i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_LimitsDefinition_max_inflow)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) <= i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_LimitsDefinition_max_holding)))))))
}

function {:inline} $AccountLimits_spec_update_inflow($tv0: $TypeValue, receiving: $Value, amount: $Value): $Value {
    $UpdateField($UpdateField(receiving, $AccountLimits_Window_window_inflow, $Integer(i#$Integer($SelectField(receiving, $AccountLimits_Window_window_inflow)) + i#$Integer(amount))), $AccountLimits_Window_tracked_balance, $Integer(i#$Integer($SelectField(receiving, $AccountLimits_Window_tracked_balance)) + i#$Integer(amount)))
}

function {:inline} $AccountLimits_spec_withdrawal_limits_ok($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory, $AccountLimits_LimitsDefinition_$memory: $Memory, $tv0: $TypeValue, sending: $Value, amount: $Value): $Value {
    $Boolean(b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, sending)) || b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, sending), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) <= i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, sending), $AccountLimits_LimitsDefinition_max_outflow)))))
}

function {:inline} $AccountLimits_spec_update_outflow($tv0: $TypeValue, sending: $Value, amount: $Value): $Value {
    $UpdateField($UpdateField(sending, $AccountLimits_Window_window_outflow, $Integer(i#$Integer($SelectField(sending, $AccountLimits_Window_window_outflow)) + i#$Integer(amount))), $AccountLimits_Window_tracked_balance, if (b#$Boolean($Boolean(i#$Integer(amount) >= i#$Integer($SelectField(sending, $AccountLimits_Window_tracked_balance))))) then ($Integer(0)) else ($Integer(i#$Integer($SelectField(sending, $AccountLimits_Window_tracked_balance)) - i#$Integer(amount))))
}

function {:inline} $AccountLimits_spec_is_unrestricted($tv0: $TypeValue, limits_def: $Value): $Value {
    $Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual($SelectField(limits_def, $AccountLimits_LimitsDefinition_max_inflow), $Integer($MAX_U64)))) && b#$Boolean($Boolean($IsEqual($SelectField(limits_def, $AccountLimits_LimitsDefinition_max_outflow), $Integer($MAX_U64)))))) && b#$Boolean($Boolean($IsEqual($SelectField(limits_def, $AccountLimits_LimitsDefinition_max_holding), $Integer($MAX_U64)))))) && b#$Boolean($Boolean($IsEqual($SelectField(limits_def, $AccountLimits_LimitsDefinition_time_period), $Integer(86400000000)))))
}

function {:inline} $AccountLimits_spec_has_window_published($AccountLimits_Window_$memory: $Memory, $tv0: $TypeValue, addr: $Value): $Value {
    $ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)
}



// ** structs of module AccountLimits

const unique $AccountLimits_AccountLimitMutationCapability: $TypeName;
const $AccountLimits_AccountLimitMutationCapability_dummy_field: $FieldName;
axiom $AccountLimits_AccountLimitMutationCapability_dummy_field == 0;
function $AccountLimits_AccountLimitMutationCapability_type_value(): $TypeValue {
    $StructType($AccountLimits_AccountLimitMutationCapability, $EmptyTypeValueArray)
}
var $AccountLimits_AccountLimitMutationCapability_$memory: $Memory;
var $AccountLimits_AccountLimitMutationCapability_$memory_$old: $Memory;
function {:inline} $AccountLimits_AccountLimitMutationCapability_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $AccountLimits_AccountLimitMutationCapability_dummy_field))
}
function {:inline} $AccountLimits_AccountLimitMutationCapability_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $AccountLimits_AccountLimitMutationCapability_$is_well_formed($this: $Value): bool {
    $AccountLimits_AccountLimitMutationCapability_$is_well_typed($this) && $AccountLimits_AccountLimitMutationCapability_$invariant_holds($this)}

procedure {:inline 1} $AccountLimits_AccountLimitMutationCapability_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $AccountLimits_AccountLimitMutationCapability_unpack($struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $AccountLimits_AccountLimitMutationCapability_dummy_field);
    assume is#$Boolean(dummy_field);
}

const unique $AccountLimits_LimitsDefinition: $TypeName;
const $AccountLimits_LimitsDefinition_max_inflow: $FieldName;
axiom $AccountLimits_LimitsDefinition_max_inflow == 0;
const $AccountLimits_LimitsDefinition_max_outflow: $FieldName;
axiom $AccountLimits_LimitsDefinition_max_outflow == 1;
const $AccountLimits_LimitsDefinition_time_period: $FieldName;
axiom $AccountLimits_LimitsDefinition_time_period == 2;
const $AccountLimits_LimitsDefinition_max_holding: $FieldName;
axiom $AccountLimits_LimitsDefinition_max_holding == 3;
function $AccountLimits_LimitsDefinition_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($AccountLimits_LimitsDefinition, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1))
}
var $AccountLimits_LimitsDefinition_$memory: $Memory;
var $AccountLimits_LimitsDefinition_$memory_$old: $Memory;
function {:inline} $AccountLimits_LimitsDefinition_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 4
      && $IsValidU64($SelectField($this, $AccountLimits_LimitsDefinition_max_inflow))
      && $IsValidU64($SelectField($this, $AccountLimits_LimitsDefinition_max_outflow))
      && $IsValidU64($SelectField($this, $AccountLimits_LimitsDefinition_time_period))
      && $IsValidU64($SelectField($this, $AccountLimits_LimitsDefinition_max_holding))
}
function {:inline} $AccountLimits_LimitsDefinition_$invariant_holds($this: $Value): bool {
    b#$Boolean($Boolean(i#$Integer($SelectField($this, $AccountLimits_LimitsDefinition_max_inflow)) > i#$Integer($Integer(0))))
      && b#$Boolean($Boolean(i#$Integer($SelectField($this, $AccountLimits_LimitsDefinition_max_outflow)) > i#$Integer($Integer(0))))
      && b#$Boolean($Boolean(i#$Integer($SelectField($this, $AccountLimits_LimitsDefinition_time_period)) > i#$Integer($Integer(0))))
      && b#$Boolean($Boolean(i#$Integer($SelectField($this, $AccountLimits_LimitsDefinition_max_holding)) > i#$Integer($Integer(0))))
}

function {:inline} $AccountLimits_LimitsDefinition_$is_well_formed($this: $Value): bool {
    $AccountLimits_LimitsDefinition_$is_well_typed($this) && $AccountLimits_LimitsDefinition_$invariant_holds($this)}

procedure {:inline 1} $AccountLimits_LimitsDefinition_$unpack_ref_deep($tv0: $TypeValue, $before: $Value) {
    assume $AccountLimits_LimitsDefinition_$invariant_holds($before);
}

procedure {:inline 1} $AccountLimits_LimitsDefinition_$unpack_ref($tv0: $TypeValue, $before: $Value) {
    assume $AccountLimits_LimitsDefinition_$invariant_holds($before);
}

procedure {:inline 1} $AccountLimits_LimitsDefinition_$pack_ref_deep($tv0: $TypeValue, $after: $Value) {
    assert b#$Boolean($Boolean(i#$Integer($SelectField($after, $AccountLimits_LimitsDefinition_max_inflow)) > i#$Integer($Integer(0))));
    assert b#$Boolean($Boolean(i#$Integer($SelectField($after, $AccountLimits_LimitsDefinition_max_outflow)) > i#$Integer($Integer(0))));
    assert b#$Boolean($Boolean(i#$Integer($SelectField($after, $AccountLimits_LimitsDefinition_time_period)) > i#$Integer($Integer(0))));
    assert b#$Boolean($Boolean(i#$Integer($SelectField($after, $AccountLimits_LimitsDefinition_max_holding)) > i#$Integer($Integer(0))));
}

procedure {:inline 1} $AccountLimits_LimitsDefinition_$pack_ref($tv0: $TypeValue, $after: $Value) {
    assert b#$Boolean($Boolean(i#$Integer($SelectField($after, $AccountLimits_LimitsDefinition_max_inflow)) > i#$Integer($Integer(0))));
    assert b#$Boolean($Boolean(i#$Integer($SelectField($after, $AccountLimits_LimitsDefinition_max_outflow)) > i#$Integer($Integer(0))));
    assert b#$Boolean($Boolean(i#$Integer($SelectField($after, $AccountLimits_LimitsDefinition_time_period)) > i#$Integer($Integer(0))));
    assert b#$Boolean($Boolean(i#$Integer($SelectField($after, $AccountLimits_LimitsDefinition_max_holding)) > i#$Integer($Integer(0))));
}

procedure {:inline 1} $AccountLimits_LimitsDefinition_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, max_inflow: $Value, max_outflow: $Value, time_period: $Value, max_holding: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(max_inflow);
    assume $IsValidU64(max_outflow);
    assume $IsValidU64(time_period);
    assume $IsValidU64(max_holding);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := max_inflow][1 := max_outflow][2 := time_period][3 := max_holding], 4));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
    assert b#$Boolean($Boolean(i#$Integer($SelectField($struct, $AccountLimits_LimitsDefinition_max_inflow)) > i#$Integer($Integer(0))));
    assert b#$Boolean($Boolean(i#$Integer($SelectField($struct, $AccountLimits_LimitsDefinition_max_outflow)) > i#$Integer($Integer(0))));
    assert b#$Boolean($Boolean(i#$Integer($SelectField($struct, $AccountLimits_LimitsDefinition_time_period)) > i#$Integer($Integer(0))));
    assert b#$Boolean($Boolean(i#$Integer($SelectField($struct, $AccountLimits_LimitsDefinition_max_holding)) > i#$Integer($Integer(0))));
}

procedure {:inline 1} $AccountLimits_LimitsDefinition_unpack($tv0: $TypeValue, $struct: $Value) returns (max_inflow: $Value, max_outflow: $Value, time_period: $Value, max_holding: $Value)
{
    assume is#$Vector($struct);
    max_inflow := $SelectField($struct, $AccountLimits_LimitsDefinition_max_inflow);
    assume $IsValidU64(max_inflow);
    max_outflow := $SelectField($struct, $AccountLimits_LimitsDefinition_max_outflow);
    assume $IsValidU64(max_outflow);
    time_period := $SelectField($struct, $AccountLimits_LimitsDefinition_time_period);
    assume $IsValidU64(time_period);
    max_holding := $SelectField($struct, $AccountLimits_LimitsDefinition_max_holding);
    assume $IsValidU64(max_holding);
}

const unique $AccountLimits_Window: $TypeName;
const $AccountLimits_Window_window_start: $FieldName;
axiom $AccountLimits_Window_window_start == 0;
const $AccountLimits_Window_window_inflow: $FieldName;
axiom $AccountLimits_Window_window_inflow == 1;
const $AccountLimits_Window_window_outflow: $FieldName;
axiom $AccountLimits_Window_window_outflow == 2;
const $AccountLimits_Window_tracked_balance: $FieldName;
axiom $AccountLimits_Window_tracked_balance == 3;
const $AccountLimits_Window_limit_address: $FieldName;
axiom $AccountLimits_Window_limit_address == 4;
function $AccountLimits_Window_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($AccountLimits_Window, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1))
}
var $AccountLimits_Window_$memory: $Memory;
var $AccountLimits_Window_$memory_$old: $Memory;
function {:inline} $AccountLimits_Window_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 5
      && $IsValidU64($SelectField($this, $AccountLimits_Window_window_start))
      && $IsValidU64($SelectField($this, $AccountLimits_Window_window_inflow))
      && $IsValidU64($SelectField($this, $AccountLimits_Window_window_outflow))
      && $IsValidU64($SelectField($this, $AccountLimits_Window_tracked_balance))
      && is#$Address($SelectField($this, $AccountLimits_Window_limit_address))
}
function {:inline} $AccountLimits_Window_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $AccountLimits_Window_$is_well_formed($this: $Value): bool {
    $AccountLimits_Window_$is_well_typed($this) && $AccountLimits_Window_$invariant_holds($this)}

procedure {:inline 1} $AccountLimits_Window_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, window_start: $Value, window_inflow: $Value, window_outflow: $Value, tracked_balance: $Value, limit_address: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(window_start);
    assume $IsValidU64(window_inflow);
    assume $IsValidU64(window_outflow);
    assume $IsValidU64(tracked_balance);
    assume is#$Address(limit_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := window_start][1 := window_inflow][2 := window_outflow][3 := tracked_balance][4 := limit_address], 5));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $AccountLimits_Window_unpack($tv0: $TypeValue, $struct: $Value) returns (window_start: $Value, window_inflow: $Value, window_outflow: $Value, tracked_balance: $Value, limit_address: $Value)
{
    assume is#$Vector($struct);
    window_start := $SelectField($struct, $AccountLimits_Window_window_start);
    assume $IsValidU64(window_start);
    window_inflow := $SelectField($struct, $AccountLimits_Window_window_inflow);
    assume $IsValidU64(window_inflow);
    window_outflow := $SelectField($struct, $AccountLimits_Window_window_outflow);
    assume $IsValidU64(window_outflow);
    tracked_balance := $SelectField($struct, $AccountLimits_Window_tracked_balance);
    assume $IsValidU64(tracked_balance);
    limit_address := $SelectField($struct, $AccountLimits_Window_limit_address);
    assume is#$Address(limit_address);
}



// ** functions of module AccountLimits

procedure {:inline 1} $AccountLimits_can_receive_$def($tv0: $TypeValue, amount: $Value, receiving: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    // declare local variables
    var holding_ok: $Value; // $BooleanType()
    var inflow_ok: $Value; // $BooleanType()
    var limits_definition: $Value; // $AccountLimits_LimitsDefinition_type_value($tv0)
    var tmp#$5: $Value; // $BooleanType()
    var tmp#$6: $Value; // $IntegerType()
    var tmp#$7: $Value; // $BooleanType()
    var tmp#$8: $Value; // $IntegerType()
    var tmp#$9: $Value; // $BooleanType()
    var tmp#$10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $AccountLimits_Window_type_value($tv0)
    var $t13: $Mutation; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Value; // $BooleanType()
    var $t21: $Value; // $AccountLimits_Window_type_value($tv0)
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $BooleanType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $IntegerType()
    var $t30: $Value; // $IntegerType()
    var $t31: $Value; // $IntegerType()
    var $t32: $Value; // $IntegerType()
    var $t33: $Value; // $IntegerType()
    var $t34: $Value; // $BooleanType()
    var $t35: $Value; // $IntegerType()
    var $t36: $Value; // $IntegerType()
    var $t37: $Value; // $IntegerType()
    var $t38: $Value; // $IntegerType()
    var $t39: $Value; // $IntegerType()
    var $t40: $Value; // $BooleanType()
    var $t41: $Value; // $IntegerType()
    var $t42: $Value; // $IntegerType()
    var $t43: $Mutation; // ReferenceType($IntegerType())
    var $t44: $Value; // $IntegerType()
    var $t45: $Value; // $IntegerType()
    var $t46: $Mutation; // ReferenceType($IntegerType())
    var $t47: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(3, 13941, 0, amount); }
    if (true) { assume $DebugTrackLocal(3, 13941, 1, receiving); }

    // bytecode translation starts here
    // $t11 := move(amount)
    call $t11 := $CopyOrMoveValue(amount);

    // $t12 := move(receiving)
    call $t12 := $CopyOrMoveValue(receiving);

    // $t13 := borrow_local($t12)
    call $t13 := $BorrowLoc(12, $t12);

    // $t14 := get_field<AccountLimits::Window<#0>>.limit_address($t13)
    call $t14 := $GetFieldFromReference($t13, $AccountLimits_Window_limit_address);

    // $t15 := exists<AccountLimits::LimitsDefinition<#0>>($t14)
    $t15 := $ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t14);

    // $t16 := 0
    $t16 := $Integer(0);

    // $t17 := Errors::not_published($t16)
    call $t17 := $Errors_not_published($t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 14155, $abort_code);
      goto Abort;
    }

    // if ($t15) goto L0 else goto L1
    if (b#$Boolean($t15)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t13)

    // abort($t17)
    if (true) { assume $DebugTrackAbort(3, 14079, i#$Integer($t17)); }
    $abort_code := i#$Integer($t17);
    goto Abort;

    // L0:
L0:

    // $t18 := get_field<AccountLimits::Window<#0>>.limit_address($t13)
    call $t18 := $GetFieldFromReference($t13, $AccountLimits_Window_limit_address);

    // limits_definition := get_global<AccountLimits::LimitsDefinition<#0>>($t18)
    call limits_definition := $GetGlobal($AccountLimits_LimitsDefinition_$memory, $t18, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 14223, $abort_code);
      goto Abort;
    }
    if (true) { assume $DebugTrackLocal(3, 14223, 4, limits_definition); }

    // $t19 := AccountLimits::is_unrestricted<#0>(limits_definition)
    call $t19 := $AccountLimits_is_unrestricted($tv0, limits_definition);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 21664, $abort_code);
      goto Abort;
    }

    // if ($t19) goto L2 else goto L3
    if (b#$Boolean($t19)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // goto L4
    goto L4;

    // L2:
L2:

    // destroy($t13)

    // destroy(limits_definition)

    // $t20 := true
    $t20 := $Boolean(true);

    // return ($t20, $t12)
    $ret0 := $t20;
    if (true) { assume $DebugTrackLocal(3, 14410, 48, $ret0); }
    $ret1 := $t12;
    if (true) { assume $DebugTrackLocal(3, 14410, 49, $ret1); }
    return;

    // L4:
L4:

    // $t21 := read_ref($t13)
    call $t21 := $ReadRef($t13);
    assert $AccountLimits_Window_$invariant_holds($t21);

    // $t21 := AccountLimits::reset_window<#0>($t21, limits_definition)
    call $t21 := $AccountLimits_reset_window($tv0, $t21, limits_definition);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 11602, $abort_code);
      goto Abort;
    }

    // write_ref($t13, $t21)
    call $t13 := $WriteRef($t13, $t21);

    // $t22 := get_field<AccountLimits::Window<#0>>.window_inflow($t13)
    call $t22 := $GetFieldFromReference($t13, $AccountLimits_Window_window_inflow);

    // $t23 := 18446744073709551615
    $t23 := $Integer(18446744073709551615);

    // $t24 := -($t23, $t11)
    call $t24 := $Sub($t23, $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 14679, $abort_code);
      goto Abort;
    }

    // $t25 := <=($t22, $t24)
    call $t25 := $Le($t22, $t24);

    // $t26 := 1
    $t26 := $Integer(1);

    // $t27 := Errors::limit_exceeded($t26)
    call $t27 := $Errors_limit_exceeded($t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 14697, $abort_code);
      goto Abort;
    }

    // if ($t25) goto L5 else goto L6
    if (b#$Boolean($t25)) { goto L5; } else { goto L6; }

    // L6:
L6:

    // destroy($t13)

    // write_back[LocalRoot($t12)]($t13)
    call $t12 := $WritebackToValue($t13, 12, $t12);

    // destroy(limits_definition)

    // abort($t27)
    if (true) { assume $DebugTrackAbort(3, 14637, i#$Integer($t27)); }
    $abort_code := i#$Integer($t27);
    goto Abort;

    // L5:
L5:

    // $t28 := get_field<AccountLimits::Window<#0>>.window_inflow($t13)
    call $t28 := $GetFieldFromReference($t13, $AccountLimits_Window_window_inflow);

    // $t29 := +($t28, $t11)
    call $t29 := $AddU64($t28, $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 14772, $abort_code);
      goto Abort;
    }

    // $t30 := get_field<AccountLimits::LimitsDefinition<#0>>.max_inflow(limits_definition)
    call $t30 := $GetFieldFromValue(limits_definition, $AccountLimits_LimitsDefinition_max_inflow);

    // inflow_ok := <=($t29, $t30)
    call inflow_ok := $Le($t29, $t30);
    if (true) { assume $DebugTrackLocal(3, 14782, 3, inflow_ok); }

    // $t31 := get_field<AccountLimits::Window<#0>>.tracked_balance($t13)
    call $t31 := $GetFieldFromReference($t13, $AccountLimits_Window_tracked_balance);

    // $t32 := 18446744073709551615
    $t32 := $Integer(18446744073709551615);

    // $t33 := -($t32, $t11)
    call $t33 := $Sub($t32, $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 14925, $abort_code);
      goto Abort;
    }

    // $t34 := <=($t31, $t33)
    call $t34 := $Le($t31, $t33);

    // $t35 := 1
    $t35 := $Integer(1);

    // $t36 := Errors::limit_exceeded($t35)
    call $t36 := $Errors_limit_exceeded($t35);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 14943, $abort_code);
      goto Abort;
    }

    // if ($t34) goto L7 else goto L8
    if (b#$Boolean($t34)) { goto L7; } else { goto L8; }

    // L8:
L8:

    // destroy($t13)

    // write_back[LocalRoot($t12)]($t13)
    call $t12 := $WritebackToValue($t13, 12, $t12);

    // destroy(limits_definition)

    // abort($t36)
    if (true) { assume $DebugTrackAbort(3, 14881, i#$Integer($t36)); }
    $abort_code := i#$Integer($t36);
    goto Abort;

    // L7:
L7:

    // $t37 := get_field<AccountLimits::Window<#0>>.tracked_balance($t13)
    call $t37 := $GetFieldFromReference($t13, $AccountLimits_Window_tracked_balance);

    // $t38 := +($t37, $t11)
    call $t38 := $AddU64($t37, $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 15021, $abort_code);
      goto Abort;
    }

    // $t39 := get_field<AccountLimits::LimitsDefinition<#0>>.max_holding(limits_definition)
    call $t39 := $GetFieldFromValue(limits_definition, $AccountLimits_LimitsDefinition_max_holding);

    // holding_ok := <=($t38, $t39)
    call holding_ok := $Le($t38, $t39);
    if (true) { assume $DebugTrackLocal(3, 15031, 2, holding_ok); }

    // $t40 := &&(inflow_ok, holding_ok)
    call $t40 := $And(inflow_ok, holding_ok);

    // if ($t40) goto L9 else goto L10
    if (b#$Boolean($t40)) { goto L9; } else { goto L10; }

    // L10:
L10:

    // goto L11
    goto L11;

    // L9:
L9:

    // $t41 := get_field<AccountLimits::Window<#0>>.window_inflow($t13)
    call $t41 := $GetFieldFromReference($t13, $AccountLimits_Window_window_inflow);

    // $t42 := +($t41, $t11)
    call $t42 := $AddU64($t41, $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 15251, $abort_code);
      goto Abort;
    }

    // $t43 := borrow_field<AccountLimits::Window<#0>>.window_inflow($t13)
    call $t43 := $BorrowField($t13, $AccountLimits_Window_window_inflow);

    // write_ref($t43, $t42)
    call $t43 := $WriteRef($t43, $t42);

    // write_back[Reference($t13)]($t43)
    call $t13 := $WritebackToReference($t43, $t13);

    // $t44 := get_field<AccountLimits::Window<#0>>.tracked_balance($t13)
    call $t44 := $GetFieldFromReference($t13, $AccountLimits_Window_tracked_balance);

    // $t45 := +($t44, $t11)
    call $t45 := $AddU64($t44, $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 15327, $abort_code);
      goto Abort;
    }

    // $t46 := borrow_field<AccountLimits::Window<#0>>.tracked_balance($t13)
    call $t46 := $BorrowField($t13, $AccountLimits_Window_tracked_balance);

    // write_ref($t46, $t45)
    call $t46 := $WriteRef($t46, $t45);

    // write_back[Reference($t13)]($t46)
    call $t13 := $WritebackToReference($t46, $t13);

    // write_back[LocalRoot($t12)]($t13)
    call $t12 := $WritebackToValue($t13, 12, $t12);

    // goto L12
    goto L12;

    // L11:
L11:

    // destroy($t13)

    // write_back[LocalRoot($t12)]($t13)
    call $t12 := $WritebackToValue($t13, 12, $t12);

    // goto L12
    goto L12;

    // L12:
L12:

    // $t47 := &&(inflow_ok, holding_ok)
    call $t47 := $And(inflow_ok, holding_ok);

    // return ($t47, $t12)
    $ret0 := $t47;
    if (true) { assume $DebugTrackLocal(3, 15356, 48, $ret0); }
    $ret1 := $t12;
    if (true) { assume $DebugTrackLocal(3, 15356, 49, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}

procedure {:inline 1} $AccountLimits_can_receive_$direct_intra($tv0: $TypeValue, amount: $Value, receiving: $Value) returns ($ret0: $Value, $ret1: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField(receiving, $AccountLimits_Window_limit_address)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField(receiving, $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField(receiving, $AccountLimits_Window_limit_address))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField(receiving, $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField(receiving, $AccountLimits_Window_limit_address)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField(receiving, $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $AccountLimits_spec_receiving_limits_ok($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old(receiving), amount)))));
ensures !$abort_flag ==> (b#$Boolean(if (b#$Boolean($Boolean(b#$Boolean($ret0) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, old(receiving)))))))) then ($Boolean($IsEqual($ret1, $AccountLimits_spec_update_inflow($tv0, $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old(receiving)), amount)))) else ($Boolean(b#$Boolean($Boolean($IsEqual($ret1, $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old(receiving))))) || b#$Boolean($Boolean($IsEqual($ret1, old(receiving))))))));
ensures is#$Boolean($ret0);
ensures $AccountLimits_Window_$is_well_typed($ret1);

procedure {:inline 1} $AccountLimits_can_receive($tv0: $TypeValue, amount: $Value, receiving: $Value) returns ($ret0: $Value, $ret1: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField(receiving, $AccountLimits_Window_limit_address)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField(receiving, $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField(receiving, $AccountLimits_Window_limit_address))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField(receiving, $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField(receiving, $AccountLimits_Window_limit_address)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField(receiving, $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, receiving), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, receiving)))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $AccountLimits_spec_receiving_limits_ok($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old(receiving), amount)))));
ensures !$abort_flag ==> (b#$Boolean(if (b#$Boolean($Boolean(b#$Boolean($ret0) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, old(receiving)))))))) then ($Boolean($IsEqual($ret1, $AccountLimits_spec_update_inflow($tv0, $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old(receiving)), amount)))) else ($Boolean(b#$Boolean($Boolean($IsEqual($ret1, $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old(receiving))))) || b#$Boolean($Boolean($IsEqual($ret1, old(receiving))))))));
ensures is#$Boolean($ret0);
ensures $AccountLimits_Window_$is_well_typed($ret1);

procedure {:inline 1} $AccountLimits_can_withdraw_$def($tv0: $TypeValue, amount: $Value, sending: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    // declare local variables
    var limits_definition: $Value; // $AccountLimits_LimitsDefinition_type_value($tv0)
    var outflow_ok: $Value; // $BooleanType()
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var tmp#$6: $Value; // $BooleanType()
    var tmp#$7: $Value; // $IntegerType()
    var tmp#$8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AccountLimits_Window_type_value($tv0)
    var $t11: $Mutation; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $BooleanType()
    var $t19: $Value; // $AccountLimits_Window_type_value($tv0)
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $IntegerType()
    var $t30: $Value; // $IntegerType()
    var $t31: $Mutation; // ReferenceType($IntegerType())
    var $t32: $Value; // $IntegerType()
    var $t33: $Value; // $BooleanType()
    var $t34: $Value; // $IntegerType()
    var $t35: $Value; // $IntegerType()
    var $t36: $Mutation; // ReferenceType($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(3, 18479, 0, amount); }
    if (true) { assume $DebugTrackLocal(3, 18479, 1, sending); }

    // bytecode translation starts here
    // $t9 := move(amount)
    call $t9 := $CopyOrMoveValue(amount);

    // $t10 := move(sending)
    call $t10 := $CopyOrMoveValue(sending);

    // $t11 := borrow_local($t10)
    call $t11 := $BorrowLoc(10, $t10);

    // $t12 := get_field<AccountLimits::Window<#0>>.limit_address($t11)
    call $t12 := $GetFieldFromReference($t11, $AccountLimits_Window_limit_address);

    // $t13 := exists<AccountLimits::LimitsDefinition<#0>>($t12)
    $t13 := $ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t12);

    // $t14 := 0
    $t14 := $Integer(0);

    // $t15 := Errors::not_published($t14)
    call $t15 := $Errors_not_published($t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 18690, $abort_code);
      goto Abort;
    }

    // if ($t13) goto L0 else goto L1
    if (b#$Boolean($t13)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t11)

    // abort($t15)
    if (true) { assume $DebugTrackAbort(3, 18616, i#$Integer($t15)); }
    $abort_code := i#$Integer($t15);
    goto Abort;

    // L0:
L0:

    // $t16 := get_field<AccountLimits::Window<#0>>.limit_address($t11)
    call $t16 := $GetFieldFromReference($t11, $AccountLimits_Window_limit_address);

    // limits_definition := get_global<AccountLimits::LimitsDefinition<#0>>($t16)
    call limits_definition := $GetGlobal($AccountLimits_LimitsDefinition_$memory, $t16, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 18758, $abort_code);
      goto Abort;
    }
    if (true) { assume $DebugTrackLocal(3, 18758, 2, limits_definition); }

    // $t17 := AccountLimits::is_unrestricted<#0>(limits_definition)
    call $t17 := $AccountLimits_is_unrestricted($tv0, limits_definition);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 21664, $abort_code);
      goto Abort;
    }

    // if ($t17) goto L2 else goto L3
    if (b#$Boolean($t17)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // goto L4
    goto L4;

    // L2:
L2:

    // destroy($t11)

    // destroy(limits_definition)

    // $t18 := true
    $t18 := $Boolean(true);

    // return ($t18, $t10)
    $ret0 := $t18;
    if (true) { assume $DebugTrackLocal(3, 18943, 37, $ret0); }
    $ret1 := $t10;
    if (true) { assume $DebugTrackLocal(3, 18943, 38, $ret1); }
    return;

    // L4:
L4:

    // $t19 := read_ref($t11)
    call $t19 := $ReadRef($t11);
    assert $AccountLimits_Window_$invariant_holds($t19);

    // $t19 := AccountLimits::reset_window<#0>($t19, limits_definition)
    call $t19 := $AccountLimits_reset_window($tv0, $t19, limits_definition);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 11602, $abort_code);
      goto Abort;
    }

    // write_ref($t11, $t19)
    call $t11 := $WriteRef($t11, $t19);

    // $t20 := get_field<AccountLimits::Window<#0>>.window_outflow($t11)
    call $t20 := $GetFieldFromReference($t11, $AccountLimits_Window_window_outflow);

    // $t21 := 18446744073709551615
    $t21 := $Integer(18446744073709551615);

    // $t22 := -($t21, $t9)
    call $t22 := $Sub($t21, $t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 19087, $abort_code);
      goto Abort;
    }

    // $t23 := <=($t20, $t22)
    call $t23 := $Le($t20, $t22);

    // $t24 := 1
    $t24 := $Integer(1);

    // $t25 := Errors::limit_exceeded($t24)
    call $t25 := $Errors_limit_exceeded($t24);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 19105, $abort_code);
      goto Abort;
    }

    // if ($t23) goto L5 else goto L6
    if (b#$Boolean($t23)) { goto L5; } else { goto L6; }

    // L6:
L6:

    // destroy($t11)

    // write_back[LocalRoot($t10)]($t11)
    call $t10 := $WritebackToValue($t11, 10, $t10);

    // destroy(limits_definition)

    // abort($t25)
    if (true) { assume $DebugTrackAbort(3, 19046, i#$Integer($t25)); }
    $abort_code := i#$Integer($t25);
    goto Abort;

    // L5:
L5:

    // $t26 := get_field<AccountLimits::Window<#0>>.window_outflow($t11)
    call $t26 := $GetFieldFromReference($t11, $AccountLimits_Window_window_outflow);

    // $t27 := +($t26, $t9)
    call $t27 := $AddU64($t26, $t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 19179, $abort_code);
      goto Abort;
    }

    // $t28 := get_field<AccountLimits::LimitsDefinition<#0>>.max_outflow(limits_definition)
    call $t28 := $GetFieldFromValue(limits_definition, $AccountLimits_LimitsDefinition_max_outflow);

    // outflow_ok := <=($t27, $t28)
    call outflow_ok := $Le($t27, $t28);
    if (true) { assume $DebugTrackLocal(3, 19188, 3, outflow_ok); }

    // if (outflow_ok) goto L7 else goto L8
    if (b#$Boolean(outflow_ok)) { goto L7; } else { goto L8; }

    // L8:
L8:

    // goto L9
    goto L9;

    // L7:
L7:

    // $t29 := get_field<AccountLimits::Window<#0>>.window_outflow($t11)
    call $t29 := $GetFieldFromReference($t11, $AccountLimits_Window_window_outflow);

    // $t30 := +($t29, $t9)
    call $t30 := $AddU64($t29, $t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 19345, $abort_code);
      goto Abort;
    }

    // $t31 := borrow_field<AccountLimits::Window<#0>>.window_outflow($t11)
    call $t31 := $BorrowField($t11, $AccountLimits_Window_window_outflow);

    // write_ref($t31, $t30)
    call $t31 := $WriteRef($t31, $t30);

    // write_back[Reference($t11)]($t31)
    call $t11 := $WritebackToReference($t31, $t11);

    // $t32 := get_field<AccountLimits::Window<#0>>.tracked_balance($t11)
    call $t32 := $GetFieldFromReference($t11, $AccountLimits_Window_tracked_balance);

    // $t33 := >=($t9, $t32)
    call $t33 := $Ge($t9, $t32);

    // if ($t33) goto L10 else goto L11
    if (b#$Boolean($t33)) { goto L10; } else { goto L11; }

    // L11:
L11:

    // goto L12
    goto L12;

    // L10:
L10:

    // $t34 := 0
    $t34 := $Integer(0);

    // tmp#$8 := $t34
    call tmp#$8 := $CopyOrMoveValue($t34);
    if (true) { assume $DebugTrackLocal(3, 19393, 8, tmp#$8); }

    // goto L13
    goto L13;

    // L12:
L12:

    // $t35 := get_field<AccountLimits::Window<#0>>.tracked_balance($t11)
    call $t35 := $GetFieldFromReference($t11, $AccountLimits_Window_tracked_balance);

    // tmp#$8 := -($t35, $t9)
    call tmp#$8 := $Sub($t35, $t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 19502, $abort_code);
      goto Abort;
    }
    if (true) { assume $DebugTrackLocal(3, 19502, 8, tmp#$8); }

    // goto L13
    goto L13;

    // L13:
L13:

    // $t36 := borrow_field<AccountLimits::Window<#0>>.tracked_balance($t11)
    call $t36 := $BorrowField($t11, $AccountLimits_Window_tracked_balance);

    // write_ref($t36, tmp#$8)
    call $t36 := $WriteRef($t36, tmp#$8);

    // write_back[Reference($t11)]($t36)
    call $t11 := $WritebackToReference($t36, $t11);

    // write_back[LocalRoot($t10)]($t11)
    call $t10 := $WritebackToValue($t11, 10, $t10);

    // goto L14
    goto L14;

    // L9:
L9:

    // destroy($t11)

    // write_back[LocalRoot($t10)]($t11)
    call $t10 := $WritebackToValue($t11, 10, $t10);

    // goto L14
    goto L14;

    // L14:
L14:

    // return (outflow_ok, $t10)
    $ret0 := outflow_ok;
    if (true) { assume $DebugTrackLocal(3, 19531, 37, $ret0); }
    $ret1 := $t10;
    if (true) { assume $DebugTrackLocal(3, 19531, 38, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}

procedure {:inline 1} $AccountLimits_can_withdraw_$direct_intra($tv0: $TypeValue, amount: $Value, sending: $Value) returns ($ret0: $Value, $ret1: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField(sending, $AccountLimits_Window_limit_address)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, sending)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, sending), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, sending)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField(sending, $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, sending), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, sending)))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField(sending, $AccountLimits_Window_limit_address))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, sending)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, sending), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, sending)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField(sending, $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, sending), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, sending)))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField(sending, $AccountLimits_Window_limit_address)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, sending)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, sending), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, sending)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField(sending, $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, sending), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, sending)))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $AccountLimits_spec_withdrawal_limits_ok($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old(sending), amount)))));
ensures !$abort_flag ==> (b#$Boolean(if (b#$Boolean($Boolean(b#$Boolean($ret0) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, old(sending)))))))) then ($Boolean($IsEqual($ret1, $AccountLimits_spec_update_outflow($tv0, $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old(sending)), amount)))) else ($Boolean(b#$Boolean($Boolean($IsEqual($ret1, $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old(sending))))) || b#$Boolean($Boolean($IsEqual($ret1, old(sending))))))));
ensures is#$Boolean($ret0);
ensures $AccountLimits_Window_$is_well_typed($ret1);

procedure {:inline 1} $AccountLimits_can_withdraw($tv0: $TypeValue, amount: $Value, sending: $Value) returns ($ret0: $Value, $ret1: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField(sending, $AccountLimits_Window_limit_address)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, sending)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, sending), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, sending)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField(sending, $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, sending), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, sending)))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField(sending, $AccountLimits_Window_limit_address))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, sending)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, sending), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, sending)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField(sending, $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, sending), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, sending)))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField(sending, $AccountLimits_Window_limit_address)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, sending)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, sending), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, sending)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField(sending, $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, sending), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, sending)))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $AccountLimits_spec_withdrawal_limits_ok($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old(sending), amount)))));
ensures !$abort_flag ==> (b#$Boolean(if (b#$Boolean($Boolean(b#$Boolean($ret0) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, old(sending)))))))) then ($Boolean($IsEqual($ret1, $AccountLimits_spec_update_outflow($tv0, $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old(sending)), amount)))) else ($Boolean(b#$Boolean($Boolean($IsEqual($ret1, $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old(sending))))) || b#$Boolean($Boolean($IsEqual($ret1, old(sending))))))));
ensures is#$Boolean($ret0);
ensures $AccountLimits_Window_$is_well_typed($ret1);

procedure {:inline 1} $AccountLimits_current_time_$def() returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$0: $Value; // $IntegerType()
    var $t1: $Value; // $BooleanType()
    var $t2: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t1 := LibraTimestamp::is_genesis()
    call $t1 := $LibraTimestamp_is_genesis();
    if ($abort_flag) {
      goto Abort;
    }

    // if ($t1) goto L0 else goto L1
    if (b#$Boolean($t1)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t2 := 0
    $t2 := $Integer(0);

    // tmp#$0 := $t2
    call tmp#$0 := $CopyOrMoveValue($t2);
    if (true) { assume $DebugTrackLocal(3, 23163, 0, tmp#$0); }

    // goto L3
    goto L3;

    // L2:
L2:

    // tmp#$0 := LibraTimestamp::now_microseconds()
    call tmp#$0 := $LibraTimestamp_now_microseconds();
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 23220, $abort_code);
      goto Abort;
    }

    // goto L3
    goto L3;

    // L3:
L3:

    // return tmp#$0
    $ret0 := tmp#$0;
    if (true) { assume $DebugTrackLocal(3, 23163, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $AccountLimits_current_time_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $AccountLimits_current_time_$def();
}


procedure {:inline 1} $AccountLimits_current_time() returns ($ret0: $Value)
{
    call $ret0 := $AccountLimits_current_time_$def();
}


procedure {:inline 1} $AccountLimits_grant_mutation_capability_$def(lr_account: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $AccountLimits_AccountLimitMutationCapability_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(3, 2518, 0, lr_account); }

    // bytecode translation starts here
    // $t1 := move(lr_account)
    call $t1 := $CopyOrMoveValue(lr_account);

    // LibraTimestamp::assert_genesis()
    call $LibraTimestamp_assert_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 2634, $abort_code);
      goto Abort;
    }

    // Roles::assert_libra_root($t1)
    call $Roles_assert_libra_root($t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 2667, $abort_code);
      goto Abort;
    }

    // $t2 := false
    $t2 := $Boolean(false);

    // $t3 := pack AccountLimits::AccountLimitMutationCapability($t2)
    call $t3 := $AccountLimits_AccountLimitMutationCapability_pack(0, 0, 0, $t2);

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(3, 2706, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $AccountLimits_grant_mutation_capability_$direct_inter(lr_account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(lr_account);

    call $ret0 := $AccountLimits_grant_mutation_capability_$def(lr_account);
}


procedure {:inline 1} $AccountLimits_grant_mutation_capability_$direct_intra(lr_account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(lr_account);

    call $ret0 := $AccountLimits_grant_mutation_capability_$def(lr_account);
}


procedure {:inline 1} $AccountLimits_grant_mutation_capability(lr_account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(lr_account);

    call $ret0 := $AccountLimits_grant_mutation_capability_$def(lr_account);
}


procedure {:inline 1} $AccountLimits_has_limits_published_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(3, 22627, 0, addr); }

    // bytecode translation starts here
    // $t1 := move(addr)
    call $t1 := $CopyOrMoveValue(addr);

    // $t2 := exists<AccountLimits::LimitsDefinition<#0>>($t1)
    $t2 := $ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t1);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(3, 22700, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $AccountLimits_has_limits_published_$direct_inter($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $AccountLimits_has_limits_published_$def($tv0, addr);
}


procedure {:inline 1} $AccountLimits_has_limits_published_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $AccountLimits_has_limits_published_$def($tv0, addr);
}


procedure {:inline 1} $AccountLimits_has_limits_published($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $AccountLimits_has_limits_published_$def($tv0, addr);
}


procedure {:inline 1} $AccountLimits_has_window_published_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(3, 22752, 0, addr); }

    // bytecode translation starts here
    // $t1 := move(addr)
    call $t1 := $CopyOrMoveValue(addr);

    // $t2 := exists<AccountLimits::Window<#0>>($t1)
    $t2 := $ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t1);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(3, 22825, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $AccountLimits_has_window_published_$direct_inter($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $AccountLimits_has_window_published_$def($tv0, addr);
}


procedure {:inline 1} $AccountLimits_has_window_published_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $AccountLimits_has_window_published_$def($tv0, addr);
}


procedure {:inline 1} $AccountLimits_has_window_published($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $AccountLimits_has_window_published_$def($tv0, addr);
}


procedure {:inline 1} $AccountLimits_is_unrestricted_$def($tv0: $TypeValue, limits_def: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $BooleanType()
    var $t4: $Value; // $AccountLimits_LimitsDefinition_type_value($tv0)
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(3, 21660, 0, limits_def); }

    // bytecode translation starts here
    // $t4 := move(limits_def)
    call $t4 := $CopyOrMoveValue(limits_def);

    // $t5 := get_field<AccountLimits::LimitsDefinition<#0>>.max_inflow($t4)
    call $t5 := $GetFieldFromValue($t4, $AccountLimits_LimitsDefinition_max_inflow);

    // $t6 := 18446744073709551615
    $t6 := $Integer(18446744073709551615);

    // $t7 := ==($t5, $t6)
    $t7 := $Boolean($IsEqual($t5, $t6));

    // if ($t7) goto L0 else goto L1
    if (b#$Boolean($t7)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t8 := get_field<AccountLimits::LimitsDefinition<#0>>.max_outflow($t4)
    call $t8 := $GetFieldFromValue($t4, $AccountLimits_LimitsDefinition_max_outflow);

    // $t9 := 18446744073709551615
    $t9 := $Integer(18446744073709551615);

    // tmp#$1 := ==($t8, $t9)
    tmp#$1 := $Boolean($IsEqual($t8, $t9));
    if (true) { assume $DebugTrackLocal(3, 21814, 1, tmp#$1); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t10 := false
    $t10 := $Boolean(false);

    // tmp#$1 := $t10
    call tmp#$1 := $CopyOrMoveValue($t10);
    if (true) { assume $DebugTrackLocal(3, 21747, 1, tmp#$1); }

    // goto L3
    goto L3;

    // L3:
L3:

    // if (tmp#$1) goto L4 else goto L5
    if (b#$Boolean(tmp#$1)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // goto L6
    goto L6;

    // L4:
L4:

    // $t11 := get_field<AccountLimits::LimitsDefinition<#0>>.max_holding($t4)
    call $t11 := $GetFieldFromValue($t4, $AccountLimits_LimitsDefinition_max_holding);

    // $t12 := 18446744073709551615
    $t12 := $Integer(18446744073709551615);

    // tmp#$2 := ==($t11, $t12)
    tmp#$2 := $Boolean($IsEqual($t11, $t12));
    if (true) { assume $DebugTrackLocal(3, 21859, 2, tmp#$2); }

    // goto L7
    goto L7;

    // L6:
L6:

    // $t13 := false
    $t13 := $Boolean(false);

    // tmp#$2 := $t13
    call tmp#$2 := $CopyOrMoveValue($t13);
    if (true) { assume $DebugTrackLocal(3, 21747, 2, tmp#$2); }

    // goto L7
    goto L7;

    // L7:
L7:

    // if (tmp#$2) goto L8 else goto L9
    if (b#$Boolean(tmp#$2)) { goto L8; } else { goto L9; }

    // L9:
L9:

    // goto L10
    goto L10;

    // L8:
L8:

    // $t14 := get_field<AccountLimits::LimitsDefinition<#0>>.time_period($t4)
    call $t14 := $GetFieldFromValue($t4, $AccountLimits_LimitsDefinition_time_period);

    // $t15 := 86400000000
    $t15 := $Integer(86400000000);

    // tmp#$3 := ==($t14, $t15)
    tmp#$3 := $Boolean($IsEqual($t14, $t15));
    if (true) { assume $DebugTrackLocal(3, 21904, 3, tmp#$3); }

    // goto L11
    goto L11;

    // L10:
L10:

    // destroy($t4)

    // $t16 := false
    $t16 := $Boolean(false);

    // tmp#$3 := $t16
    call tmp#$3 := $CopyOrMoveValue($t16);
    if (true) { assume $DebugTrackLocal(3, 21747, 3, tmp#$3); }

    // goto L11
    goto L11;

    // L11:
L11:

    // return tmp#$3
    $ret0 := tmp#$3;
    if (true) { assume $DebugTrackLocal(3, 21747, 17, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $AccountLimits_is_unrestricted_$direct_intra($tv0: $TypeValue, limits_def: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $AccountLimits_spec_is_unrestricted($tv0, limits_def)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $AccountLimits_is_unrestricted($tv0: $TypeValue, limits_def: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $AccountLimits_spec_is_unrestricted($tv0, limits_def)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $AccountLimits_limits_definition_address_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $AccountLimits_Window_type_value($tv0)
    var $t3: $Value; // $AddressType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(3, 22467, 0, addr); }

    // bytecode translation starts here
    // $t1 := move(addr)
    call $t1 := $CopyOrMoveValue(addr);

    // $t2 := get_global<AccountLimits::Window<#0>>($t1)
    call $t2 := $GetGlobal($AccountLimits_Window_$memory, $t1, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 22564, $abort_code);
      goto Abort;
    }

    // $t3 := get_field<AccountLimits::Window<#0>>.limit_address($t2)
    call $t3 := $GetFieldFromValue($t2, $AccountLimits_Window_limit_address);

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(3, 22564, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $AccountLimits_limits_definition_address_$direct_inter($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $AccountLimits_limits_definition_address_$def($tv0, addr);
}


procedure {:inline 1} $AccountLimits_limits_definition_address_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $AccountLimits_limits_definition_address_$def($tv0, addr);
}


procedure {:inline 1} $AccountLimits_limits_definition_address($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $AccountLimits_limits_definition_address_$def($tv0, addr);
}


procedure {:inline 1} $AccountLimits_publish_unrestricted_limits_$def($tv0: $TypeValue, publish_account: $Value) returns ()
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var tmp#$3: $Value; // $IntegerType()
    var tmp#$4: $Value; // $IntegerType()
    var tmp#$5: $Value; // $IntegerType()
    var tmp#$6: $Value; // $IntegerType()
    var tmp#$7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $BooleanType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $AccountLimits_LimitsDefinition_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(3, 7821, 0, publish_account); }

    // bytecode translation starts here
    // $t8 := move(publish_account)
    call $t8 := $CopyOrMoveValue(publish_account);

    // $t9 := Signer::address_of($t8)
    call $t9 := $Signer_address_of($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 7970, $abort_code);
      goto Abort;
    }

    // $t10 := exists<AccountLimits::LimitsDefinition<#0>>($t9)
    $t10 := $ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t9);

    // $t11 := !($t10)
    call $t11 := $Not($t10);

    // $t12 := 0
    $t12 := $Integer(0);

    // $t13 := Errors::already_published($t12)
    call $t13 := $Errors_already_published($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 8020, $abort_code);
      goto Abort;
    }

    // if ($t11) goto L0 else goto L1
    if (b#$Boolean($t11)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t8)

    // abort($t13)
    if (true) { assume $DebugTrackAbort(3, 7906, i#$Integer($t13)); }
    $abort_code := i#$Integer($t13);
    goto Abort;

    // L0:
L0:

    // $t14 := 18446744073709551615
    $t14 := $Integer(18446744073709551615);

    // $t15 := 18446744073709551615
    $t15 := $Integer(18446744073709551615);

    // $t16 := 86400000000
    $t16 := $Integer(86400000000);

    // $t17 := 18446744073709551615
    $t17 := $Integer(18446744073709551615);

    // $t18 := pack AccountLimits::LimitsDefinition<#0>($t14, $t15, $t16, $t17)
    call $t18 := $AccountLimits_LimitsDefinition_pack(0, 0, 0, $tv0, $t14, $t15, $t16, $t17);

    // move_to<AccountLimits::LimitsDefinition<#0>>($t18, $t8)
    call $AccountLimits_LimitsDefinition_$memory := $MoveTo($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t18, $t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 8077, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $AccountLimits_publish_unrestricted_limits_$direct_inter($tv0: $TypeValue, publish_account: $Value) returns ()
{
    assume is#$Address(publish_account);

    call $AccountLimits_publish_unrestricted_limits_$def($tv0, publish_account);
}


procedure {:inline 1} $AccountLimits_publish_unrestricted_limits_$direct_intra($tv0: $TypeValue, publish_account: $Value) returns ()
{
    assume is#$Address(publish_account);

    call $AccountLimits_publish_unrestricted_limits_$def($tv0, publish_account);
}


procedure {:inline 1} $AccountLimits_publish_unrestricted_limits($tv0: $TypeValue, publish_account: $Value) returns ()
{
    assume is#$Address(publish_account);

    call $AccountLimits_publish_unrestricted_limits_$def($tv0, publish_account);
}


procedure {:inline 1} $AccountLimits_publish_window_$def($tv0: $TypeValue, lr_account: $Value, to_limit: $Value, limit_address: $Value) returns ()
{
    // declare local variables
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var tmp#$5: $Value; // $BooleanType()
    var tmp#$6: $Value; // $IntegerType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $AccountLimits_Window_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(3, 5872, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(3, 5872, 1, to_limit); }
    if (true) { assume $DebugTrackLocal(3, 5872, 2, limit_address); }

    // bytecode translation starts here
    // $t7 := move(lr_account)
    call $t7 := $CopyOrMoveValue(lr_account);

    // $t8 := move(to_limit)
    call $t8 := $CopyOrMoveValue(to_limit);

    // $t9 := move(limit_address)
    call $t9 := $CopyOrMoveValue(limit_address);

    // Roles::assert_libra_root($t7)
    call $Roles_assert_libra_root($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 6020, $abort_code);
      goto Abort;
    }

    // $t10 := exists<AccountLimits::LimitsDefinition<#0>>($t9)
    $t10 := $ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t9);

    // $t11 := 0
    $t11 := $Integer(0);

    // $t12 := Errors::not_published($t11)
    call $t12 := $Errors_not_published($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 6125, $abort_code);
      goto Abort;
    }

    // if ($t10) goto L0 else goto L1
    if (b#$Boolean($t10)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t8)

    // abort($t12)
    if (true) { assume $DebugTrackAbort(3, 6059, i#$Integer($t12)); }
    $abort_code := i#$Integer($t12);
    goto Abort;

    // L0:
L0:

    // Roles::assert_parent_vasp_or_child_vasp($t8)
    call $Roles_assert_parent_vasp_or_child_vasp($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 6176, $abort_code);
      goto Abort;
    }

    // $t13 := Signer::address_of($t8)
    call $t13 := $Signer_address_of($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 6282, $abort_code);
      goto Abort;
    }

    // $t14 := exists<AccountLimits::Window<#0>>($t13)
    $t14 := $ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t13);

    // $t15 := !($t14)
    call $t15 := $Not($t14);

    // $t16 := 1
    $t16 := $Integer(1);

    // $t17 := Errors::already_published($t16)
    call $t17 := $Errors_already_published($t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 6325, $abort_code);
      goto Abort;
    }

    // if ($t15) goto L2 else goto L3
    if (b#$Boolean($t15)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // destroy($t8)

    // abort($t17)
    if (true) { assume $DebugTrackAbort(3, 6228, i#$Integer($t17)); }
    $abort_code := i#$Integer($t17);
    goto Abort;

    // L2:
L2:

    // $t18 := AccountLimits::current_time()
    call $t18 := $AccountLimits_current_time();
    if ($abort_flag) {
      goto Abort;
    }

    // $t19 := 0
    $t19 := $Integer(0);

    // $t20 := 0
    $t20 := $Integer(0);

    // $t21 := 0
    $t21 := $Integer(0);

    // $t22 := pack AccountLimits::Window<#0>($t18, $t19, $t20, $t21, $t9)
    call $t22 := $AccountLimits_Window_pack(0, 0, 0, $tv0, $t18, $t19, $t20, $t21, $t9);

    // move_to<AccountLimits::Window<#0>>($t22, $t8)
    call $AccountLimits_Window_$memory := $MoveTo($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t22, $t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 6371, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $AccountLimits_publish_window_$direct_inter($tv0: $TypeValue, lr_account: $Value, to_limit: $Value, limit_address: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume is#$Address(to_limit);

    assume is#$Address(limit_address);

    call $AccountLimits_publish_window_$def($tv0, lr_account, to_limit, limit_address);
}


procedure {:inline 1} $AccountLimits_publish_window_$direct_intra($tv0: $TypeValue, lr_account: $Value, to_limit: $Value, limit_address: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume is#$Address(to_limit);

    assume is#$Address(limit_address);

    call $AccountLimits_publish_window_$def($tv0, lr_account, to_limit, limit_address);
}


procedure {:inline 1} $AccountLimits_publish_window($tv0: $TypeValue, lr_account: $Value, to_limit: $Value, limit_address: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume is#$Address(to_limit);

    assume is#$Address(limit_address);

    call $AccountLimits_publish_window_$def($tv0, lr_account, to_limit, limit_address);
}


procedure {:inline 1} $AccountLimits_reset_window_$def($tv0: $TypeValue, window: $Value, limits_definition: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var current_time: $Value; // $IntegerType()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var $t5: $Value; // $AccountLimits_Window_type_value($tv0)
    var $t6: $Value; // $AccountLimits_LimitsDefinition_type_value($tv0)
    var $t7: $Mutation; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $BooleanType()
    var $t19: $Mutation; // ReferenceType($IntegerType())
    var $t20: $Value; // $IntegerType()
    var $t21: $Mutation; // ReferenceType($IntegerType())
    var $t22: $Value; // $IntegerType()
    var $t23: $Mutation; // ReferenceType($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(3, 11598, 0, window); }
    if (true) { assume $DebugTrackLocal(3, 11598, 1, limits_definition); }

    // bytecode translation starts here
    // $t5 := move(window)
    call $t5 := $CopyOrMoveValue(window);

    // $t6 := move(limits_definition)
    call $t6 := $CopyOrMoveValue(limits_definition);

    // $t7 := borrow_local($t5)
    call $t7 := $BorrowLoc(5, $t5);

    // current_time := LibraTimestamp::now_microseconds()
    call current_time := $LibraTimestamp_now_microseconds();
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 11749, $abort_code);
      goto Abort;
    }

    // $t8 := get_field<AccountLimits::Window<#0>>.window_start($t7)
    call $t8 := $GetFieldFromReference($t7, $AccountLimits_Window_window_start);

    // $t9 := 18446744073709551615
    $t9 := $Integer(18446744073709551615);

    // $t10 := get_field<AccountLimits::LimitsDefinition<#0>>.time_period($t6)
    call $t10 := $GetFieldFromValue($t6, $AccountLimits_LimitsDefinition_time_period);

    // $t11 := -($t9, $t10)
    call $t11 := $Sub($t9, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 11815, $abort_code);
      goto Abort;
    }

    // $t12 := <=($t8, $t11)
    call $t12 := $Le($t8, $t11);

    // $t13 := 1
    $t13 := $Integer(1);

    // $t14 := Errors::limit_exceeded($t13)
    call $t14 := $Errors_limit_exceeded($t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 11856, $abort_code);
      goto Abort;
    }

    // if ($t12) goto L0 else goto L1
    if (b#$Boolean($t12)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t7)

    // destroy($t6)

    // abort($t14)
    if (true) { assume $DebugTrackAbort(3, 11777, i#$Integer($t14)); }
    $abort_code := i#$Integer($t14);
    goto Abort;

    // L0:
L0:

    // $t15 := get_field<AccountLimits::Window<#0>>.window_start($t7)
    call $t15 := $GetFieldFromReference($t7, $AccountLimits_Window_window_start);

    // $t16 := get_field<AccountLimits::LimitsDefinition<#0>>.time_period($t6)
    call $t16 := $GetFieldFromValue($t6, $AccountLimits_LimitsDefinition_time_period);

    // $t17 := +($t15, $t16)
    call $t17 := $AddU64($t15, $t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 11929, $abort_code);
      goto Abort;
    }

    // $t18 := >(current_time, $t17)
    call $t18 := $Gt(current_time, $t17);

    // if ($t18) goto L2 else goto L3
    if (b#$Boolean($t18)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // goto L4
    goto L4;

    // L2:
L2:

    // $t19 := borrow_field<AccountLimits::Window<#0>>.window_start($t7)
    call $t19 := $BorrowField($t7, $AccountLimits_Window_window_start);

    // write_ref($t19, current_time)
    call $t19 := $WriteRef($t19, current_time);

    // write_back[Reference($t7)]($t19)
    call $t7 := $WritebackToReference($t19, $t7);

    // $t20 := 0
    $t20 := $Integer(0);

    // $t21 := borrow_field<AccountLimits::Window<#0>>.window_inflow($t7)
    call $t21 := $BorrowField($t7, $AccountLimits_Window_window_inflow);

    // write_ref($t21, $t20)
    call $t21 := $WriteRef($t21, $t20);

    // write_back[Reference($t7)]($t21)
    call $t7 := $WritebackToReference($t21, $t7);

    // $t22 := 0
    $t22 := $Integer(0);

    // $t23 := borrow_field<AccountLimits::Window<#0>>.window_outflow($t7)
    call $t23 := $BorrowField($t7, $AccountLimits_Window_window_outflow);

    // write_ref($t23, $t22)
    call $t23 := $WriteRef($t23, $t22);

    // write_back[Reference($t7)]($t23)
    call $t7 := $WritebackToReference($t23, $t7);

    // write_back[LocalRoot($t5)]($t7)
    call $t5 := $WritebackToValue($t7, 5, $t5);

    // goto L5
    goto L5;

    // L4:
L4:

    // destroy($t7)

    // goto L5
    goto L5;

    // L5:
L5:

    // return $t5
    $ret0 := $t5;
    if (true) { assume $DebugTrackLocal(3, 11890, 24, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $AccountLimits_reset_window_$direct_intra($tv0: $TypeValue, window: $Value, limits_definition: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(window, $AccountLimits_Window_window_start)) + i#$Integer($SelectField(limits_definition, $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(window, $AccountLimits_Window_window_start)) + i#$Integer($SelectField(limits_definition, $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(window, $AccountLimits_Window_window_start)) + i#$Integer($SelectField(limits_definition, $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, old($AccountLimits_spec_window_reset_with_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $tv0, window, limits_definition))))));
ensures $AccountLimits_Window_$is_well_typed($ret0);

procedure {:inline 1} $AccountLimits_reset_window($tv0: $TypeValue, window: $Value, limits_definition: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(window, $AccountLimits_Window_window_start)) + i#$Integer($SelectField(limits_definition, $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(window, $AccountLimits_Window_window_start)) + i#$Integer($SelectField(limits_definition, $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(window, $AccountLimits_Window_window_start)) + i#$Integer($SelectField(limits_definition, $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, old($AccountLimits_spec_window_reset_with_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $tv0, window, limits_definition))))));
ensures $AccountLimits_Window_$is_well_typed($ret0);

procedure {:inline 1} $AccountLimits_update_deposit_limits_$def($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value, $AccountLimits_Window_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Mutation; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t11: $Value; // $AccountLimits_Window_type_value($tv0)
    var $t12: $Value; // $BooleanType()
    var $AccountLimits_Window_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(3, 3118, 0, amount); }
    if (true) { assume $DebugTrackLocal(3, 3118, 1, addr); }
    if (true) { assume $DebugTrackLocal(3, 3118, 2, _cap); }
    $AccountLimits_Window_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr) := true];

    // bytecode translation starts here
    // $t5 := move(amount)
    call $t5 := $CopyOrMoveValue(amount);

    // $t6 := move(addr)
    call $t6 := $CopyOrMoveValue(addr);

    // $t7 := exists<AccountLimits::Window<#0>>($t6)
    $t7 := $ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t6);

    // $t8 := 1
    $t8 := $Integer(1);

    // $t9 := Errors::not_published($t8)
    call $t9 := $Errors_not_published($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 3356, $abort_code);
      goto Abort;
    }

    // if ($t7) goto L0 else goto L1
    if (b#$Boolean($t7)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t9)
    if (true) { assume $DebugTrackAbort(3, 3309, i#$Integer($t9)); }
    $abort_code := i#$Integer($t9);
    goto Abort;

    // L0:
L0:

    // $t10 := borrow_global<AccountLimits::Window<#0>>($t6)
    assert $AccountLimits_Window_$SelfDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($t6)];
    call $t10 := $BorrowGlobal($AccountLimits_Window_$memory, $t6, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 3444, $abort_code);
      goto Abort;
    }

    // unpack_ref($t10)

    // $t11 := read_ref($t10)
    call $t11 := $ReadRef($t10);
    assert $AccountLimits_Window_$invariant_holds($t11);

    // ($t12, $t11) := AccountLimits::can_receive<#0>($t5, $t11)
    call $t12, $t11 := $AccountLimits_can_receive($tv0, $t5, $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 13945, $abort_code);
      goto Abort;
    }

    // write_ref($t10, $t11)
    call $t10 := $WriteRef($t10, $t11);

    // pack_ref($t10)

    // write_back[AccountLimits::Window]($t10)
    call $AccountLimits_Window_$memory := $WritebackToGlobal($AccountLimits_Window_$memory, $t10);

    // return $t12
    $ret0 := $t12;
    if (true) { assume $DebugTrackLocal(3, 3389, 13, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $AccountLimits_update_deposit_limits_$direct_inter($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value, $AccountLimits_Window_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
requires $AccountLimits_Window_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr)];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $AccountLimits_spec_receiving_limits_ok($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), amount)))));
ensures !$abort_flag ==> (b#$Boolean(if (b#$Boolean($Boolean(b#$Boolean($ret0) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))) then ($Boolean($IsEqual($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_spec_update_inflow($tv0, $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))), amount)))) else ($Boolean(b#$Boolean($Boolean($IsEqual($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))))) || b#$Boolean($Boolean($IsEqual($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))))))));
ensures is#$Boolean($ret0);
modifies $AccountLimits_Window_$memory;
ensures contents#$Memory($AccountLimits_Window_$memory) == old(contents#$Memory($AccountLimits_Window_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr) := contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr)]];
ensures domain#$Memory($AccountLimits_Window_$memory) == old(domain#$Memory($AccountLimits_Window_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr) := domain#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr)]];

procedure {:inline 1} $AccountLimits_update_deposit_limits_$direct_intra($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value, $AccountLimits_Window_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
requires $AccountLimits_Window_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr)];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $AccountLimits_spec_receiving_limits_ok($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), amount)))));
ensures !$abort_flag ==> (b#$Boolean(if (b#$Boolean($Boolean(b#$Boolean($ret0) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))) then ($Boolean($IsEqual($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_spec_update_inflow($tv0, $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))), amount)))) else ($Boolean(b#$Boolean($Boolean($IsEqual($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))))) || b#$Boolean($Boolean($IsEqual($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))))))));
ensures is#$Boolean($ret0);
modifies $AccountLimits_Window_$memory;
ensures contents#$Memory($AccountLimits_Window_$memory) == old(contents#$Memory($AccountLimits_Window_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr) := contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr)]];
ensures domain#$Memory($AccountLimits_Window_$memory) == old(domain#$Memory($AccountLimits_Window_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr) := domain#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr)]];

procedure {:inline 1} $AccountLimits_update_deposit_limits($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value, $AccountLimits_Window_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
requires $AccountLimits_Window_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr)];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $AccountLimits_spec_receiving_limits_ok($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), amount)))));
ensures !$abort_flag ==> (b#$Boolean(if (b#$Boolean($Boolean(b#$Boolean($ret0) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))) then ($Boolean($IsEqual($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_spec_update_inflow($tv0, $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))), amount)))) else ($Boolean(b#$Boolean($Boolean($IsEqual($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))))) || b#$Boolean($Boolean($IsEqual($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))))))));
ensures is#$Boolean($ret0);
modifies $AccountLimits_Window_$memory;
ensures contents#$Memory($AccountLimits_Window_$memory) == old(contents#$Memory($AccountLimits_Window_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr) := contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr)]];
ensures domain#$Memory($AccountLimits_Window_$memory) == old(domain#$Memory($AccountLimits_Window_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr) := domain#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr)]];

procedure {:inline 1} $AccountLimits_update_limits_definition_$def($tv0: $TypeValue, tc_account: $Value, limit_address: $Value, new_max_inflow: $Value, new_max_outflow: $Value, new_max_holding_balance: $Value, new_time_period: $Value) returns ()
{
    // declare local variables
    var limits_def: $Mutation; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var tmp#$7: $Value; // $BooleanType()
    var tmp#$8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Mutation; // ReferenceType($IntegerType())
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $BooleanType()
    var $t23: $Mutation; // ReferenceType($IntegerType())
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $BooleanType()
    var $t26: $Mutation; // ReferenceType($IntegerType())
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $BooleanType()
    var $t29: $Mutation; // ReferenceType($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(3, 8788, 0, tc_account); }
    if (true) { assume $DebugTrackLocal(3, 8788, 1, limit_address); }
    if (true) { assume $DebugTrackLocal(3, 8788, 2, new_max_inflow); }
    if (true) { assume $DebugTrackLocal(3, 8788, 3, new_max_outflow); }
    if (true) { assume $DebugTrackLocal(3, 8788, 4, new_max_holding_balance); }
    if (true) { assume $DebugTrackLocal(3, 8788, 5, new_time_period); }

    // bytecode translation starts here
    // $t9 := move(tc_account)
    call $t9 := $CopyOrMoveValue(tc_account);

    // $t10 := move(limit_address)
    call $t10 := $CopyOrMoveValue(limit_address);

    // $t11 := move(new_max_inflow)
    call $t11 := $CopyOrMoveValue(new_max_inflow);

    // $t12 := move(new_max_outflow)
    call $t12 := $CopyOrMoveValue(new_max_outflow);

    // $t13 := move(new_max_holding_balance)
    call $t13 := $CopyOrMoveValue(new_max_holding_balance);

    // $t14 := move(new_time_period)
    call $t14 := $CopyOrMoveValue(new_time_period);

    // Roles::assert_treasury_compliance($t9)
    call $Roles_assert_treasury_compliance($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 9072, $abort_code);
      goto Abort;
    }

    // $t15 := exists<AccountLimits::LimitsDefinition<#0>>($t10)
    $t15 := $ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t10);

    // $t16 := 0
    $t16 := $Integer(0);

    // $t17 := Errors::not_published($t16)
    call $t17 := $Errors_not_published($t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 9359, $abort_code);
      goto Abort;
    }

    // if ($t15) goto L0 else goto L1
    if (b#$Boolean($t15)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t17)
    if (true) { assume $DebugTrackAbort(3, 9293, i#$Integer($t17)); }
    $abort_code := i#$Integer($t17);
    goto Abort;

    // L0:
L0:

    // limits_def := borrow_global<AccountLimits::LimitsDefinition<#0>>($t10)
    call limits_def := $BorrowGlobal($AccountLimits_LimitsDefinition_$memory, $t10, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 9420, $abort_code);
      goto Abort;
    }

    // unpack_ref(limits_def)
    call $AccountLimits_LimitsDefinition_$unpack_ref($tv0, $Dereference(limits_def));

    // $t18 := 0
    $t18 := $Integer(0);

    // $t19 := >($t11, $t18)
    call $t19 := $Gt($t11, $t18);

    // if ($t19) goto L2 else goto L3
    if (b#$Boolean($t19)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // goto L4
    goto L4;

    // L2:
L2:

    // $t20 := borrow_field<AccountLimits::LimitsDefinition<#0>>.max_inflow(limits_def)
    call $t20 := $BorrowField(limits_def, $AccountLimits_LimitsDefinition_max_inflow);

    // unpack_ref($t20)

    // write_ref($t20, $t11)
    call $t20 := $WriteRef($t20, $t11);
    if (true) { assume $DebugTrackLocal(3, 9516, 6, $Dereference(limits_def)); }

    // pack_ref($t20)

    // write_back[Reference(limits_def)]($t20)
    call limits_def := $WritebackToReference($t20, limits_def);

    // goto L4
    goto L4;

    // L4:
L4:

    // $t21 := 0
    $t21 := $Integer(0);

    // $t22 := >($t12, $t21)
    call $t22 := $Gt($t12, $t21);

    // if ($t22) goto L5 else goto L6
    if (b#$Boolean($t22)) { goto L5; } else { goto L6; }

    // L6:
L6:

    // goto L7
    goto L7;

    // L5:
L5:

    // $t23 := borrow_field<AccountLimits::LimitsDefinition<#0>>.max_outflow(limits_def)
    call $t23 := $BorrowField(limits_def, $AccountLimits_LimitsDefinition_max_outflow);

    // unpack_ref($t23)

    // write_ref($t23, $t12)
    call $t23 := $WriteRef($t23, $t12);
    if (true) { assume $DebugTrackLocal(3, 9593, 6, $Dereference(limits_def)); }

    // pack_ref($t23)

    // write_back[Reference(limits_def)]($t23)
    call limits_def := $WritebackToReference($t23, limits_def);

    // goto L7
    goto L7;

    // L7:
L7:

    // $t24 := 0
    $t24 := $Integer(0);

    // $t25 := >($t13, $t24)
    call $t25 := $Gt($t13, $t24);

    // if ($t25) goto L8 else goto L9
    if (b#$Boolean($t25)) { goto L8; } else { goto L9; }

    // L9:
L9:

    // goto L10
    goto L10;

    // L8:
L8:

    // $t26 := borrow_field<AccountLimits::LimitsDefinition<#0>>.max_holding(limits_def)
    call $t26 := $BorrowField(limits_def, $AccountLimits_LimitsDefinition_max_holding);

    // unpack_ref($t26)

    // write_ref($t26, $t13)
    call $t26 := $WriteRef($t26, $t13);
    if (true) { assume $DebugTrackLocal(3, 9680, 6, $Dereference(limits_def)); }

    // pack_ref($t26)

    // write_back[Reference(limits_def)]($t26)
    call limits_def := $WritebackToReference($t26, limits_def);

    // goto L10
    goto L10;

    // L10:
L10:

    // $t27 := 0
    $t27 := $Integer(0);

    // $t28 := >($t14, $t27)
    call $t28 := $Gt($t14, $t27);

    // if ($t28) goto L11 else goto L12
    if (b#$Boolean($t28)) { goto L11; } else { goto L12; }

    // L12:
L12:

    // goto L13
    goto L13;

    // L11:
L11:

    // $t29 := borrow_field<AccountLimits::LimitsDefinition<#0>>.time_period(limits_def)
    call $t29 := $BorrowField(limits_def, $AccountLimits_LimitsDefinition_time_period);

    // unpack_ref($t29)

    // write_ref($t29, $t14)
    call $t29 := $WriteRef($t29, $t14);
    if (true) { assume $DebugTrackLocal(3, 9767, 6, $Dereference(limits_def)); }

    // pack_ref($t29)

    // write_back[Reference(limits_def)]($t29)
    call limits_def := $WritebackToReference($t29, limits_def);

    // pack_ref(limits_def)
    call $AccountLimits_LimitsDefinition_$pack_ref($tv0, $Dereference(limits_def));

    // write_back[AccountLimits::LimitsDefinition](limits_def)
    call $AccountLimits_LimitsDefinition_$memory := $WritebackToGlobal($AccountLimits_LimitsDefinition_$memory, limits_def);

    // goto L14
    goto L14;

    // L13:
L13:

    // destroy(limits_def)

    // pack_ref(limits_def)
    call $AccountLimits_LimitsDefinition_$pack_ref($tv0, $Dereference(limits_def));

    // write_back[AccountLimits::LimitsDefinition](limits_def)
    call $AccountLimits_LimitsDefinition_$memory := $WritebackToGlobal($AccountLimits_LimitsDefinition_$memory, limits_def);

    // goto L14
    goto L14;

    // L14:
L14:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $AccountLimits_update_limits_definition_$direct_inter($tv0: $TypeValue, tc_account: $Value, limit_address: $Value, new_max_inflow: $Value, new_max_outflow: $Value, new_max_holding_balance: $Value, new_time_period: $Value) returns ()
{
    assume is#$Address(tc_account);

    assume is#$Address(limit_address);

    assume $IsValidU64(new_max_inflow);

    assume $IsValidU64(new_max_outflow);

    assume $IsValidU64(new_max_holding_balance);

    assume $IsValidU64(new_time_period);

    call $AccountLimits_update_limits_definition_$def($tv0, tc_account, limit_address, new_max_inflow, new_max_outflow, new_max_holding_balance, new_time_period);
}


procedure {:inline 1} $AccountLimits_update_limits_definition_$direct_intra($tv0: $TypeValue, tc_account: $Value, limit_address: $Value, new_max_inflow: $Value, new_max_outflow: $Value, new_max_holding_balance: $Value, new_time_period: $Value) returns ()
{
    assume is#$Address(tc_account);

    assume is#$Address(limit_address);

    assume $IsValidU64(new_max_inflow);

    assume $IsValidU64(new_max_outflow);

    assume $IsValidU64(new_max_holding_balance);

    assume $IsValidU64(new_time_period);

    call $AccountLimits_update_limits_definition_$def($tv0, tc_account, limit_address, new_max_inflow, new_max_outflow, new_max_holding_balance, new_time_period);
}


procedure {:inline 1} $AccountLimits_update_limits_definition($tv0: $TypeValue, tc_account: $Value, limit_address: $Value, new_max_inflow: $Value, new_max_outflow: $Value, new_max_holding_balance: $Value, new_time_period: $Value) returns ()
{
    assume is#$Address(tc_account);

    assume is#$Address(limit_address);

    assume $IsValidU64(new_max_inflow);

    assume $IsValidU64(new_max_outflow);

    assume $IsValidU64(new_max_holding_balance);

    assume $IsValidU64(new_time_period);

    call $AccountLimits_update_limits_definition_$def($tv0, tc_account, limit_address, new_max_inflow, new_max_outflow, new_max_holding_balance, new_time_period);
}


procedure {:inline 1} $AccountLimits_update_window_info_$def($tv0: $TypeValue, tc_account: $Value, window_address: $Value, aggregate_balance: $Value, new_limit_address: $Value) returns ()
{
    // declare local variables
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var window: $Mutation; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Mutation; // ReferenceType($IntegerType())
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Mutation; // ReferenceType($AddressType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(3, 10626, 0, tc_account); }
    if (true) { assume $DebugTrackLocal(3, 10626, 1, window_address); }
    if (true) { assume $DebugTrackLocal(3, 10626, 2, aggregate_balance); }
    if (true) { assume $DebugTrackLocal(3, 10626, 3, new_limit_address); }

    // bytecode translation starts here
    // $t7 := move(tc_account)
    call $t7 := $CopyOrMoveValue(tc_account);

    // $t8 := move(window_address)
    call $t8 := $CopyOrMoveValue(window_address);

    // $t9 := move(aggregate_balance)
    call $t9 := $CopyOrMoveValue(aggregate_balance);

    // $t10 := move(new_limit_address)
    call $t10 := $CopyOrMoveValue(new_limit_address);

    // Roles::assert_treasury_compliance($t7)
    call $Roles_assert_treasury_compliance($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 10836, $abort_code);
      goto Abort;
    }

    // window := borrow_global<AccountLimits::Window<#0>>($t8)
    call window := $BorrowGlobal($AccountLimits_Window_$memory, $t8, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 10897, $abort_code);
      goto Abort;
    }

    // unpack_ref(window)

    // $t11 := 0
    $t11 := $Integer(0);

    // $t12 := !=($t9, $t11)
    $t12 := $Boolean(!$IsEqual($t9, $t11));

    // if ($t12) goto L0 else goto L1
    if (b#$Boolean($t12)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t13 := borrow_field<AccountLimits::Window<#0>>.tracked_balance(window)
    call $t13 := $BorrowField(window, $AccountLimits_Window_tracked_balance);

    // unpack_ref($t13)

    // write_ref($t13, $t9)
    call $t13 := $WriteRef($t13, $t9);
    if (true) { assume $DebugTrackLocal(3, 10989, 6, $Dereference(window)); }

    // pack_ref($t13)

    // write_back[Reference(window)]($t13)
    call window := $WritebackToReference($t13, window);

    // goto L2
    goto L2;

    // L2:
L2:

    // $t14 := exists<AccountLimits::LimitsDefinition<#0>>($t10)
    $t14 := $ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t10);

    // $t15 := 0
    $t15 := $Integer(0);

    // $t16 := Errors::not_published($t15)
    call $t16 := $Errors_not_published($t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 11113, $abort_code);
      goto Abort;
    }

    // if ($t14) goto L3 else goto L4
    if (b#$Boolean($t14)) { goto L3; } else { goto L4; }

    // L4:
L4:

    // destroy(window)

    // pack_ref(window)

    // write_back[AccountLimits::Window](window)
    call $AccountLimits_Window_$memory := $WritebackToGlobal($AccountLimits_Window_$memory, window);

    // abort($t16)
    if (true) { assume $DebugTrackAbort(3, 11043, i#$Integer($t16)); }
    $abort_code := i#$Integer($t16);
    goto Abort;

    // L3:
L3:

    // $t17 := borrow_field<AccountLimits::Window<#0>>.limit_address(window)
    call $t17 := $BorrowField(window, $AccountLimits_Window_limit_address);

    // unpack_ref($t17)

    // write_ref($t17, $t10)
    call $t17 := $WriteRef($t17, $t10);
    if (true) { assume $DebugTrackLocal(3, 11157, 6, $Dereference(window)); }

    // pack_ref($t17)

    // write_back[Reference(window)]($t17)
    call window := $WritebackToReference($t17, window);

    // pack_ref(window)

    // write_back[AccountLimits::Window](window)
    call $AccountLimits_Window_$memory := $WritebackToGlobal($AccountLimits_Window_$memory, window);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $AccountLimits_update_window_info_$direct_inter($tv0: $TypeValue, tc_account: $Value, window_address: $Value, aggregate_balance: $Value, new_limit_address: $Value) returns ()
{
    assume is#$Address(tc_account);

    assume is#$Address(window_address);

    assume $IsValidU64(aggregate_balance);

    assume is#$Address(new_limit_address);

    call $AccountLimits_update_window_info_$def($tv0, tc_account, window_address, aggregate_balance, new_limit_address);
}


procedure {:inline 1} $AccountLimits_update_window_info_$direct_intra($tv0: $TypeValue, tc_account: $Value, window_address: $Value, aggregate_balance: $Value, new_limit_address: $Value) returns ()
{
    assume is#$Address(tc_account);

    assume is#$Address(window_address);

    assume $IsValidU64(aggregate_balance);

    assume is#$Address(new_limit_address);

    call $AccountLimits_update_window_info_$def($tv0, tc_account, window_address, aggregate_balance, new_limit_address);
}


procedure {:inline 1} $AccountLimits_update_window_info($tv0: $TypeValue, tc_account: $Value, window_address: $Value, aggregate_balance: $Value, new_limit_address: $Value) returns ()
{
    assume is#$Address(tc_account);

    assume is#$Address(window_address);

    assume $IsValidU64(aggregate_balance);

    assume is#$Address(new_limit_address);

    call $AccountLimits_update_window_info_$def($tv0, tc_account, window_address, aggregate_balance, new_limit_address);
}


procedure {:inline 1} $AccountLimits_update_withdrawal_limits_$def($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value, $AccountLimits_Window_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Mutation; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t11: $Value; // $AccountLimits_Window_type_value($tv0)
    var $t12: $Value; // $BooleanType()
    var $AccountLimits_Window_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(3, 4541, 0, amount); }
    if (true) { assume $DebugTrackLocal(3, 4541, 1, addr); }
    if (true) { assume $DebugTrackLocal(3, 4541, 2, _cap); }
    $AccountLimits_Window_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr) := true];

    // bytecode translation starts here
    // $t5 := move(amount)
    call $t5 := $CopyOrMoveValue(amount);

    // $t6 := move(addr)
    call $t6 := $CopyOrMoveValue(addr);

    // $t7 := exists<AccountLimits::Window<#0>>($t6)
    $t7 := $ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t6);

    // $t8 := 1
    $t8 := $Integer(1);

    // $t9 := Errors::not_published($t8)
    call $t9 := $Errors_not_published($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 4782, $abort_code);
      goto Abort;
    }

    // if ($t7) goto L0 else goto L1
    if (b#$Boolean($t7)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t9)
    if (true) { assume $DebugTrackAbort(3, 4735, i#$Integer($t9)); }
    $abort_code := i#$Integer($t9);
    goto Abort;

    // L0:
L0:

    // $t10 := borrow_global<AccountLimits::Window<#0>>($t6)
    assert $AccountLimits_Window_$SelfDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($t6)];
    call $t10 := $BorrowGlobal($AccountLimits_Window_$memory, $t6, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 4871, $abort_code);
      goto Abort;
    }

    // unpack_ref($t10)

    // $t11 := read_ref($t10)
    call $t11 := $ReadRef($t10);
    assert $AccountLimits_Window_$invariant_holds($t11);

    // ($t12, $t11) := AccountLimits::can_withdraw<#0>($t5, $t11)
    call $t12, $t11 := $AccountLimits_can_withdraw($tv0, $t5, $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 18483, $abort_code);
      goto Abort;
    }

    // write_ref($t10, $t11)
    call $t10 := $WriteRef($t10, $t11);

    // pack_ref($t10)

    // write_back[AccountLimits::Window]($t10)
    call $AccountLimits_Window_$memory := $WritebackToGlobal($AccountLimits_Window_$memory, $t10);

    // return $t12
    $ret0 := $t12;
    if (true) { assume $DebugTrackLocal(3, 4815, 13, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $AccountLimits_update_withdrawal_limits_$direct_inter($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value, $AccountLimits_Window_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
requires $AccountLimits_Window_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr)];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $AccountLimits_spec_withdrawal_limits_ok($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), amount)))));
ensures !$abort_flag ==> (b#$Boolean(if (b#$Boolean($Boolean(b#$Boolean($ret0) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))) then ($Boolean($IsEqual($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_spec_update_outflow($tv0, $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))), amount)))) else ($Boolean(b#$Boolean($Boolean($IsEqual($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))))) || b#$Boolean($Boolean($IsEqual($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))))))));
ensures is#$Boolean($ret0);
modifies $AccountLimits_Window_$memory;
ensures contents#$Memory($AccountLimits_Window_$memory) == old(contents#$Memory($AccountLimits_Window_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr) := contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr)]];
ensures domain#$Memory($AccountLimits_Window_$memory) == old(domain#$Memory($AccountLimits_Window_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr) := domain#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr)]];

procedure {:inline 1} $AccountLimits_update_withdrawal_limits_$direct_intra($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value, $AccountLimits_Window_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
requires $AccountLimits_Window_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr)];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $AccountLimits_spec_withdrawal_limits_ok($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), amount)))));
ensures !$abort_flag ==> (b#$Boolean(if (b#$Boolean($Boolean(b#$Boolean($ret0) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))) then ($Boolean($IsEqual($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_spec_update_outflow($tv0, $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))), amount)))) else ($Boolean(b#$Boolean($Boolean($IsEqual($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))))) || b#$Boolean($Boolean($IsEqual($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))))))));
ensures is#$Boolean($ret0);
modifies $AccountLimits_Window_$memory;
ensures contents#$Memory($AccountLimits_Window_$memory) == old(contents#$Memory($AccountLimits_Window_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr) := contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr)]];
ensures domain#$Memory($AccountLimits_Window_$memory) == old(domain#$Memory($AccountLimits_Window_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr) := domain#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr)]];

procedure {:inline 1} $AccountLimits_update_withdrawal_limits($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value, $AccountLimits_Window_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
requires $AccountLimits_Window_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr)];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_limit_address)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $AccountLimits_spec_withdrawal_limits_ok($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)), amount)))));
ensures !$abort_flag ==> (b#$Boolean(if (b#$Boolean($Boolean(b#$Boolean($ret0) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))) then ($Boolean($IsEqual($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_spec_update_outflow($tv0, $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))), amount)))) else ($Boolean(b#$Boolean($Boolean($IsEqual($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))))) || b#$Boolean($Boolean($IsEqual($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), old($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))))))));
ensures is#$Boolean($ret0);
modifies $AccountLimits_Window_$memory;
ensures contents#$Memory($AccountLimits_Window_$memory) == old(contents#$Memory($AccountLimits_Window_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr) := contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr)]];
ensures domain#$Memory($AccountLimits_Window_$memory) == old(domain#$Memory($AccountLimits_Window_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr) := domain#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr)]];



// ** spec vars of module ChainId



// ** spec funs of module ChainId

function {:inline} $ChainId_spec_get_chain_id($ChainId_ChainId_$memory: $Memory): $Value {
    $SelectField($ResourceValue($ChainId_ChainId_$memory, $EmptyTypeValueArray, $CoreAddresses_$LIBRA_ROOT_ADDRESS()), $ChainId_ChainId_id)
}



// ** structs of module ChainId

const unique $ChainId_ChainId: $TypeName;
const $ChainId_ChainId_id: $FieldName;
axiom $ChainId_ChainId_id == 0;
function $ChainId_ChainId_type_value(): $TypeValue {
    $StructType($ChainId_ChainId, $EmptyTypeValueArray)
}
var $ChainId_ChainId_$memory: $Memory;
var $ChainId_ChainId_$memory_$old: $Memory;
function {:inline} $ChainId_ChainId_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU8($SelectField($this, $ChainId_ChainId_id))
}
function {:inline} $ChainId_ChainId_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $ChainId_ChainId_$is_well_formed($this: $Value): bool {
    $ChainId_ChainId_$is_well_typed($this) && $ChainId_ChainId_$invariant_holds($this)}

procedure {:inline 1} $ChainId_ChainId_pack($file_id: int, $byte_index: int, $var_idx: int, id: $Value) returns ($struct: $Value)
{
    assume $IsValidU8(id);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := id], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $ChainId_ChainId_unpack($struct: $Value) returns (id: $Value)
{
    assume is#$Vector($struct);
    id := $SelectField($struct, $ChainId_ChainId_id);
    assume $IsValidU8(id);
}



// ** functions of module ChainId

procedure {:inline 1} $ChainId_initialize_$def(lr_account: $Value, id: $Value) returns ()
{
    // declare local variables
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $ChainId_ChainId_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(4, 404, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(4, 404, 1, id); }

    // bytecode translation starts here
    // $t4 := move(lr_account)
    call $t4 := $CopyOrMoveValue(lr_account);

    // $t5 := move(id)
    call $t5 := $CopyOrMoveValue(id);

    // LibraTimestamp::assert_genesis()
    call $LibraTimestamp_assert_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(4, 481, $abort_code);
      goto Abort;
    }

    // CoreAddresses::assert_libra_root($t4)
    call $CoreAddresses_assert_libra_root($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(4, 522, $abort_code);
      goto Abort;
    }

    // $t6 := Signer::address_of($t4)
    call $t6 := $Signer_address_of($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(4, 593, $abort_code);
      goto Abort;
    }

    // $t7 := exists<ChainId::ChainId>($t6)
    $t7 := $ResourceExists($ChainId_ChainId_$memory, $EmptyTypeValueArray, $t6);

    // $t8 := !($t7)
    call $t8 := $Not($t7);

    // $t9 := 0
    $t9 := $Integer(0);

    // $t10 := Errors::already_published($t9)
    call $t10 := $Errors_already_published($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(4, 626, $abort_code);
      goto Abort;
    }

    // if ($t8) goto L0 else goto L1
    if (b#$Boolean($t8)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t4)

    // abort($t10)
    if (true) { assume $DebugTrackAbort(4, 561, i#$Integer($t10)); }
    $abort_code := i#$Integer($t10);
    goto Abort;

    // L0:
L0:

    // $t11 := pack ChainId::ChainId($t5)
    call $t11 := $ChainId_ChainId_pack(0, 0, 0, $t5);

    // move_to<ChainId::ChainId>($t11, $t4)
    call $ChainId_ChainId_$memory := $MoveTo($ChainId_ChainId_$memory, $EmptyTypeValueArray, $t11, $t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(4, 665, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $ChainId_initialize_$direct_inter(lr_account: $Value, id: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume $IsValidU8(id);

    call $ChainId_initialize_$def(lr_account, id);
}


procedure {:inline 1} $ChainId_initialize_$direct_intra(lr_account: $Value, id: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume $IsValidU8(id);

    call $ChainId_initialize_$def(lr_account, id);
}


procedure {:inline 1} $ChainId_initialize(lr_account: $Value, id: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume $IsValidU8(id);

    call $ChainId_initialize_$def(lr_account, id);
}


procedure {:inline 1} $ChainId_get_$def() returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $ChainId_ChainId_type_value()
    var $t2: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // LibraTimestamp::assert_operating()
    call $LibraTimestamp_assert_operating();
    if ($abort_flag) {
      assume $DebugTrackAbort(4, 827, $abort_code);
      goto Abort;
    }

    // $t0 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t0 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t1 := get_global<ChainId::ChainId>($t0)
    call $t1 := $GetGlobal($ChainId_ChainId_$memory, $t0, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(4, 855, $abort_code);
      goto Abort;
    }

    // $t2 := get_field<ChainId::ChainId>.id($t1)
    call $t2 := $GetFieldFromValue($t1, $ChainId_ChainId_id);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(4, 855, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $ChainId_get_$direct_inter() returns ($ret0: $Value)
{
    call $ret0 := $ChainId_get_$def();
}


procedure {:inline 1} $ChainId_get_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $ChainId_get_$def();
}


procedure {:inline 1} $ChainId_get() returns ($ret0: $Value)
{
    call $ret0 := $ChainId_get_$def();
}




// ** spec vars of module LibraConfig



// ** spec funs of module LibraConfig

function {:inline} $LibraConfig_$get($LibraConfig_LibraConfig_$memory: $Memory, $tv0: $TypeValue): $Value {
    (var addr := $CoreAddresses_$LIBRA_ROOT_ADDRESS(); $SelectField($ResourceValue($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $LibraConfig_LibraConfig_payload))
}

function {:inline} $LibraConfig_spec_reconfigure_omitted($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory): $Value {
    $Boolean(b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory)) || b#$Boolean($Boolean($IsEqual($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory), $Integer(0)))))
}

function {:inline} $LibraConfig_spec_has_config($LibraConfig_Configuration_$memory: $Memory): $Value {
    $ResourceExists($LibraConfig_Configuration_$memory, $EmptyTypeValueArray, $CoreAddresses_$LIBRA_ROOT_ADDRESS())
}

function {:inline} $LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory: $Memory, $tv0: $TypeValue): $Value {
    $ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS())
}

function {:inline} $LibraConfig_spec_get_config($LibraConfig_LibraConfig_$memory: $Memory, $tv0: $TypeValue): $Value {
    $SelectField($ResourceValue($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()), $LibraConfig_LibraConfig_payload)
}

function {:inline} $LibraConfig_config$13($LibraConfig_Configuration_$memory: $Memory): $Value {
    $ResourceValue($LibraConfig_Configuration_$memory, $EmptyTypeValueArray, $CoreAddresses_$LIBRA_ROOT_ADDRESS())
}

function {:inline} $LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory): $Value {
    $LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)
}

function {:inline} $LibraConfig_config$15($LibraConfig_Configuration_$memory: $Memory): $Value {
    $ResourceValue($LibraConfig_Configuration_$memory, $EmptyTypeValueArray, $CoreAddresses_$LIBRA_ROOT_ADDRESS())
}

function {:inline} $LibraConfig_current_time$16($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory): $Value {
    $LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)
}

function {:inline} $LibraConfig_new_config$17($LibraConfig_Configuration_$memory: $Memory): $Value {
    $ResourceValue($LibraConfig_Configuration_$memory, $EmptyTypeValueArray, $CoreAddresses_$LIBRA_ROOT_ADDRESS())
}

function {:inline} $LibraConfig_config$18($LibraConfig_Configuration_$memory: $Memory): $Value {
    $ResourceValue($LibraConfig_Configuration_$memory, $EmptyTypeValueArray, $CoreAddresses_$LIBRA_ROOT_ADDRESS())
}

function {:inline} $LibraConfig_now$19($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory): $Value {
    $LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)
}

function {:inline} $LibraConfig_epoch$20($LibraConfig_Configuration_$memory: $Memory): $Value {
    $SelectField($LibraConfig_config$18($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)
}



// ** structs of module LibraConfig

const unique $LibraConfig_LibraConfig: $TypeName;
const $LibraConfig_LibraConfig_payload: $FieldName;
axiom $LibraConfig_LibraConfig_payload == 0;
function $LibraConfig_LibraConfig_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($LibraConfig_LibraConfig, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1))
}
var $LibraConfig_LibraConfig_$memory: $Memory;
var $LibraConfig_LibraConfig_$memory_$old: $Memory;
function {:inline} $LibraConfig_LibraConfig_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
}
function {:inline} $LibraConfig_LibraConfig_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $LibraConfig_LibraConfig_$is_well_formed($this: $Value): bool {
    $LibraConfig_LibraConfig_$is_well_typed($this) && $LibraConfig_LibraConfig_$invariant_holds($this)}

procedure {:inline 1} $LibraConfig_LibraConfig_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, payload: $Value) returns ($struct: $Value)
{
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := payload], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraConfig_LibraConfig_unpack($tv0: $TypeValue, $struct: $Value) returns (payload: $Value)
{
    assume is#$Vector($struct);
    payload := $SelectField($struct, $LibraConfig_LibraConfig_payload);
}

const unique $LibraConfig_Configuration: $TypeName;
const $LibraConfig_Configuration_epoch: $FieldName;
axiom $LibraConfig_Configuration_epoch == 0;
const $LibraConfig_Configuration_last_reconfiguration_time: $FieldName;
axiom $LibraConfig_Configuration_last_reconfiguration_time == 1;
const $LibraConfig_Configuration_events: $FieldName;
axiom $LibraConfig_Configuration_events == 2;
function $LibraConfig_Configuration_type_value(): $TypeValue {
    $StructType($LibraConfig_Configuration, $EmptyTypeValueArray)
}
var $LibraConfig_Configuration_$memory: $Memory;
var $LibraConfig_Configuration_$memory_$old: $Memory;
function {:inline} $LibraConfig_Configuration_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 3
      && $IsValidU64($SelectField($this, $LibraConfig_Configuration_epoch))
      && $IsValidU64($SelectField($this, $LibraConfig_Configuration_last_reconfiguration_time))
      && $Event_EventHandle_$is_well_typed($SelectField($this, $LibraConfig_Configuration_events))
}
function {:inline} $LibraConfig_Configuration_$invariant_holds($this: $Value): bool {
    $Event_EventHandle_$invariant_holds($SelectField($this, $LibraConfig_Configuration_events))
}

function {:inline} $LibraConfig_Configuration_$is_well_formed($this: $Value): bool {
    $LibraConfig_Configuration_$is_well_typed($this) && $LibraConfig_Configuration_$invariant_holds($this)}

procedure {:inline 1} $LibraConfig_Configuration_pack($file_id: int, $byte_index: int, $var_idx: int, epoch: $Value, last_reconfiguration_time: $Value, events: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(epoch);
    assume $IsValidU64(last_reconfiguration_time);
    assume $Event_EventHandle_$is_well_formed(events);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := epoch][1 := last_reconfiguration_time][2 := events], 3));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraConfig_Configuration_unpack($struct: $Value) returns (epoch: $Value, last_reconfiguration_time: $Value, events: $Value)
{
    assume is#$Vector($struct);
    epoch := $SelectField($struct, $LibraConfig_Configuration_epoch);
    assume $IsValidU64(epoch);
    last_reconfiguration_time := $SelectField($struct, $LibraConfig_Configuration_last_reconfiguration_time);
    assume $IsValidU64(last_reconfiguration_time);
    events := $SelectField($struct, $LibraConfig_Configuration_events);
    assume $Event_EventHandle_$is_well_formed(events);
}

const unique $LibraConfig_ModifyConfigCapability: $TypeName;
const $LibraConfig_ModifyConfigCapability_dummy_field: $FieldName;
axiom $LibraConfig_ModifyConfigCapability_dummy_field == 0;
function $LibraConfig_ModifyConfigCapability_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($LibraConfig_ModifyConfigCapability, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1))
}
var $LibraConfig_ModifyConfigCapability_$memory: $Memory;
var $LibraConfig_ModifyConfigCapability_$memory_$old: $Memory;
function {:inline} $LibraConfig_ModifyConfigCapability_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $LibraConfig_ModifyConfigCapability_dummy_field))
}
function {:inline} $LibraConfig_ModifyConfigCapability_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $LibraConfig_ModifyConfigCapability_$is_well_formed($this: $Value): bool {
    $LibraConfig_ModifyConfigCapability_$is_well_typed($this) && $LibraConfig_ModifyConfigCapability_$invariant_holds($this)}

procedure {:inline 1} $LibraConfig_ModifyConfigCapability_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraConfig_ModifyConfigCapability_unpack($tv0: $TypeValue, $struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $LibraConfig_ModifyConfigCapability_dummy_field);
    assume is#$Boolean(dummy_field);
}

const unique $LibraConfig_NewEpochEvent: $TypeName;
const $LibraConfig_NewEpochEvent_epoch: $FieldName;
axiom $LibraConfig_NewEpochEvent_epoch == 0;
function $LibraConfig_NewEpochEvent_type_value(): $TypeValue {
    $StructType($LibraConfig_NewEpochEvent, $EmptyTypeValueArray)
}
var $LibraConfig_NewEpochEvent_$memory: $Memory;
var $LibraConfig_NewEpochEvent_$memory_$old: $Memory;
function {:inline} $LibraConfig_NewEpochEvent_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $LibraConfig_NewEpochEvent_epoch))
}
function {:inline} $LibraConfig_NewEpochEvent_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $LibraConfig_NewEpochEvent_$is_well_formed($this: $Value): bool {
    $LibraConfig_NewEpochEvent_$is_well_typed($this) && $LibraConfig_NewEpochEvent_$invariant_holds($this)}

procedure {:inline 1} $LibraConfig_NewEpochEvent_pack($file_id: int, $byte_index: int, $var_idx: int, epoch: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(epoch);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := epoch], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraConfig_NewEpochEvent_unpack($struct: $Value) returns (epoch: $Value)
{
    assume is#$Vector($struct);
    epoch := $SelectField($struct, $LibraConfig_NewEpochEvent_epoch);
    assume $IsValidU64(epoch);
}



// ** functions of module LibraConfig

procedure {:inline 1} $LibraConfig_initialize_$def(lr_account: $Value, $LibraConfig_Configuration_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $Event_EventHandle_type_value($LibraConfig_NewEpochEvent_type_value())
    var $t12: $Value; // $LibraConfig_Configuration_type_value()
    var $LibraConfig_Configuration_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(17, 1324, 0, lr_account); }
    $LibraConfig_Configuration_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := true];

    // bytecode translation starts here
    // $t3 := move(lr_account)
    call $t3 := $CopyOrMoveValue(lr_account);

    // LibraTimestamp::assert_genesis()
    call $LibraTimestamp_assert_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 1408, $abort_code);
      goto Abort;
    }

    // CoreAddresses::assert_libra_root($t3)
    call $CoreAddresses_assert_libra_root($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 1449, $abort_code);
      goto Abort;
    }

    // $t4 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t4 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t5 := exists<LibraConfig::Configuration>($t4)
    $t5 := $ResourceExists($LibraConfig_Configuration_$memory, $EmptyTypeValueArray, $t4);

    // $t6 := !($t5)
    call $t6 := $Not($t5);

    // $t7 := 0
    $t7 := $Integer(0);

    // $t8 := Errors::already_published($t7)
    call $t8 := $Errors_already_published($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 1564, $abort_code);
      goto Abort;
    }

    // if ($t6) goto L0 else goto L1
    if (b#$Boolean($t6)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t3)

    // abort($t8)
    if (true) { assume $DebugTrackAbort(17, 1488, i#$Integer($t8)); }
    $abort_code := i#$Integer($t8);
    goto Abort;

    // L0:
L0:

    // $t9 := 0
    $t9 := $Integer(0);

    // $t10 := 0
    $t10 := $Integer(0);

    // $t11 := Event::new_event_handle<LibraConfig::NewEpochEvent>($t3)
    call $t11 := $Event_new_event_handle($LibraConfig_NewEpochEvent_type_value(), $t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 1787, $abort_code);
      goto Abort;
    }

    // $t12 := pack LibraConfig::Configuration($t9, $t10, $t11)
    call $t12 := $LibraConfig_Configuration_pack(0, 0, 0, $t9, $t10, $t11);

    // move_to<LibraConfig::Configuration>($t12, $t3)
    assert $LibraConfig_Configuration_$SelfDomain[$EmptyTypeValueArray, a#$Address($Signer_spec_address_of($t3))];
    call $LibraConfig_Configuration_$memory := $MoveTo($LibraConfig_Configuration_$memory, $EmptyTypeValueArray, $t12, $t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 1608, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraConfig_initialize_$direct_inter(lr_account: $Value, $LibraConfig_Configuration_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraConfig_Configuration_$CallerDomain[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
ensures b#$Boolean(old($LibraConfig_spec_has_config($LibraConfig_Configuration_$memory))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($LibraConfig_spec_has_config($LibraConfig_Configuration_$memory)))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($LibraConfig_spec_has_config($LibraConfig_Configuration_$memory))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));
ensures !$abort_flag ==> (b#$Boolean($LibraConfig_spec_has_config($LibraConfig_Configuration_$memory)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($LibraConfig_new_config$17($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch), $Integer(0)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($LibraConfig_new_config$17($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time), $Integer(0)))));
modifies $LibraConfig_Configuration_$memory;
ensures contents#$Memory($LibraConfig_Configuration_$memory) == old(contents#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_Configuration_$memory) == old(domain#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];

procedure {:inline 1} $LibraConfig_initialize_$direct_intra(lr_account: $Value, $LibraConfig_Configuration_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraConfig_Configuration_$CallerDomain[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
ensures b#$Boolean(old($LibraConfig_spec_has_config($LibraConfig_Configuration_$memory))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($LibraConfig_spec_has_config($LibraConfig_Configuration_$memory)))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($LibraConfig_spec_has_config($LibraConfig_Configuration_$memory))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));
ensures !$abort_flag ==> (b#$Boolean($LibraConfig_spec_has_config($LibraConfig_Configuration_$memory)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($LibraConfig_new_config$17($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch), $Integer(0)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($LibraConfig_new_config$17($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time), $Integer(0)))));
modifies $LibraConfig_Configuration_$memory;
ensures contents#$Memory($LibraConfig_Configuration_$memory) == old(contents#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_Configuration_$memory) == old(domain#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];

procedure {:inline 1} $LibraConfig_initialize(lr_account: $Value, $LibraConfig_Configuration_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraConfig_Configuration_$CallerDomain[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
ensures b#$Boolean(old($LibraConfig_spec_has_config($LibraConfig_Configuration_$memory))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($LibraConfig_spec_has_config($LibraConfig_Configuration_$memory)))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($LibraConfig_spec_has_config($LibraConfig_Configuration_$memory))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));
ensures !$abort_flag ==> (b#$Boolean($LibraConfig_spec_has_config($LibraConfig_Configuration_$memory)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($LibraConfig_new_config$17($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch), $Integer(0)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($LibraConfig_new_config$17($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time), $Integer(0)))));
modifies $LibraConfig_Configuration_$memory;
ensures contents#$Memory($LibraConfig_Configuration_$memory) == old(contents#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_Configuration_$memory) == old(domain#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];

procedure {:inline 1} $LibraConfig_get_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
    // declare local variables
    var addr: $Value; // $AddressType()
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $LibraConfig_LibraConfig_type_value($tv0)
    var $t7: $Value; // $tv0

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // addr := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call addr := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t3 := exists<LibraConfig::LibraConfig<#0>>(addr)
    $t3 := $ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr);

    // $t4 := 1
    $t4 := $Integer(1);

    // $t5 := Errors::not_published($t4)
    call $t5 := $Errors_not_published($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 2760, $abort_code);
      goto Abort;
    }

    // if ($t3) goto L0 else goto L1
    if (b#$Boolean($t3)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t5)
    if (true) { assume $DebugTrackAbort(17, 2710, i#$Integer($t5)); }
    $abort_code := i#$Integer($t5);
    goto Abort;

    // L0:
L0:

    // $t6 := get_global<LibraConfig::LibraConfig<#0>>(addr)
    call $t6 := $GetGlobal($LibraConfig_LibraConfig_$memory, addr, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 2801, $abort_code);
      goto Abort;
    }

    // $t7 := get_field<LibraConfig::LibraConfig<#0>>.payload($t6)
    call $t7 := $GetFieldFromValue($t6, $LibraConfig_LibraConfig_payload);

    // return $t7
    $ret0 := $t7;
    if (true) { assume $DebugTrackLocal(17, 2799, 8, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraConfig_get_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $LibraConfig_$get($LibraConfig_LibraConfig_$memory, $tv0)))));

procedure {:inline 1} $LibraConfig_get_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $LibraConfig_$get($LibraConfig_LibraConfig_$memory, $tv0)))));

procedure {:inline 1} $LibraConfig_get($tv0: $TypeValue) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $LibraConfig_$get($LibraConfig_LibraConfig_$memory, $tv0)))));

procedure {:inline 1} $LibraConfig_emit_genesis_reconfiguration_event_$def() returns ()
{
    // declare local variables
    var config_ref: $Mutation; // ReferenceType($LibraConfig_Configuration_type_value())
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var tmp#$5: $Value; // $BooleanType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Mutation; // ReferenceType($IntegerType())
    var $t21: $Mutation; // ReferenceType($Event_EventHandle_type_value($LibraConfig_NewEpochEvent_type_value()))
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $LibraConfig_NewEpochEvent_type_value()
    var $t24: $Value; // $Event_EventHandle_type_value($LibraConfig_NewEpochEvent_type_value())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t6 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t6 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t7 := exists<LibraConfig::Configuration>($t6)
    $t7 := $ResourceExists($LibraConfig_Configuration_$memory, $EmptyTypeValueArray, $t6);

    // $t8 := 0
    $t8 := $Integer(0);

    // $t9 := Errors::not_published($t8)
    call $t9 := $Errors_not_published($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 11863, $abort_code);
      goto Abort;
    }

    // if ($t7) goto L0 else goto L1
    if (b#$Boolean($t7)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t9)
    if (true) { assume $DebugTrackAbort(17, 11788, i#$Integer($t9)); }
    $abort_code := i#$Integer($t9);
    goto Abort;

    // L0:
L0:

    // $t10 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t10 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // config_ref := borrow_global<LibraConfig::Configuration>($t10)
    call config_ref := $BorrowGlobal($LibraConfig_Configuration_$memory, $t10, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 11920, $abort_code);
      goto Abort;
    }

    // unpack_ref(config_ref)

    // $t11 := get_field<LibraConfig::Configuration>.epoch(config_ref)
    call $t11 := $GetFieldFromReference(config_ref, $LibraConfig_Configuration_epoch);

    // $t12 := 0
    $t12 := $Integer(0);

    // $t13 := ==($t11, $t12)
    $t13 := $Boolean($IsEqual($t11, $t12));

    // if ($t13) goto L2 else goto L3
    if (b#$Boolean($t13)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // goto L4
    goto L4;

    // L2:
L2:

    // $t14 := get_field<LibraConfig::Configuration>.last_reconfiguration_time(config_ref)
    call $t14 := $GetFieldFromReference(config_ref, $LibraConfig_Configuration_last_reconfiguration_time);

    // $t15 := 0
    $t15 := $Integer(0);

    // tmp#$5 := ==($t14, $t15)
    tmp#$5 := $Boolean($IsEqual($t14, $t15));
    if (true) { assume $DebugTrackLocal(17, 12068, 5, tmp#$5); }

    // goto L5
    goto L5;

    // L4:
L4:

    // $t16 := false
    $t16 := $Boolean(false);

    // tmp#$5 := $t16
    call tmp#$5 := $CopyOrMoveValue($t16);
    if (true) { assume $DebugTrackLocal(17, 12006, 5, tmp#$5); }

    // goto L5
    goto L5;

    // L5:
L5:

    // $t17 := 0
    $t17 := $Integer(0);

    // $t18 := Errors::invalid_state($t17)
    call $t18 := $Errors_invalid_state($t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 12082, $abort_code);
      goto Abort;
    }

    // if (tmp#$5) goto L6 else goto L7
    if (b#$Boolean(tmp#$5)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // destroy(config_ref)

    // pack_ref(config_ref)

    // abort($t18)
    if (true) { assume $DebugTrackAbort(17, 11999, i#$Integer($t18)); }
    $abort_code := i#$Integer($t18);
    goto Abort;

    // L6:
L6:

    // $t19 := 1
    $t19 := $Integer(1);

    // $t20 := borrow_field<LibraConfig::Configuration>.epoch(config_ref)
    call $t20 := $BorrowField(config_ref, $LibraConfig_Configuration_epoch);

    // unpack_ref($t20)

    // write_ref($t20, $t19)
    call $t20 := $WriteRef($t20, $t19);
    if (true) { assume $DebugTrackLocal(17, 12122, 0, $Dereference(config_ref)); }

    // pack_ref($t20)

    // write_back[Reference(config_ref)]($t20)
    call config_ref := $WritebackToReference($t20, config_ref);

    // $t21 := borrow_field<LibraConfig::Configuration>.events(config_ref)
    call $t21 := $BorrowField(config_ref, $LibraConfig_Configuration_events);

    // unpack_ref($t21)

    // $t22 := get_field<LibraConfig::Configuration>.epoch(config_ref)
    call $t22 := $GetFieldFromReference(config_ref, $LibraConfig_Configuration_epoch);

    // $t23 := pack LibraConfig::NewEpochEvent($t22)
    call $t23 := $LibraConfig_NewEpochEvent_pack(0, 0, 0, $t22);

    // $t24 := read_ref($t21)
    call $t24 := $ReadRef($t21);
    assert $Event_EventHandle_$invariant_holds($t24);

    // $t24 := Event::emit_event<LibraConfig::NewEpochEvent>($t24, $t23)
    call $t24 := $Event_emit_event($LibraConfig_NewEpochEvent_type_value(), $t24, $t23);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 12160, $abort_code);
      goto Abort;
    }

    // write_ref($t21, $t24)
    call $t21 := $WriteRef($t21, $t24);
    if (true) { assume $DebugTrackLocal(17, 12160, 0, $Dereference(config_ref)); }

    // pack_ref($t21)

    // write_back[Reference(config_ref)]($t21)
    call config_ref := $WritebackToReference($t21, config_ref);

    // pack_ref(config_ref)

    // write_back[LibraConfig::Configuration](config_ref)
    call $LibraConfig_Configuration_$memory := $WritebackToGlobal($LibraConfig_Configuration_$memory, config_ref);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraConfig_emit_genesis_reconfiguration_event_$direct_intra() returns ()
{
    call $LibraConfig_emit_genesis_reconfiguration_event_$def();
}


procedure {:inline 1} $LibraConfig_emit_genesis_reconfiguration_event() returns ()
{
    call $LibraConfig_emit_genesis_reconfiguration_event_$def();
}


procedure {:inline 1} $LibraConfig_publish_new_config_$def($tv0: $TypeValue, lr_account: $Value, payload: $Value, $LibraConfig_LibraConfig_$CallerDomain: [$TypeValueArray, int]bool, $LibraConfig_ModifyConfigCapability_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var capability: $Value; // $LibraConfig_ModifyConfigCapability_type_value($tv0)
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $tv0
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $LibraConfig_LibraConfig_$SelfDomain: [$TypeValueArray, int]bool;
    var $LibraConfig_ModifyConfigCapability_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(17, 6916, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(17, 6916, 1, payload); }
    $LibraConfig_LibraConfig_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := true];
    $LibraConfig_ModifyConfigCapability_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := true];

    // bytecode translation starts here
    // $t5 := move(lr_account)
    call $t5 := $CopyOrMoveValue(lr_account);

    // $t6 := move(payload)
    call $t6 := $CopyOrMoveValue(payload);

    // capability := LibraConfig::publish_new_config_and_get_capability<#0>($t5, $t6)
    call capability := $LibraConfig_publish_new_config_and_get_capability($tv0, $t5, $t6, $LibraConfig_LibraConfig_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 5677, $abort_code);
      goto Abort;
    }

    // $t7 := Signer::address_of($t5)
    call $t7 := $Signer_address_of($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 7195, $abort_code);
      goto Abort;
    }

    // $t8 := exists<LibraConfig::ModifyConfigCapability<#0>>($t7)
    $t8 := $ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t7);

    // $t9 := !($t8)
    call $t9 := $Not($t8);

    // $t10 := 2
    $t10 := $Integer(2);

    // $t11 := Errors::already_published($t10)
    call $t11 := $Errors_already_published($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 7240, $abort_code);
      goto Abort;
    }

    // if ($t9) goto L0 else goto L1
    if (b#$Boolean($t9)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t5)

    // abort($t11)
    if (true) { assume $DebugTrackAbort(17, 7127, i#$Integer($t11)); }
    $abort_code := i#$Integer($t11);
    goto Abort;

    // L0:
L0:

    // move_to<LibraConfig::ModifyConfigCapability<#0>>(capability, $t5)
    assert $LibraConfig_ModifyConfigCapability_$SelfDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($Signer_spec_address_of($t5))];
    call $LibraConfig_ModifyConfigCapability_$memory := $MoveTo($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), capability, $t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 7297, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraConfig_publish_new_config_$direct_inter($tv0: $TypeValue, lr_account: $Value, payload: $Value, $LibraConfig_LibraConfig_$CallerDomain: [$TypeValueArray, int]bool, $LibraConfig_ModifyConfigCapability_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraConfig_LibraConfig_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
requires $LibraConfig_ModifyConfigCapability_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
ensures b#$Boolean(old($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0))) ==> $abort_flag;
ensures b#$Boolean(old($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(lr_account)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0)))
    || b#$Boolean(old($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(lr_account))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0))))
    ||(b#$Boolean(old($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(lr_account)))))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(lr_account))));
ensures !$abort_flag ==> (b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraConfig_$get($LibraConfig_LibraConfig_$memory, $tv0), payload))));
modifies $LibraConfig_LibraConfig_$memory;
ensures contents#$Memory($LibraConfig_LibraConfig_$memory) == old(contents#$Memory($LibraConfig_LibraConfig_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_LibraConfig_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_LibraConfig_$memory) == old(domain#$Memory($LibraConfig_LibraConfig_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_LibraConfig_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
modifies $LibraConfig_ModifyConfigCapability_$memory;
ensures contents#$Memory($LibraConfig_ModifyConfigCapability_$memory) == old(contents#$Memory($LibraConfig_ModifyConfigCapability_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_ModifyConfigCapability_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_ModifyConfigCapability_$memory) == old(domain#$Memory($LibraConfig_ModifyConfigCapability_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_ModifyConfigCapability_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];

procedure {:inline 1} $LibraConfig_publish_new_config_$direct_intra($tv0: $TypeValue, lr_account: $Value, payload: $Value, $LibraConfig_LibraConfig_$CallerDomain: [$TypeValueArray, int]bool, $LibraConfig_ModifyConfigCapability_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraConfig_LibraConfig_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
requires $LibraConfig_ModifyConfigCapability_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
ensures b#$Boolean(old($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0))) ==> $abort_flag;
ensures b#$Boolean(old($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(lr_account)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0)))
    || b#$Boolean(old($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(lr_account))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0))))
    ||(b#$Boolean(old($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(lr_account)))))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(lr_account))));
ensures !$abort_flag ==> (b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraConfig_$get($LibraConfig_LibraConfig_$memory, $tv0), payload))));
modifies $LibraConfig_LibraConfig_$memory;
ensures contents#$Memory($LibraConfig_LibraConfig_$memory) == old(contents#$Memory($LibraConfig_LibraConfig_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_LibraConfig_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_LibraConfig_$memory) == old(domain#$Memory($LibraConfig_LibraConfig_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_LibraConfig_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
modifies $LibraConfig_ModifyConfigCapability_$memory;
ensures contents#$Memory($LibraConfig_ModifyConfigCapability_$memory) == old(contents#$Memory($LibraConfig_ModifyConfigCapability_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_ModifyConfigCapability_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_ModifyConfigCapability_$memory) == old(domain#$Memory($LibraConfig_ModifyConfigCapability_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_ModifyConfigCapability_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];

procedure {:inline 1} $LibraConfig_publish_new_config($tv0: $TypeValue, lr_account: $Value, payload: $Value, $LibraConfig_LibraConfig_$CallerDomain: [$TypeValueArray, int]bool, $LibraConfig_ModifyConfigCapability_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraConfig_LibraConfig_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
requires $LibraConfig_ModifyConfigCapability_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
ensures b#$Boolean(old($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0))) ==> $abort_flag;
ensures b#$Boolean(old($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(lr_account)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0)))
    || b#$Boolean(old($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(lr_account))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))));
ensures $abort_flag ==> ((b#$Boolean(old($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0))))
    ||(b#$Boolean(old($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(lr_account)))))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(lr_account))));
ensures !$abort_flag ==> (b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraConfig_$get($LibraConfig_LibraConfig_$memory, $tv0), payload))));
modifies $LibraConfig_LibraConfig_$memory;
ensures contents#$Memory($LibraConfig_LibraConfig_$memory) == old(contents#$Memory($LibraConfig_LibraConfig_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_LibraConfig_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_LibraConfig_$memory) == old(domain#$Memory($LibraConfig_LibraConfig_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_LibraConfig_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
modifies $LibraConfig_ModifyConfigCapability_$memory;
ensures contents#$Memory($LibraConfig_ModifyConfigCapability_$memory) == old(contents#$Memory($LibraConfig_ModifyConfigCapability_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_ModifyConfigCapability_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_ModifyConfigCapability_$memory) == old(domain#$Memory($LibraConfig_ModifyConfigCapability_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_ModifyConfigCapability_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];

procedure {:inline 1} $LibraConfig_publish_new_config_and_get_capability_$def($tv0: $TypeValue, lr_account: $Value, payload: $Value, $LibraConfig_LibraConfig_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $tv0
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $LibraConfig_LibraConfig_type_value($tv0)
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $LibraConfig_ModifyConfigCapability_type_value($tv0)
    var $LibraConfig_LibraConfig_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(17, 5666, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(17, 5666, 1, payload); }
    $LibraConfig_LibraConfig_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := true];

    // bytecode translation starts here
    // $t4 := move(lr_account)
    call $t4 := $CopyOrMoveValue(lr_account);

    // $t5 := move(payload)
    call $t5 := $CopyOrMoveValue(payload);

    // LibraTimestamp::assert_genesis()
    call $LibraTimestamp_assert_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 5852, $abort_code);
      goto Abort;
    }

    // Roles::assert_libra_root($t4)
    call $Roles_assert_libra_root($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 5885, $abort_code);
      goto Abort;
    }

    // $t6 := Signer::address_of($t4)
    call $t6 := $Signer_address_of($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 5981, $abort_code);
      goto Abort;
    }

    // $t7 := exists<LibraConfig::LibraConfig<#0>>($t6)
    $t7 := $ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t6);

    // $t8 := !($t7)
    call $t8 := $Not($t7);

    // $t9 := 1
    $t9 := $Integer(1);

    // $t10 := Errors::already_published($t9)
    call $t10 := $Errors_already_published($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 6026, $abort_code);
      goto Abort;
    }

    // if ($t8) goto L0 else goto L1
    if (b#$Boolean($t8)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t4)

    // abort($t10)
    if (true) { assume $DebugTrackAbort(17, 5924, i#$Integer($t10)); }
    $abort_code := i#$Integer($t10);
    goto Abort;

    // L0:
L0:

    // $t11 := pack LibraConfig::LibraConfig<#0>($t5)
    call $t11 := $LibraConfig_LibraConfig_pack(0, 0, 0, $tv0, $t5);

    // move_to<LibraConfig::LibraConfig<#0>>($t11, $t4)
    assert $LibraConfig_LibraConfig_$SelfDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($Signer_spec_address_of($t4))];
    call $LibraConfig_LibraConfig_$memory := $MoveTo($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t11, $t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 6078, $abort_code);
      goto Abort;
    }

    // $t12 := false
    $t12 := $Boolean(false);

    // $t13 := pack LibraConfig::ModifyConfigCapability<#0>($t12)
    call $t13 := $LibraConfig_ModifyConfigCapability_pack(0, 0, 0, $tv0, $t12);

    // return $t13
    $ret0 := $t13;
    if (true) { assume $DebugTrackLocal(17, 6132, 14, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraConfig_publish_new_config_and_get_capability_$direct_inter($tv0: $TypeValue, lr_account: $Value, payload: $Value, $LibraConfig_LibraConfig_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
requires $LibraConfig_LibraConfig_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))
    || b#$Boolean(old($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))) &&
       $abort_code == i#$Integer($Integer(6))));
ensures !$abort_flag ==> (b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraConfig_$get($LibraConfig_LibraConfig_$memory, $tv0), payload))));
ensures $LibraConfig_ModifyConfigCapability_$is_well_formed($ret0);
modifies $LibraConfig_LibraConfig_$memory;
ensures contents#$Memory($LibraConfig_LibraConfig_$memory) == old(contents#$Memory($LibraConfig_LibraConfig_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_LibraConfig_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_LibraConfig_$memory) == old(domain#$Memory($LibraConfig_LibraConfig_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_LibraConfig_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];

procedure {:inline 1} $LibraConfig_publish_new_config_and_get_capability_$direct_intra($tv0: $TypeValue, lr_account: $Value, payload: $Value, $LibraConfig_LibraConfig_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
requires $LibraConfig_LibraConfig_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))
    || b#$Boolean(old($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))) &&
       $abort_code == i#$Integer($Integer(6))));
ensures !$abort_flag ==> (b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraConfig_$get($LibraConfig_LibraConfig_$memory, $tv0), payload))));
ensures $LibraConfig_ModifyConfigCapability_$is_well_formed($ret0);
modifies $LibraConfig_LibraConfig_$memory;
ensures contents#$Memory($LibraConfig_LibraConfig_$memory) == old(contents#$Memory($LibraConfig_LibraConfig_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_LibraConfig_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_LibraConfig_$memory) == old(domain#$Memory($LibraConfig_LibraConfig_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_LibraConfig_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];

procedure {:inline 1} $LibraConfig_publish_new_config_and_get_capability($tv0: $TypeValue, lr_account: $Value, payload: $Value, $LibraConfig_LibraConfig_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
requires $LibraConfig_LibraConfig_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))
    || b#$Boolean(old($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))) &&
       $abort_code == i#$Integer($Integer(6))));
ensures !$abort_flag ==> (b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraConfig_$get($LibraConfig_LibraConfig_$memory, $tv0), payload))));
ensures $LibraConfig_ModifyConfigCapability_$is_well_formed($ret0);
modifies $LibraConfig_LibraConfig_$memory;
ensures contents#$Memory($LibraConfig_LibraConfig_$memory) == old(contents#$Memory($LibraConfig_LibraConfig_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_LibraConfig_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_LibraConfig_$memory) == old(domain#$Memory($LibraConfig_LibraConfig_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_LibraConfig_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];

procedure {:inline 1} $LibraConfig_reconfigure_$def(lr_account: $Value, $LibraConfig_Configuration_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $LibraConfig_Configuration_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(17, 8379, 0, lr_account); }
    $LibraConfig_Configuration_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := true];

    // bytecode translation starts here
    // $t1 := move(lr_account)
    call $t1 := $CopyOrMoveValue(lr_account);

    // Roles::assert_libra_root($t1)
    call $Roles_assert_libra_root($t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 8478, $abort_code);
      goto Abort;
    }

    // LibraConfig::reconfigure_()
    call $LibraConfig_reconfigure_($LibraConfig_Configuration_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 8784, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraConfig_reconfigure_$direct_inter(lr_account: $Value, $LibraConfig_Configuration_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraConfig_Configuration_$CallerDomain[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))) &&
       $abort_code == i#$Integer($Integer(1))));
modifies $LibraConfig_Configuration_$memory;
ensures contents#$Memory($LibraConfig_Configuration_$memory) == old(contents#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_Configuration_$memory) == old(domain#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];

procedure {:inline 1} $LibraConfig_reconfigure_$direct_intra(lr_account: $Value, $LibraConfig_Configuration_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraConfig_Configuration_$CallerDomain[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))) &&
       $abort_code == i#$Integer($Integer(1))));
modifies $LibraConfig_Configuration_$memory;
ensures contents#$Memory($LibraConfig_Configuration_$memory) == old(contents#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_Configuration_$memory) == old(domain#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];

procedure {:inline 1} $LibraConfig_reconfigure(lr_account: $Value, $LibraConfig_Configuration_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraConfig_Configuration_$CallerDomain[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$36(lr_account)), $Roles_RoleId_role_id), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(lr_account), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))) &&
       $abort_code == i#$Integer($Integer(1))));
modifies $LibraConfig_Configuration_$memory;
ensures contents#$Memory($LibraConfig_Configuration_$memory) == old(contents#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_Configuration_$memory) == old(domain#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];

procedure {:inline 1} $LibraConfig_reconfigure__$def($LibraConfig_Configuration_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var config_ref: $Mutation; // ReferenceType($LibraConfig_Configuration_type_value())
    var current_time: $Value; // $IntegerType()
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $BooleanType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Mutation; // ReferenceType($IntegerType())
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Mutation; // ReferenceType($IntegerType())
    var $t19: $Mutation; // ReferenceType($Event_EventHandle_type_value($LibraConfig_NewEpochEvent_type_value()))
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $LibraConfig_NewEpochEvent_type_value()
    var $t22: $Value; // $Event_EventHandle_type_value($LibraConfig_NewEpochEvent_type_value())
    var $LibraConfig_Configuration_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    $LibraConfig_Configuration_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := true];

    // bytecode translation starts here
    // $t5 := LibraTimestamp::is_genesis()
    call $t5 := $LibraTimestamp_is_genesis();
    if ($abort_flag) {
      goto Abort;
    }

    // if ($t5) goto L0 else goto L1
    if (b#$Boolean($t5)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t6 := true
    $t6 := $Boolean(true);

    // tmp#$2 := $t6
    call tmp#$2 := $CopyOrMoveValue($t6);
    if (true) { assume $DebugTrackLocal(17, 8895, 2, tmp#$2); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t7 := LibraTimestamp::now_microseconds()
    call $t7 := $LibraTimestamp_now_microseconds();
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 8943, $abort_code);
      goto Abort;
    }

    // $t8 := 0
    $t8 := $Integer(0);

    // tmp#$2 := ==($t7, $t8)
    tmp#$2 := $Boolean($IsEqual($t7, $t8));
    if (true) { assume $DebugTrackLocal(17, 8962, 2, tmp#$2); }

    // goto L3
    goto L3;

    // L3:
L3:

    // if (tmp#$2) goto L4 else goto L5
    if (b#$Boolean(tmp#$2)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // goto L6
    goto L6;

    // L4:
L4:

    // return ()
    return;

    // L6:
L6:

    // $t9 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t9 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // config_ref := borrow_global<LibraConfig::Configuration>($t9)
    assert $LibraConfig_Configuration_$SelfDomain[$EmptyTypeValueArray, a#$Address($t9)];
    call config_ref := $BorrowGlobal($LibraConfig_Configuration_$memory, $t9, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 9029, $abort_code);
      goto Abort;
    }

    // unpack_ref(config_ref)

    // current_time := LibraTimestamp::now_microseconds()
    call current_time := $LibraTimestamp_now_microseconds();
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 9143, $abort_code);
      goto Abort;
    }

    // $t10 := get_field<LibraConfig::Configuration>.last_reconfiguration_time(config_ref)
    call $t10 := $GetFieldFromReference(config_ref, $LibraConfig_Configuration_last_reconfiguration_time);

    // $t11 := >(current_time, $t10)
    call $t11 := $Gt(current_time, $t10);

    // $t12 := 4
    $t12 := $Integer(4);

    // $t13 := Errors::invalid_state($t12)
    call $t13 := $Errors_invalid_state($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 9239, $abort_code);
      goto Abort;
    }

    // if ($t11) goto L7 else goto L8
    if (b#$Boolean($t11)) { goto L7; } else { goto L8; }

    // L8:
L8:

    // destroy(config_ref)

    // pack_ref(config_ref)

    // abort($t13)
    if (true) { assume $DebugTrackAbort(17, 9171, i#$Integer($t13)); }
    $abort_code := i#$Integer($t13);
    goto Abort;

    // L7:
L7:

    // $t14 := borrow_field<LibraConfig::Configuration>.last_reconfiguration_time(config_ref)
    call $t14 := $BorrowField(config_ref, $LibraConfig_Configuration_last_reconfiguration_time);

    // unpack_ref($t14)

    // write_ref($t14, current_time)
    call $t14 := $WriteRef($t14, current_time);
    if (true) { assume $DebugTrackLocal(17, 9284, 0, $Dereference(config_ref)); }

    // pack_ref($t14)

    // write_back[Reference(config_ref)]($t14)
    call config_ref := $WritebackToReference($t14, config_ref);

    // $t15 := get_field<LibraConfig::Configuration>.epoch(config_ref)
    call $t15 := $GetFieldFromReference(config_ref, $LibraConfig_Configuration_epoch);

    // $t16 := 1
    $t16 := $Integer(1);

    // $t17 := +($t15, $t16)
    call $t17 := $AddU64($t15, $t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 9381, $abort_code);
      goto Abort;
    }

    // $t18 := borrow_field<LibraConfig::Configuration>.epoch(config_ref)
    call $t18 := $BorrowField(config_ref, $LibraConfig_Configuration_epoch);

    // unpack_ref($t18)

    // write_ref($t18, $t17)
    call $t18 := $WriteRef($t18, $t17);
    if (true) { assume $DebugTrackLocal(17, 9345, 0, $Dereference(config_ref)); }

    // pack_ref($t18)

    // write_back[Reference(config_ref)]($t18)
    call config_ref := $WritebackToReference($t18, config_ref);

    // $t19 := borrow_field<LibraConfig::Configuration>.events(config_ref)
    call $t19 := $BorrowField(config_ref, $LibraConfig_Configuration_events);

    // unpack_ref($t19)

    // $t20 := get_field<LibraConfig::Configuration>.epoch(config_ref)
    call $t20 := $GetFieldFromReference(config_ref, $LibraConfig_Configuration_epoch);

    // $t21 := pack LibraConfig::NewEpochEvent($t20)
    call $t21 := $LibraConfig_NewEpochEvent_pack(0, 0, 0, $t20);

    // $t22 := read_ref($t19)
    call $t22 := $ReadRef($t19);
    assert $Event_EventHandle_$invariant_holds($t22);

    // $t22 := Event::emit_event<LibraConfig::NewEpochEvent>($t22, $t21)
    call $t22 := $Event_emit_event($LibraConfig_NewEpochEvent_type_value(), $t22, $t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 9402, $abort_code);
      goto Abort;
    }

    // write_ref($t19, $t22)
    call $t19 := $WriteRef($t19, $t22);
    if (true) { assume $DebugTrackLocal(17, 9402, 0, $Dereference(config_ref)); }

    // pack_ref($t19)

    // write_back[Reference(config_ref)]($t19)
    call config_ref := $WritebackToReference($t19, config_ref);

    // pack_ref(config_ref)

    // write_back[LibraConfig::Configuration](config_ref)
    call $LibraConfig_Configuration_$memory := $WritebackToGlobal($LibraConfig_Configuration_$memory, config_ref);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraConfig_reconfigure__$direct_intra($LibraConfig_Configuration_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraConfig_Configuration_$CallerDomain[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraConfig_spec_reconfigure_omitted($LibraTimestamp_CurrentTimeMicroseconds_$memory)))) && b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraConfig_spec_reconfigure_omitted($LibraTimestamp_CurrentTimeMicroseconds_$memory)))) && b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraConfig_spec_reconfigure_omitted($LibraTimestamp_CurrentTimeMicroseconds_$memory)))) && b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($LibraConfig_spec_reconfigure_omitted($LibraTimestamp_CurrentTimeMicroseconds_$memory)) ==> b#$Boolean($Boolean($IsEqual($LibraConfig_config$18($LibraConfig_Configuration_$memory), old($LibraConfig_config$18($LibraConfig_Configuration_$memory))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraConfig_spec_reconfigure_omitted($LibraTimestamp_CurrentTimeMicroseconds_$memory)))) ==> b#$Boolean($Boolean($IsEqual($LibraConfig_config$18($LibraConfig_Configuration_$memory), $UpdateField($UpdateField(old($LibraConfig_config$18($LibraConfig_Configuration_$memory)), $LibraConfig_Configuration_epoch, $Integer(i#$Integer(old($SelectField($LibraConfig_config$18($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch))) + i#$Integer($Integer(1)))), $LibraConfig_Configuration_last_reconfiguration_time, $LibraConfig_now$19($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))));
modifies $LibraConfig_Configuration_$memory;
ensures contents#$Memory($LibraConfig_Configuration_$memory) == old(contents#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_Configuration_$memory) == old(domain#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];

procedure {:inline 1} $LibraConfig_reconfigure_($LibraConfig_Configuration_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraConfig_Configuration_$CallerDomain[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraConfig_spec_reconfigure_omitted($LibraTimestamp_CurrentTimeMicroseconds_$memory)))) && b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraConfig_spec_reconfigure_omitted($LibraTimestamp_CurrentTimeMicroseconds_$memory)))) && b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraConfig_spec_reconfigure_omitted($LibraTimestamp_CurrentTimeMicroseconds_$memory)))) && b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($LibraConfig_spec_reconfigure_omitted($LibraTimestamp_CurrentTimeMicroseconds_$memory)) ==> b#$Boolean($Boolean($IsEqual($LibraConfig_config$18($LibraConfig_Configuration_$memory), old($LibraConfig_config$18($LibraConfig_Configuration_$memory))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraConfig_spec_reconfigure_omitted($LibraTimestamp_CurrentTimeMicroseconds_$memory)))) ==> b#$Boolean($Boolean($IsEqual($LibraConfig_config$18($LibraConfig_Configuration_$memory), $UpdateField($UpdateField(old($LibraConfig_config$18($LibraConfig_Configuration_$memory)), $LibraConfig_Configuration_epoch, $Integer(i#$Integer(old($SelectField($LibraConfig_config$18($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch))) + i#$Integer($Integer(1)))), $LibraConfig_Configuration_last_reconfiguration_time, $LibraConfig_now$19($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))));
modifies $LibraConfig_Configuration_$memory;
ensures contents#$Memory($LibraConfig_Configuration_$memory) == old(contents#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_Configuration_$memory) == old(domain#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];

procedure {:inline 1} $LibraConfig_set_$def($tv0: $TypeValue, account: $Value, payload: $Value) returns ()
{
    // declare local variables
    var addr: $Value; // $AddressType()
    var config: $Mutation; // ReferenceType($LibraConfig_LibraConfig_type_value($tv0))
    var signer_address: $Value; // $AddressType()
    var tmp#$5: $Value; // $BooleanType()
    var tmp#$6: $Value; // $IntegerType()
    var tmp#$7: $Value; // $BooleanType()
    var tmp#$8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $tv0
    var $t11: $Value; // $BooleanType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Mutation; // ReferenceType($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(17, 3295, 0, account); }
    if (true) { assume $DebugTrackLocal(17, 3295, 1, payload); }

    // bytecode translation starts here
    // $t9 := move(account)
    call $t9 := $CopyOrMoveValue(account);

    // $t10 := move(payload)
    call $t10 := $CopyOrMoveValue(payload);

    // signer_address := Signer::address_of($t9)
    call signer_address := $Signer_address_of($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 3442, $abort_code);
      goto Abort;
    }

    // $t11 := exists<LibraConfig::ModifyConfigCapability<#0>>(signer_address)
    $t11 := $ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), signer_address);

    // $t12 := 2
    $t12 := $Integer(2);

    // $t13 := Errors::requires_capability($t12)
    call $t13 := $Errors_requires_capability($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 3542, $abort_code);
      goto Abort;
    }

    // if ($t11) goto L0 else goto L1
    if (b#$Boolean($t11)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t13)
    if (true) { assume $DebugTrackAbort(17, 3471, i#$Integer($t13)); }
    $abort_code := i#$Integer($t13);
    goto Abort;

    // L0:
L0:

    // addr := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call addr := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t14 := exists<LibraConfig::LibraConfig<#0>>(addr)
    $t14 := $ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr);

    // $t15 := 1
    $t15 := $Integer(1);

    // $t16 := Errors::not_published($t15)
    call $t16 := $Errors_not_published($t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 3699, $abort_code);
      goto Abort;
    }

    // if ($t14) goto L2 else goto L3
    if (b#$Boolean($t14)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t16)
    if (true) { assume $DebugTrackAbort(17, 3649, i#$Integer($t16)); }
    $abort_code := i#$Integer($t16);
    goto Abort;

    // L2:
L2:

    // config := borrow_global<LibraConfig::LibraConfig<#0>>(addr)
    call config := $BorrowGlobal($LibraConfig_LibraConfig_$memory, addr, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 3751, $abort_code);
      goto Abort;
    }

    // unpack_ref(config)

    // $t17 := borrow_field<LibraConfig::LibraConfig<#0>>.payload(config)
    call $t17 := $BorrowField(config, $LibraConfig_LibraConfig_payload);

    // unpack_ref($t17)

    // write_ref($t17, $t10)
    call $t17 := $WriteRef($t17, $t10);
    if (true) { assume $DebugTrackLocal(17, 3805, 3, $Dereference(config)); }

    // pack_ref($t17)

    // write_back[Reference(config)]($t17)
    call config := $WritebackToReference($t17, config);

    // pack_ref(config)

    // write_back[LibraConfig::LibraConfig](config)
    call $LibraConfig_LibraConfig_$memory := $WritebackToGlobal($LibraConfig_LibraConfig_$memory, config);

    // LibraConfig::reconfigure_()
    call $LibraConfig_reconfigure_($ConstMemoryDomain(true));
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 8784, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraConfig_set_$direct_inter($tv0: $TypeValue, account: $Value, payload: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(account))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(account)))))) &&
       $abort_code == i#$Integer($Integer(4)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraConfig_$get($LibraConfig_LibraConfig_$memory, $tv0), payload))));
modifies $LibraConfig_LibraConfig_$memory;
modifies $LibraConfig_Configuration_$memory;

procedure {:inline 1} $LibraConfig_set_$direct_intra($tv0: $TypeValue, account: $Value, payload: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(account))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(account)))))) &&
       $abort_code == i#$Integer($Integer(4)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraConfig_$get($LibraConfig_LibraConfig_$memory, $tv0), payload))));
modifies $LibraConfig_LibraConfig_$memory;
modifies $LibraConfig_Configuration_$memory;

procedure {:inline 1} $LibraConfig_set($tv0: $TypeValue, account: $Value, payload: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(account))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_ModifyConfigCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(account)))))) &&
       $abort_code == i#$Integer($Integer(4)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraConfig_$get($LibraConfig_LibraConfig_$memory, $tv0), payload))));
modifies $LibraConfig_LibraConfig_$memory;
modifies $LibraConfig_Configuration_$memory;

procedure {:inline 1} $LibraConfig_set_with_capability_and_reconfigure_$def($tv0: $TypeValue, _cap: $Value, payload: $Value, $LibraConfig_LibraConfig_$CallerDomain: [$TypeValueArray, int]bool, $LibraConfig_Configuration_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var addr: $Value; // $AddressType()
    var config: $Mutation; // ReferenceType($LibraConfig_LibraConfig_type_value($tv0))
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var $t6: $Value; // $tv0
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Mutation; // ReferenceType($tv0)
    var $LibraConfig_LibraConfig_$SelfDomain: [$TypeValueArray, int]bool;
    var $LibraConfig_Configuration_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(17, 4630, 0, _cap); }
    if (true) { assume $DebugTrackLocal(17, 4630, 1, payload); }
    $LibraConfig_LibraConfig_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := true];
    $LibraConfig_Configuration_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := true];

    // bytecode translation starts here
    // $t6 := move(payload)
    call $t6 := $CopyOrMoveValue(payload);

    // addr := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call addr := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t7 := exists<LibraConfig::LibraConfig<#0>>(addr)
    $t7 := $ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr);

    // $t8 := 1
    $t8 := $Integer(1);

    // $t9 := Errors::not_published($t8)
    call $t9 := $Errors_not_published($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 4925, $abort_code);
      goto Abort;
    }

    // if ($t7) goto L0 else goto L1
    if (b#$Boolean($t7)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t9)
    if (true) { assume $DebugTrackAbort(17, 4875, i#$Integer($t9)); }
    $abort_code := i#$Integer($t9);
    goto Abort;

    // L0:
L0:

    // config := borrow_global<LibraConfig::LibraConfig<#0>>(addr)
    assert $LibraConfig_LibraConfig_$SelfDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(addr)];
    call config := $BorrowGlobal($LibraConfig_LibraConfig_$memory, addr, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 4977, $abort_code);
      goto Abort;
    }

    // unpack_ref(config)

    // $t10 := borrow_field<LibraConfig::LibraConfig<#0>>.payload(config)
    call $t10 := $BorrowField(config, $LibraConfig_LibraConfig_payload);

    // unpack_ref($t10)

    // write_ref($t10, $t6)
    call $t10 := $WriteRef($t10, $t6);
    if (true) { assume $DebugTrackLocal(17, 5031, 3, $Dereference(config)); }

    // pack_ref($t10)

    // write_back[Reference(config)]($t10)
    call config := $WritebackToReference($t10, config);

    // pack_ref(config)

    // write_back[LibraConfig::LibraConfig](config)
    call $LibraConfig_LibraConfig_$memory := $WritebackToGlobal($LibraConfig_LibraConfig_$memory, config);

    // LibraConfig::reconfigure_()
    call $LibraConfig_reconfigure_($LibraConfig_Configuration_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 8784, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraConfig_set_with_capability_and_reconfigure_$direct_inter($tv0: $TypeValue, _cap: $Value, payload: $Value, $LibraConfig_LibraConfig_$CallerDomain: [$TypeValueArray, int]bool, $LibraConfig_Configuration_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraConfig_LibraConfig_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
requires $LibraConfig_Configuration_$CallerDomain[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraConfig_$get($LibraConfig_LibraConfig_$memory, $tv0), payload))));
modifies $LibraConfig_LibraConfig_$memory;
ensures contents#$Memory($LibraConfig_LibraConfig_$memory) == old(contents#$Memory($LibraConfig_LibraConfig_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_LibraConfig_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_LibraConfig_$memory) == old(domain#$Memory($LibraConfig_LibraConfig_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_LibraConfig_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
modifies $LibraConfig_Configuration_$memory;
ensures contents#$Memory($LibraConfig_Configuration_$memory) == old(contents#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_Configuration_$memory) == old(domain#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];

procedure {:inline 1} $LibraConfig_set_with_capability_and_reconfigure_$direct_intra($tv0: $TypeValue, _cap: $Value, payload: $Value, $LibraConfig_LibraConfig_$CallerDomain: [$TypeValueArray, int]bool, $LibraConfig_Configuration_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraConfig_LibraConfig_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
requires $LibraConfig_Configuration_$CallerDomain[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraConfig_$get($LibraConfig_LibraConfig_$memory, $tv0), payload))));
modifies $LibraConfig_LibraConfig_$memory;
ensures contents#$Memory($LibraConfig_LibraConfig_$memory) == old(contents#$Memory($LibraConfig_LibraConfig_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_LibraConfig_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_LibraConfig_$memory) == old(domain#$Memory($LibraConfig_LibraConfig_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_LibraConfig_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
modifies $LibraConfig_Configuration_$memory;
ensures contents#$Memory($LibraConfig_Configuration_$memory) == old(contents#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_Configuration_$memory) == old(domain#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];

procedure {:inline 1} $LibraConfig_set_with_capability_and_reconfigure($tv0: $TypeValue, _cap: $Value, payload: $Value, $LibraConfig_LibraConfig_$CallerDomain: [$TypeValueArray, int]bool, $LibraConfig_Configuration_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraConfig_LibraConfig_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
requires $LibraConfig_Configuration_$CallerDomain[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS())))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraConfig_LibraConfig_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) > i#$Integer($Integer(0)))))) && b#$Boolean($Boolean(i#$Integer($SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_epoch)) < i#$Integer($Integer(18446744073709551615)))))) && b#$Boolean($Boolean($IsEqual($LibraConfig_current_time$14($LibraTimestamp_CurrentTimeMicroseconds_$memory), $SelectField($LibraConfig_config$13($LibraConfig_Configuration_$memory), $LibraConfig_Configuration_last_reconfiguration_time))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $tv0)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraConfig_$get($LibraConfig_LibraConfig_$memory, $tv0), payload))));
modifies $LibraConfig_LibraConfig_$memory;
ensures contents#$Memory($LibraConfig_LibraConfig_$memory) == old(contents#$Memory($LibraConfig_LibraConfig_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_LibraConfig_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_LibraConfig_$memory) == old(domain#$Memory($LibraConfig_LibraConfig_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_LibraConfig_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
modifies $LibraConfig_Configuration_$memory;
ensures contents#$Memory($LibraConfig_Configuration_$memory) == old(contents#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := contents#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];
ensures domain#$Memory($LibraConfig_Configuration_$memory) == old(domain#$Memory($LibraConfig_Configuration_$memory))[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS()) := domain#$Memory($LibraConfig_Configuration_$memory)[$EmptyTypeValueArray, a#$Address($CoreAddresses_$LIBRA_ROOT_ADDRESS())]];



// ** spec vars of module RegisteredCurrencies



// ** spec funs of module RegisteredCurrencies

function {:inline} $RegisteredCurrencies_get_currency_codes($LibraConfig_LibraConfig_$memory: $Memory): $Value {
    $SelectField($LibraConfig_$get($LibraConfig_LibraConfig_$memory, $RegisteredCurrencies_RegisteredCurrencies_type_value()), $RegisteredCurrencies_RegisteredCurrencies_currency_codes)
}



// ** structs of module RegisteredCurrencies

const unique $RegisteredCurrencies_RegisteredCurrencies: $TypeName;
const $RegisteredCurrencies_RegisteredCurrencies_currency_codes: $FieldName;
axiom $RegisteredCurrencies_RegisteredCurrencies_currency_codes == 0;
function $RegisteredCurrencies_RegisteredCurrencies_type_value(): $TypeValue {
    $StructType($RegisteredCurrencies_RegisteredCurrencies, $EmptyTypeValueArray)
}
var $RegisteredCurrencies_RegisteredCurrencies_$memory: $Memory;
var $RegisteredCurrencies_RegisteredCurrencies_$memory_$old: $Memory;
function {:inline} $RegisteredCurrencies_RegisteredCurrencies_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && $Vector_$is_well_formed($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes)) && (forall $$0: int :: {$select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes)) ==> $Vector_$is_well_formed($select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes),$$0)) && (forall $$1: int :: {$select_vector($select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes),$$0),$$1)} $$1 >= 0 && $$1 < $vlen($select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes),$$0)) ==> $IsValidU8($select_vector($select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes),$$0),$$1))))
}
function {:inline} $RegisteredCurrencies_RegisteredCurrencies_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $RegisteredCurrencies_RegisteredCurrencies_$is_well_formed($this: $Value): bool {
    $RegisteredCurrencies_RegisteredCurrencies_$is_well_typed($this) && $RegisteredCurrencies_RegisteredCurrencies_$invariant_holds($this)}

procedure {:inline 1} $RegisteredCurrencies_RegisteredCurrencies_pack($file_id: int, $byte_index: int, $var_idx: int, currency_codes: $Value) returns ($struct: $Value)
{
    assume $Vector_$is_well_formed(currency_codes) && (forall $$0: int :: {$select_vector(currency_codes,$$0)} $$0 >= 0 && $$0 < $vlen(currency_codes) ==> $Vector_$is_well_formed($select_vector(currency_codes,$$0)) && (forall $$1: int :: {$select_vector($select_vector(currency_codes,$$0),$$1)} $$1 >= 0 && $$1 < $vlen($select_vector(currency_codes,$$0)) ==> $IsValidU8($select_vector($select_vector(currency_codes,$$0),$$1))));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := currency_codes], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $RegisteredCurrencies_RegisteredCurrencies_unpack($struct: $Value) returns (currency_codes: $Value)
{
    assume is#$Vector($struct);
    currency_codes := $SelectField($struct, $RegisteredCurrencies_RegisteredCurrencies_currency_codes);
    assume $Vector_$is_well_formed(currency_codes) && (forall $$0: int :: {$select_vector(currency_codes,$$0)} $$0 >= 0 && $$0 < $vlen(currency_codes) ==> $Vector_$is_well_formed($select_vector(currency_codes,$$0)) && (forall $$1: int :: {$select_vector($select_vector(currency_codes,$$0),$$1)} $$1 >= 0 && $$1 < $vlen($select_vector(currency_codes,$$0)) ==> $IsValidU8($select_vector($select_vector(currency_codes,$$0),$$1))));
}



// ** functions of module RegisteredCurrencies

procedure {:inline 1} $RegisteredCurrencies_initialize_$def(lr_account: $Value) returns ()
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $Vector_type_value($Vector_type_value($IntegerType()))
    var $t3: $Value; // $RegisteredCurrencies_RegisteredCurrencies_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 675, 0, lr_account); }

    // bytecode translation starts here
    // $t1 := move(lr_account)
    call $t1 := $CopyOrMoveValue(lr_account);

    // LibraTimestamp::assert_genesis()
    call $LibraTimestamp_assert_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 744, $abort_code);
      goto Abort;
    }

    // Roles::assert_libra_root($t1)
    call $Roles_assert_libra_root($t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 777, $abort_code);
      goto Abort;
    }

    // $t2 := Vector::empty<vector<u8>>()
    call $t2 := $Vector_empty($Vector_type_value($IntegerType()));
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 932, $abort_code);
      goto Abort;
    }

    // $t3 := pack RegisteredCurrencies::RegisteredCurrencies($t2)
    call $t3 := $RegisteredCurrencies_RegisteredCurrencies_pack(0, 0, 0, $t2);

    // LibraConfig::publish_new_config<RegisteredCurrencies::RegisteredCurrencies>($t1, $t3)
    call $LibraConfig_publish_new_config($RegisteredCurrencies_RegisteredCurrencies_type_value(), $t1, $t3, $ConstMemoryDomain(true), $ConstMemoryDomain(true));
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 829, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $RegisteredCurrencies_initialize_$direct_inter(lr_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    call $RegisteredCurrencies_initialize_$def(lr_account);
}


procedure {:inline 1} $RegisteredCurrencies_initialize_$direct_intra(lr_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    call $RegisteredCurrencies_initialize_$def(lr_account);
}


procedure {:inline 1} $RegisteredCurrencies_initialize(lr_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    call $RegisteredCurrencies_initialize_$def(lr_account);
}


procedure {:inline 1} $RegisteredCurrencies_add_currency_code_$def(lr_account: $Value, currency_code: $Value) returns ()
{
    // declare local variables
    var config: $Value; // $RegisteredCurrencies_RegisteredCurrencies_type_value()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $Vector_type_value($IntegerType())
    var $t7: $Value; // $Vector_type_value($Vector_type_value($IntegerType()))
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Mutation; // ReferenceType($RegisteredCurrencies_RegisteredCurrencies_type_value())
    var $t13: $Mutation; // ReferenceType($Vector_type_value($Vector_type_value($IntegerType())))
    var $t14: $Value; // $Vector_type_value($Vector_type_value($IntegerType()))

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 1477, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(21, 1477, 1, currency_code); }

    // bytecode translation starts here
    // $t5 := move(lr_account)
    call $t5 := $CopyOrMoveValue(lr_account);

    // $t6 := move(currency_code)
    call $t6 := $CopyOrMoveValue(currency_code);

    // config := LibraConfig::get<RegisteredCurrencies::RegisteredCurrencies>()
    call config := $LibraConfig_get($RegisteredCurrencies_RegisteredCurrencies_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 1613, $abort_code);
      goto Abort;
    }

    // $t7 := get_field<RegisteredCurrencies::RegisteredCurrencies>.currency_codes(config)
    call $t7 := $GetFieldFromValue(config, $RegisteredCurrencies_RegisteredCurrencies_currency_codes);

    // $t8 := Vector::contains<vector<u8>>($t7, $t6)
    call $t8 := $Vector_contains($Vector_type_value($IntegerType()), $t7, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 1679, $abort_code);
      goto Abort;
    }

    // $t9 := !($t8)
    call $t9 := $Not($t8);

    // $t10 := 0
    $t10 := $Integer(0);

    // $t11 := Errors::invalid_argument($t10)
    call $t11 := $Errors_invalid_argument($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 1749, $abort_code);
      goto Abort;
    }

    // if ($t9) goto L0 else goto L1
    if (b#$Boolean($t9)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t5)

    // abort($t11)
    if (true) { assume $DebugTrackAbort(21, 1650, i#$Integer($t11)); }
    $abort_code := i#$Integer($t11);
    goto Abort;

    // L0:
L0:

    // $t12 := borrow_local(config)
    call $t12 := $BorrowLoc(2, config);

    // unpack_ref($t12)

    // $t13 := borrow_field<RegisteredCurrencies::RegisteredCurrencies>.currency_codes($t12)
    call $t13 := $BorrowField($t12, $RegisteredCurrencies_RegisteredCurrencies_currency_codes);

    // unpack_ref($t13)

    // $t14 := read_ref($t13)
    call $t14 := $ReadRef($t13);

    // $t14 := Vector::push_back<vector<u8>>($t14, $t6)
    call $t14 := $Vector_push_back($Vector_type_value($IntegerType()), $t14, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 1823, $abort_code);
      goto Abort;
    }

    // write_ref($t13, $t14)
    call $t13 := $WriteRef($t13, $t14);

    // pack_ref($t13)

    // write_back[Reference($t12)]($t13)
    call $t12 := $WritebackToReference($t13, $t12);

    // pack_ref($t12)

    // write_back[LocalRoot(config)]($t12)
    call config := $WritebackToValue($t12, 2, config);

    // LibraConfig::set<RegisteredCurrencies::RegisteredCurrencies>($t5, config)
    call $LibraConfig_set($RegisteredCurrencies_RegisteredCurrencies_type_value(), $t5, config);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 1898, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $RegisteredCurrencies_add_currency_code_$direct_inter(lr_account: $Value, currency_code: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));

    call $RegisteredCurrencies_add_currency_code_$def(lr_account, currency_code);
}


procedure {:inline 1} $RegisteredCurrencies_add_currency_code_$direct_intra(lr_account: $Value, currency_code: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));

    call $RegisteredCurrencies_add_currency_code_$def(lr_account, currency_code);
}


procedure {:inline 1} $RegisteredCurrencies_add_currency_code(lr_account: $Value, currency_code: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));

    call $RegisteredCurrencies_add_currency_code_$def(lr_account, currency_code);
}




// ** spec vars of module FixedPoint32



// ** spec funs of module FixedPoint32

function {:inline} $FixedPoint32_spec_concrete_multiply_u64(val: $Value, multiplier: $Value): $Value {
    $shr($Integer(i#$Integer(val) * i#$Integer($SelectField(multiplier, $FixedPoint32_FixedPoint32_value))), $Integer(32))
}

function {:inline} $FixedPoint32_spec_multiply_u64(val: $Value, multiplier: $Value): $Value {
    if (b#$Boolean($Boolean($IsEqual($SelectField(multiplier, $FixedPoint32_FixedPoint32_value), $Integer(0))))) then ($Integer(0)) else (if (b#$Boolean($Boolean($IsEqual($SelectField(multiplier, $FixedPoint32_FixedPoint32_value), $Integer(1))))) then (val) else (if (b#$Boolean($Boolean($IsEqual($SelectField(multiplier, $FixedPoint32_FixedPoint32_value), $Integer(2))))) then ($Integer(i#$Integer(val) div i#$Integer($Integer(2)))) else ($Integer(i#$Integer($Integer(18446744073709551615)) + i#$Integer($Integer(1))))))
}

function {:inline} $FixedPoint32_spec_concrete_divide_u64(val: $Value, divisor: $Value): $Value {
    $Integer(i#$Integer($shl(val, $Integer(32))) div i#$Integer($SelectField(divisor, $FixedPoint32_FixedPoint32_value)))
}

function {:inline} $FixedPoint32_spec_divide_u64(val: $Value, divisor: $Value): $Value {
    if (b#$Boolean($Boolean($IsEqual($SelectField(divisor, $FixedPoint32_FixedPoint32_value), $Integer(1))))) then (val) else (if (b#$Boolean($Boolean($IsEqual($SelectField(divisor, $FixedPoint32_FixedPoint32_value), $Integer(2))))) then ($Integer(i#$Integer(val) * i#$Integer($Integer(2)))) else ($Integer(i#$Integer($Integer(18446744073709551615)) + i#$Integer($Integer(1)))))
}

function {:inline} $FixedPoint32_spec_concrete_create_from_rational(numerator: $Value, denominator: $Value): $Value {
    $Vector($ExtendValueArray($EmptyValueArray(), $Integer(i#$Integer($shl(numerator, $Integer(64))) div i#$Integer($shl(denominator, $Integer(32))))))
}

function {:inline} $FixedPoint32_spec_create_from_rational(numerator: $Value, denominator: $Value): $Value {
    if (b#$Boolean($Boolean($IsEqual(numerator, denominator)))) then ($Vector($ExtendValueArray($EmptyValueArray(), $Integer(1)))) else ($Vector($ExtendValueArray($EmptyValueArray(), $Integer(2))))
}

function {:inline} $FixedPoint32_scaled_numerator$12(numerator: $Value): $Value {
    $shl(numerator, $Integer(64))
}

function {:inline} $FixedPoint32_scaled_denominator$13(denominator: $Value): $Value {
    $shl(denominator, $Integer(32))
}

function {:inline} $FixedPoint32_quotient$14(numerator: $Value, denominator: $Value): $Value {
    $Integer(i#$Integer($FixedPoint32_scaled_numerator$12(numerator)) div i#$Integer($FixedPoint32_scaled_denominator$13(denominator)))
}



// ** structs of module FixedPoint32

const unique $FixedPoint32_FixedPoint32: $TypeName;
const $FixedPoint32_FixedPoint32_value: $FieldName;
axiom $FixedPoint32_FixedPoint32_value == 0;
function $FixedPoint32_FixedPoint32_type_value(): $TypeValue {
    $StructType($FixedPoint32_FixedPoint32, $EmptyTypeValueArray)
}
var $FixedPoint32_FixedPoint32_$memory: $Memory;
var $FixedPoint32_FixedPoint32_$memory_$old: $Memory;
function {:inline} $FixedPoint32_FixedPoint32_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $FixedPoint32_FixedPoint32_value))
}
function {:inline} $FixedPoint32_FixedPoint32_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $FixedPoint32_FixedPoint32_$is_well_formed($this: $Value): bool {
    $FixedPoint32_FixedPoint32_$is_well_typed($this) && $FixedPoint32_FixedPoint32_$invariant_holds($this)}

procedure {:inline 1} $FixedPoint32_FixedPoint32_pack($file_id: int, $byte_index: int, $var_idx: int, value: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(value);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := value], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $FixedPoint32_FixedPoint32_unpack($struct: $Value) returns (value: $Value)
{
    assume is#$Vector($struct);
    value := $SelectField($struct, $FixedPoint32_FixedPoint32_value);
    assume $IsValidU64(value);
}



// ** functions of module FixedPoint32

procedure {:inline 1} $FixedPoint32_create_from_rational_$def(numerator: $Value, denominator: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var quotient: $Value; // $IntegerType()
    var scaled_denominator: $Value; // $IntegerType()
    var scaled_numerator: $Value; // $IntegerType()
    var tmp#$5: $Value; // $BooleanType()
    var tmp#$6: $Value; // $IntegerType()
    var tmp#$7: $Value; // $BooleanType()
    var tmp#$8: $Value; // $IntegerType()
    var tmp#$9: $Value; // $BooleanType()
    var tmp#$10: $Value; // $BooleanType()
    var tmp#$11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Value; // $BooleanType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $BooleanType()
    var $t30: $Value; // $IntegerType()
    var $t31: $Value; // $IntegerType()
    var $t32: $Value; // $IntegerType()
    var $t33: $Value; // $FixedPoint32_FixedPoint32_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(11, 6644, 0, numerator); }
    if (true) { assume $DebugTrackLocal(11, 6644, 1, denominator); }

    // bytecode translation starts here
    // $t12 := move(numerator)
    call $t12 := $CopyOrMoveValue(numerator);

    // $t13 := move(denominator)
    call $t13 := $CopyOrMoveValue(denominator);

    // $t14 := (u128)($t12)
    call $t14 := $CastU128($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(11, 6992, $abort_code);
      goto Abort;
    }

    // $t15 := 64
    $t15 := $Integer(64);

    // scaled_numerator := <<($t14, $t15)
    call scaled_numerator := $Shl($t14, $t15);
    if (true) { assume $DebugTrackLocal(11, 7012, 4, scaled_numerator); }

    // $t16 := (u128)($t13)
    call $t16 := $CastU128($t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(11, 7052, $abort_code);
      goto Abort;
    }

    // $t17 := 32
    $t17 := $Integer(32);

    // scaled_denominator := <<($t16, $t17)
    call scaled_denominator := $Shl($t16, $t17);
    if (true) { assume $DebugTrackLocal(11, 7074, 3, scaled_denominator); }

    // $t18 := 0
    $t18 := $Integer(0);

    // $t19 := !=(scaled_denominator, $t18)
    $t19 := $Boolean(!$IsEqual(scaled_denominator, $t18));

    // $t20 := 0
    $t20 := $Integer(0);

    // $t21 := Errors::invalid_argument($t20)
    call $t21 := $Errors_invalid_argument($t20);
    if ($abort_flag) {
      assume $DebugTrackAbort(11, 7129, $abort_code);
      goto Abort;
    }

    // if ($t19) goto L0 else goto L1
    if (b#$Boolean($t19)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t21)
    if (true) { assume $DebugTrackAbort(11, 7089, i#$Integer($t21)); }
    $abort_code := i#$Integer($t21);
    goto Abort;

    // L0:
L0:

    // quotient := /(scaled_numerator, scaled_denominator)
    call quotient := $Div(scaled_numerator, scaled_denominator);
    if ($abort_flag) {
      assume $DebugTrackAbort(11, 7202, $abort_code);
      goto Abort;
    }
    if (true) { assume $DebugTrackLocal(11, 7202, 2, quotient); }

    // $t22 := 0
    $t22 := $Integer(0);

    // $t23 := !=(quotient, $t22)
    $t23 := $Boolean(!$IsEqual(quotient, $t22));

    // if ($t23) goto L2 else goto L3
    if (b#$Boolean($t23)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // goto L4
    goto L4;

    // L2:
L2:

    // $t24 := true
    $t24 := $Boolean(true);

    // tmp#$9 := $t24
    call tmp#$9 := $CopyOrMoveValue($t24);
    if (true) { assume $DebugTrackLocal(11, 7239, 9, tmp#$9); }

    // goto L5
    goto L5;

    // L4:
L4:

    // $t25 := 0
    $t25 := $Integer(0);

    // tmp#$9 := ==($t12, $t25)
    tmp#$9 := $Boolean($IsEqual($t12, $t25));
    if (true) { assume $DebugTrackLocal(11, 7266, 9, tmp#$9); }

    // goto L5
    goto L5;

    // L5:
L5:

    // $t26 := 4
    $t26 := $Integer(4);

    // $t27 := Errors::invalid_argument($t26)
    call $t27 := $Errors_invalid_argument($t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(11, 7280, $abort_code);
      goto Abort;
    }

    // if (tmp#$9) goto L6 else goto L7
    if (b#$Boolean(tmp#$9)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // abort($t27)
    if (true) { assume $DebugTrackAbort(11, 7232, i#$Integer($t27)); }
    $abort_code := i#$Integer($t27);
    goto Abort;

    // L6:
L6:

    // $t28 := 18446744073709551615
    $t28 := $Integer(18446744073709551615);

    // $t29 := <=(quotient, $t28)
    call $t29 := $Le(quotient, $t28);

    // $t30 := 4
    $t30 := $Integer(4);

    // $t31 := Errors::limit_exceeded($t30)
    call $t31 := $Errors_limit_exceeded($t30);
    if ($abort_flag) {
      assume $DebugTrackAbort(11, 7484, $abort_code);
      goto Abort;
    }

    // if ($t29) goto L8 else goto L9
    if (b#$Boolean($t29)) { goto L8; } else { goto L9; }

    // L9:
L9:

    // abort($t31)
    if (true) { assume $DebugTrackAbort(11, 7448, i#$Integer($t31)); }
    $abort_code := i#$Integer($t31);
    goto Abort;

    // L8:
L8:

    // $t32 := (u64)(quotient)
    call $t32 := $CastU64(quotient);
    if ($abort_flag) {
      assume $DebugTrackAbort(11, 7552, $abort_code);
      goto Abort;
    }

    // $t33 := pack FixedPoint32::FixedPoint32($t32)
    call $t33 := $FixedPoint32_FixedPoint32_pack(0, 0, 0, $t32);

    // return $t33
    $ret0 := $t33;
    if (true) { assume $DebugTrackLocal(11, 7530, 34, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $FixedPoint32_create_from_rational_$direct_inter(numerator: $Value, denominator: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean($IsEqual($FixedPoint32_scaled_denominator$13(denominator), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($FixedPoint32_quotient$14(numerator, denominator), $Integer(0)))) && b#$Boolean($Boolean(!$IsEqual($FixedPoint32_scaled_numerator$12(numerator), $Integer(0))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_quotient$14(numerator, denominator)) > i#$Integer($Integer(18446744073709551615))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean($IsEqual($FixedPoint32_scaled_denominator$13(denominator), $Integer(0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($FixedPoint32_quotient$14(numerator, denominator), $Integer(0)))) && b#$Boolean($Boolean(!$IsEqual($FixedPoint32_scaled_numerator$12(numerator), $Integer(0)))))))
    || b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_quotient$14(numerator, denominator)) > i#$Integer($Integer(18446744073709551615))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean($IsEqual($FixedPoint32_scaled_denominator$13(denominator), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($FixedPoint32_quotient$14(numerator, denominator), $Integer(0)))) && b#$Boolean($Boolean(!$IsEqual($FixedPoint32_scaled_numerator$12(numerator), $Integer(0))))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_quotient$14(numerator, denominator)) > i#$Integer($Integer(18446744073709551615))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_create_from_rational(numerator, denominator)))));
ensures $FixedPoint32_FixedPoint32_$is_well_formed($ret0);

procedure {:inline 1} $FixedPoint32_create_from_rational_$direct_intra(numerator: $Value, denominator: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean($IsEqual($FixedPoint32_scaled_denominator$13(denominator), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($FixedPoint32_quotient$14(numerator, denominator), $Integer(0)))) && b#$Boolean($Boolean(!$IsEqual($FixedPoint32_scaled_numerator$12(numerator), $Integer(0))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_quotient$14(numerator, denominator)) > i#$Integer($Integer(18446744073709551615))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean($IsEqual($FixedPoint32_scaled_denominator$13(denominator), $Integer(0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($FixedPoint32_quotient$14(numerator, denominator), $Integer(0)))) && b#$Boolean($Boolean(!$IsEqual($FixedPoint32_scaled_numerator$12(numerator), $Integer(0)))))))
    || b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_quotient$14(numerator, denominator)) > i#$Integer($Integer(18446744073709551615))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean($IsEqual($FixedPoint32_scaled_denominator$13(denominator), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($FixedPoint32_quotient$14(numerator, denominator), $Integer(0)))) && b#$Boolean($Boolean(!$IsEqual($FixedPoint32_scaled_numerator$12(numerator), $Integer(0))))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_quotient$14(numerator, denominator)) > i#$Integer($Integer(18446744073709551615))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_create_from_rational(numerator, denominator)))));
ensures $FixedPoint32_FixedPoint32_$is_well_formed($ret0);

procedure {:inline 1} $FixedPoint32_create_from_rational(numerator: $Value, denominator: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean($IsEqual($FixedPoint32_scaled_denominator$13(denominator), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($FixedPoint32_quotient$14(numerator, denominator), $Integer(0)))) && b#$Boolean($Boolean(!$IsEqual($FixedPoint32_scaled_numerator$12(numerator), $Integer(0))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_quotient$14(numerator, denominator)) > i#$Integer($Integer(18446744073709551615))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean($IsEqual($FixedPoint32_scaled_denominator$13(denominator), $Integer(0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($FixedPoint32_quotient$14(numerator, denominator), $Integer(0)))) && b#$Boolean($Boolean(!$IsEqual($FixedPoint32_scaled_numerator$12(numerator), $Integer(0)))))))
    || b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_quotient$14(numerator, denominator)) > i#$Integer($Integer(18446744073709551615))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean($IsEqual($FixedPoint32_scaled_denominator$13(denominator), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($FixedPoint32_quotient$14(numerator, denominator), $Integer(0)))) && b#$Boolean($Boolean(!$IsEqual($FixedPoint32_scaled_numerator$12(numerator), $Integer(0))))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_quotient$14(numerator, denominator)) > i#$Integer($Integer(18446744073709551615))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_create_from_rational(numerator, denominator)))));
ensures $FixedPoint32_FixedPoint32_$is_well_formed($ret0);

procedure {:inline 1} $FixedPoint32_create_from_raw_value_$def(value: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $IntegerType()
    var $t2: $Value; // $FixedPoint32_FixedPoint32_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(11, 9254, 0, value); }

    // bytecode translation starts here
    // $t1 := move(value)
    call $t1 := $CopyOrMoveValue(value);

    // $t2 := pack FixedPoint32::FixedPoint32($t1)
    call $t2 := $FixedPoint32_FixedPoint32_pack(0, 0, 0, $t1);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(11, 9323, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $FixedPoint32_create_from_raw_value_$direct_inter(value: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $FixedPoint32_FixedPoint32_value), $Integer(2)))));
ensures $FixedPoint32_FixedPoint32_$is_well_formed($ret0);

procedure {:inline 1} $FixedPoint32_create_from_raw_value_$direct_intra(value: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $FixedPoint32_FixedPoint32_value), $Integer(2)))));
ensures $FixedPoint32_FixedPoint32_$is_well_formed($ret0);

procedure {:inline 1} $FixedPoint32_create_from_raw_value(value: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $FixedPoint32_FixedPoint32_value), $Integer(2)))));
ensures $FixedPoint32_FixedPoint32_$is_well_formed($ret0);

procedure {:inline 1} $FixedPoint32_divide_u64_$def(val: $Value, divisor: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var quotient: $Value; // $IntegerType()
    var scaled_value: $Value; // $IntegerType()
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var tmp#$6: $Value; // $BooleanType()
    var tmp#$7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $BooleanType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(11, 3860, 0, val); }
    if (true) { assume $DebugTrackLocal(11, 3860, 1, divisor); }

    // bytecode translation starts here
    // $t8 := move(val)
    call $t8 := $CopyOrMoveValue(val);

    // $t9 := move(divisor)
    call $t9 := $CopyOrMoveValue(divisor);

    // $t10 := get_field<FixedPoint32::FixedPoint32>.value($t9)
    call $t10 := $GetFieldFromValue($t9, $FixedPoint32_FixedPoint32_value);

    // $t11 := 0
    $t11 := $Integer(0);

    // $t12 := !=($t10, $t11)
    $t12 := $Boolean(!$IsEqual($t10, $t11));

    // $t13 := 3
    $t13 := $Integer(3);

    // $t14 := Errors::invalid_argument($t13)
    call $t14 := $Errors_invalid_argument($t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(11, 4004, $abort_code);
      goto Abort;
    }

    // if ($t12) goto L0 else goto L1
    if (b#$Boolean($t12)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t14)
    if (true) { assume $DebugTrackAbort(11, 3969, i#$Integer($t14)); }
    $abort_code := i#$Integer($t14);
    goto Abort;

    // L0:
L0:

    // $t15 := (u128)($t8)
    call $t15 := $CastU128($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(11, 4185, $abort_code);
      goto Abort;
    }

    // $t16 := 32
    $t16 := $Integer(32);

    // scaled_value := <<($t15, $t16)
    call scaled_value := $Shl($t15, $t16);
    if (true) { assume $DebugTrackLocal(11, 4199, 3, scaled_value); }

    // $t17 := get_field<FixedPoint32::FixedPoint32>.value($t9)
    call $t17 := $GetFieldFromValue($t9, $FixedPoint32_FixedPoint32_value);

    // $t18 := (u128)($t17)
    call $t18 := $CastU128($t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(11, 4244, $abort_code);
      goto Abort;
    }

    // quotient := /(scaled_value, $t18)
    call quotient := $Div(scaled_value, $t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(11, 4242, $abort_code);
      goto Abort;
    }
    if (true) { assume $DebugTrackLocal(11, 4242, 2, quotient); }

    // $t19 := 18446744073709551615
    $t19 := $Integer(18446744073709551615);

    // $t20 := <=(quotient, $t19)
    call $t20 := $Le(quotient, $t19);

    // $t21 := 1
    $t21 := $Integer(1);

    // $t22 := Errors::limit_exceeded($t21)
    call $t22 := $Errors_limit_exceeded($t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(11, 4362, $abort_code);
      goto Abort;
    }

    // if ($t20) goto L2 else goto L3
    if (b#$Boolean($t20)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t22)
    if (true) { assume $DebugTrackAbort(11, 4326, i#$Integer($t22)); }
    $abort_code := i#$Integer($t22);
    goto Abort;

    // L2:
L2:

    // $t23 := (u64)(quotient)
    call $t23 := $CastU64(quotient);
    if ($abort_flag) {
      assume $DebugTrackAbort(11, 4508, $abort_code);
      goto Abort;
    }

    // return $t23
    $ret0 := $t23;
    if (true) { assume $DebugTrackLocal(11, 4508, 24, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $FixedPoint32_divide_u64_$direct_inter(val: $Value, divisor: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean($IsEqual($SelectField(divisor, $FixedPoint32_FixedPoint32_value), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_divide_u64(val, divisor)) > i#$Integer($Integer(18446744073709551615))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean($IsEqual($SelectField(divisor, $FixedPoint32_FixedPoint32_value), $Integer(0)))))
    || b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_divide_u64(val, divisor)) > i#$Integer($Integer(18446744073709551615))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean($IsEqual($SelectField(divisor, $FixedPoint32_FixedPoint32_value), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_divide_u64(val, divisor)) > i#$Integer($Integer(18446744073709551615))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_divide_u64(val, divisor)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $FixedPoint32_divide_u64_$direct_intra(val: $Value, divisor: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean($IsEqual($SelectField(divisor, $FixedPoint32_FixedPoint32_value), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_divide_u64(val, divisor)) > i#$Integer($Integer(18446744073709551615))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean($IsEqual($SelectField(divisor, $FixedPoint32_FixedPoint32_value), $Integer(0)))))
    || b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_divide_u64(val, divisor)) > i#$Integer($Integer(18446744073709551615))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean($IsEqual($SelectField(divisor, $FixedPoint32_FixedPoint32_value), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_divide_u64(val, divisor)) > i#$Integer($Integer(18446744073709551615))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_divide_u64(val, divisor)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $FixedPoint32_divide_u64(val: $Value, divisor: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean($IsEqual($SelectField(divisor, $FixedPoint32_FixedPoint32_value), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_divide_u64(val, divisor)) > i#$Integer($Integer(18446744073709551615))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean($IsEqual($SelectField(divisor, $FixedPoint32_FixedPoint32_value), $Integer(0)))))
    || b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_divide_u64(val, divisor)) > i#$Integer($Integer(18446744073709551615))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean($IsEqual($SelectField(divisor, $FixedPoint32_FixedPoint32_value), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_divide_u64(val, divisor)) > i#$Integer($Integer(18446744073709551615))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_divide_u64(val, divisor)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $FixedPoint32_get_raw_value_$def(num: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t2: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(11, 9724, 0, num); }

    // bytecode translation starts here
    // $t1 := move(num)
    call $t1 := $CopyOrMoveValue(num);

    // $t2 := get_field<FixedPoint32::FixedPoint32>.value($t1)
    call $t2 := $GetFieldFromValue($t1, $FixedPoint32_FixedPoint32_value);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(11, 9783, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $FixedPoint32_get_raw_value_$direct_inter(num: $Value) returns ($ret0: $Value)
{
    assume $FixedPoint32_FixedPoint32_$is_well_formed(num);

    call $ret0 := $FixedPoint32_get_raw_value_$def(num);
}


procedure {:inline 1} $FixedPoint32_get_raw_value_$direct_intra(num: $Value) returns ($ret0: $Value)
{
    assume $FixedPoint32_FixedPoint32_$is_well_formed(num);

    call $ret0 := $FixedPoint32_get_raw_value_$def(num);
}


procedure {:inline 1} $FixedPoint32_get_raw_value(num: $Value) returns ($ret0: $Value)
{
    assume $FixedPoint32_FixedPoint32_$is_well_formed(num);

    call $ret0 := $FixedPoint32_get_raw_value_$def(num);
}


procedure {:inline 1} $FixedPoint32_is_zero_$def(num: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(11, 9847, 0, num); }

    // bytecode translation starts here
    // $t1 := move(num)
    call $t1 := $CopyOrMoveValue(num);

    // $t2 := get_field<FixedPoint32::FixedPoint32>.value($t1)
    call $t2 := $GetFieldFromValue($t1, $FixedPoint32_FixedPoint32_value);

    // $t3 := 0
    $t3 := $Integer(0);

    // $t4 := ==($t2, $t3)
    $t4 := $Boolean($IsEqual($t2, $t3));

    // return $t4
    $ret0 := $t4;
    if (true) { assume $DebugTrackLocal(11, 9901, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $FixedPoint32_is_zero_$direct_inter(num: $Value) returns ($ret0: $Value)
{
    assume $FixedPoint32_FixedPoint32_$is_well_formed(num);

    call $ret0 := $FixedPoint32_is_zero_$def(num);
}


procedure {:inline 1} $FixedPoint32_is_zero_$direct_intra(num: $Value) returns ($ret0: $Value)
{
    assume $FixedPoint32_FixedPoint32_$is_well_formed(num);

    call $ret0 := $FixedPoint32_is_zero_$def(num);
}


procedure {:inline 1} $FixedPoint32_is_zero(num: $Value) returns ($ret0: $Value)
{
    assume $FixedPoint32_FixedPoint32_$is_well_formed(num);

    call $ret0 := $FixedPoint32_is_zero_$def(num);
}


procedure {:inline 1} $FixedPoint32_multiply_u64_$def(val: $Value, multiplier: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var product: $Value; // $IntegerType()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var unscaled_product: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(11, 1467, 0, val); }
    if (true) { assume $DebugTrackLocal(11, 1467, 1, multiplier); }

    // bytecode translation starts here
    // $t6 := move(val)
    call $t6 := $CopyOrMoveValue(val);

    // $t7 := move(multiplier)
    call $t7 := $CopyOrMoveValue(multiplier);

    // $t8 := (u128)($t6)
    call $t8 := $CastU128($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(11, 1751, $abort_code);
      goto Abort;
    }

    // $t9 := get_field<FixedPoint32::FixedPoint32>.value($t7)
    call $t9 := $GetFieldFromValue($t7, $FixedPoint32_FixedPoint32_value);

    // $t10 := (u128)($t9)
    call $t10 := $CastU128($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(11, 1767, $abort_code);
      goto Abort;
    }

    // unscaled_product := *($t8, $t10)
    call unscaled_product := $MulU128($t8, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(11, 1765, $abort_code);
      goto Abort;
    }
    if (true) { assume $DebugTrackLocal(11, 1765, 5, unscaled_product); }

    // $t11 := 32
    $t11 := $Integer(32);

    // product := <<(unscaled_product, $t11)
    call product := $Shr(unscaled_product, $t11);
    if (true) { assume $DebugTrackLocal(11, 1967, 2, product); }

    // $t12 := 18446744073709551615
    $t12 := $Integer(18446744073709551615);

    // $t13 := <=(product, $t12)
    call $t13 := $Le(product, $t12);

    // $t14 := 2
    $t14 := $Integer(2);

    // $t15 := Errors::limit_exceeded($t14)
    call $t15 := $Errors_limit_exceeded($t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(11, 2066, $abort_code);
      goto Abort;
    }

    // if ($t13) goto L0 else goto L1
    if (b#$Boolean($t13)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t15)
    if (true) { assume $DebugTrackAbort(11, 2031, i#$Integer($t15)); }
    $abort_code := i#$Integer($t15);
    goto Abort;

    // L0:
L0:

    // $t16 := (u64)(product)
    call $t16 := $CastU64(product);
    if ($abort_flag) {
      assume $DebugTrackAbort(11, 2108, $abort_code);
      goto Abort;
    }

    // return $t16
    $ret0 := $t16;
    if (true) { assume $DebugTrackLocal(11, 2108, 17, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $FixedPoint32_multiply_u64_$direct_inter(val: $Value, multiplier: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(val, multiplier)) > i#$Integer($Integer(18446744073709551615))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(val, multiplier)) > i#$Integer($Integer(18446744073709551615))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(val, multiplier)) > i#$Integer($Integer(18446744073709551615))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_multiply_u64(val, multiplier)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $FixedPoint32_multiply_u64_$direct_intra(val: $Value, multiplier: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(val, multiplier)) > i#$Integer($Integer(18446744073709551615))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(val, multiplier)) > i#$Integer($Integer(18446744073709551615))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(val, multiplier)) > i#$Integer($Integer(18446744073709551615))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_multiply_u64(val, multiplier)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $FixedPoint32_multiply_u64(val: $Value, multiplier: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(val, multiplier)) > i#$Integer($Integer(18446744073709551615))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(val, multiplier)) > i#$Integer($Integer(18446744073709551615))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(val, multiplier)) > i#$Integer($Integer(18446744073709551615))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_multiply_u64(val, multiplier)))));
ensures $IsValidU64($ret0);



// ** spec vars of module Libra



// ** spec funs of module Libra

function {:inline} $Libra_$is_currency($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue): $Value {
    $ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())
}

function {:inline} $Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue): $Value {
    (var addr := $CoreAddresses_$CURRENCY_INFO_ADDRESS(); $Boolean(b#$Boolean($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)) && b#$Boolean($SelectField($ResourceValue($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $Libra_CurrencyInfo_is_synthetic))))
}

function {:inline} $Libra_$value($tv0: $TypeValue, coin: $Value): $Value {
    $SelectField(coin, $Libra_Libra_value)
}

function {:inline} $Libra_spec_market_cap($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue): $Value {
    $SelectField($ResourceValue($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)
}

function {:inline} $Libra_spec_scaling_factor($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue): $Value {
    $SelectField($ResourceValue($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_scaling_factor)
}

function {:inline} $Libra_spec_is_currency($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue): $Value {
    $ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())
}

function {:inline} $Libra_spec_currency_info($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue): $Value {
    $ResourceValue($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())
}

function {:inline} $Libra_spec_approx_lbr_for_value($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue, value: $Value): $Value {
    $FixedPoint32_spec_multiply_u64(value, $Libra_spec_lbr_exchange_rate($Libra_CurrencyInfo_$memory, $tv0))
}

function {:inline} $Libra_spec_lbr_exchange_rate($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue): $Value {
    $SelectField($ResourceValue($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_to_lbr_exchange_rate)
}

function {:inline} $Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue): $Value {
    $Boolean(b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)) && b#$Boolean($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_is_synthetic)))))
}

function {:inline} $Libra_spec_has_mint_capability($Libra_MintCapability_$memory: $Memory, $tv0: $TypeValue, addr: $Value): $Value {
    $ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)
}

function {:inline} $Libra_spec_has_burn_capability($Libra_BurnCapability_$memory: $Memory, $tv0: $TypeValue, addr: $Value): $Value {
    $ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)
}

function {:inline} $Libra_to_burn$49($tv0: $TypeValue, preburn: $Value): $Value {
    $SelectField($SelectField(preburn, $Libra_Preburn_to_burn), $Libra_Libra_value)
}

function {:inline} $Libra_info$50($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue): $Value {
    $Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0)
}

function {:inline} $Libra_currency_info$51($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue): $Value {
    $ResourceValue($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())
}

function {:inline} $Libra_account_addr$52($tv0: $TypeValue, account: $Value): $Value {
    $Signer_spec_address_of(account)
}

function {:inline} $Libra_preburn$53($Libra_Preburn_$memory: $Memory, $tv0: $TypeValue, account: $Value): $Value {
    $ResourceValue($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Libra_account_addr$52($tv0, account))
}

function {:inline} $Libra_info$54($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue): $Value {
    $ResourceValue($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())
}

function {:inline} $Libra_amount$55($Libra_Preburn_$memory: $Memory, $tv0: $TypeValue, preburn_address: $Value): $Value {
    $SelectField($SelectField($ResourceValue($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), preburn_address), $Libra_Preburn_to_burn), $Libra_Libra_value)
}

function {:inline} $Libra_preburn_value$56($Libra_Preburn_$memory: $Memory, $tv0: $TypeValue, preburn_address: $Value): $Value {
    $SelectField($SelectField($ResourceValue($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), preburn_address), $Libra_Preburn_to_burn), $Libra_Libra_value)
}

function {:inline} $Libra_total_preburn_value$57($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue): $Value {
    $SelectField($ResourceValue($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_preburn_value)
}

function {:inline} $Libra_info$58($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue): $Value {
    $Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0)
}

function {:inline} $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue): $Value {
    $Libra_spec_lbr_exchange_rate($Libra_CurrencyInfo_$memory, $tv0)
}

function {:inline} $Libra_currency_info$60($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue): $Value {
    $ResourceValue($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())
}

function {:inline} $Libra_preburn$61($Libra_Preburn_$memory: $Memory, $tv0: $TypeValue, account: $Value): $Value {
    $ResourceValue($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(account))
}

function {:inline} $Libra_info$62($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue): $Value {
    $Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0)
}



// ** structs of module Libra

const unique $Libra_Libra: $TypeName;
const $Libra_Libra_value: $FieldName;
axiom $Libra_Libra_value == 0;
function $Libra_Libra_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($Libra_Libra, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1))
}
var $Libra_Libra_$memory: $Memory;
var $Libra_Libra_$memory_$old: $Memory;
function {:inline} $Libra_Libra_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $Libra_Libra_value))
}
function {:inline} $Libra_Libra_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $Libra_Libra_$is_well_formed($this: $Value): bool {
    $Libra_Libra_$is_well_typed($this) && $Libra_Libra_$invariant_holds($this)}

procedure {:inline 1} $Libra_Libra_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, value: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(value);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := value], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Libra_Libra_unpack($tv0: $TypeValue, $struct: $Value) returns (value: $Value)
{
    assume is#$Vector($struct);
    value := $SelectField($struct, $Libra_Libra_value);
    assume $IsValidU64(value);
}

const unique $Libra_BurnCapability: $TypeName;
const $Libra_BurnCapability_dummy_field: $FieldName;
axiom $Libra_BurnCapability_dummy_field == 0;
function $Libra_BurnCapability_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($Libra_BurnCapability, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1))
}
var $Libra_BurnCapability_$memory: $Memory;
var $Libra_BurnCapability_$memory_$old: $Memory;
function {:inline} $Libra_BurnCapability_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $Libra_BurnCapability_dummy_field))
}
function {:inline} $Libra_BurnCapability_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $Libra_BurnCapability_$is_well_formed($this: $Value): bool {
    $Libra_BurnCapability_$is_well_typed($this) && $Libra_BurnCapability_$invariant_holds($this)}

procedure {:inline 1} $Libra_BurnCapability_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Libra_BurnCapability_unpack($tv0: $TypeValue, $struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $Libra_BurnCapability_dummy_field);
    assume is#$Boolean(dummy_field);
}

const unique $Libra_BurnEvent: $TypeName;
const $Libra_BurnEvent_amount: $FieldName;
axiom $Libra_BurnEvent_amount == 0;
const $Libra_BurnEvent_currency_code: $FieldName;
axiom $Libra_BurnEvent_currency_code == 1;
const $Libra_BurnEvent_preburn_address: $FieldName;
axiom $Libra_BurnEvent_preburn_address == 2;
function $Libra_BurnEvent_type_value(): $TypeValue {
    $StructType($Libra_BurnEvent, $EmptyTypeValueArray)
}
var $Libra_BurnEvent_$memory: $Memory;
var $Libra_BurnEvent_$memory_$old: $Memory;
function {:inline} $Libra_BurnEvent_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 3
      && $IsValidU64($SelectField($this, $Libra_BurnEvent_amount))
      && $Vector_$is_well_formed($SelectField($this, $Libra_BurnEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $Libra_BurnEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_BurnEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_BurnEvent_currency_code),$$0)))
      && is#$Address($SelectField($this, $Libra_BurnEvent_preburn_address))
}
function {:inline} $Libra_BurnEvent_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $Libra_BurnEvent_$is_well_formed($this: $Value): bool {
    $Libra_BurnEvent_$is_well_typed($this) && $Libra_BurnEvent_$invariant_holds($this)}

procedure {:inline 1} $Libra_BurnEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value, preburn_address: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(amount);
    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    assume is#$Address(preburn_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := amount][1 := currency_code][2 := preburn_address], 3));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Libra_BurnEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value, preburn_address: $Value)
{
    assume is#$Vector($struct);
    amount := $SelectField($struct, $Libra_BurnEvent_amount);
    assume $IsValidU64(amount);
    currency_code := $SelectField($struct, $Libra_BurnEvent_currency_code);
    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    preburn_address := $SelectField($struct, $Libra_BurnEvent_preburn_address);
    assume is#$Address(preburn_address);
}

const unique $Libra_CancelBurnEvent: $TypeName;
const $Libra_CancelBurnEvent_amount: $FieldName;
axiom $Libra_CancelBurnEvent_amount == 0;
const $Libra_CancelBurnEvent_currency_code: $FieldName;
axiom $Libra_CancelBurnEvent_currency_code == 1;
const $Libra_CancelBurnEvent_preburn_address: $FieldName;
axiom $Libra_CancelBurnEvent_preburn_address == 2;
function $Libra_CancelBurnEvent_type_value(): $TypeValue {
    $StructType($Libra_CancelBurnEvent, $EmptyTypeValueArray)
}
var $Libra_CancelBurnEvent_$memory: $Memory;
var $Libra_CancelBurnEvent_$memory_$old: $Memory;
function {:inline} $Libra_CancelBurnEvent_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 3
      && $IsValidU64($SelectField($this, $Libra_CancelBurnEvent_amount))
      && $Vector_$is_well_formed($SelectField($this, $Libra_CancelBurnEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $Libra_CancelBurnEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_CancelBurnEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_CancelBurnEvent_currency_code),$$0)))
      && is#$Address($SelectField($this, $Libra_CancelBurnEvent_preburn_address))
}
function {:inline} $Libra_CancelBurnEvent_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $Libra_CancelBurnEvent_$is_well_formed($this: $Value): bool {
    $Libra_CancelBurnEvent_$is_well_typed($this) && $Libra_CancelBurnEvent_$invariant_holds($this)}

procedure {:inline 1} $Libra_CancelBurnEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value, preburn_address: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(amount);
    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    assume is#$Address(preburn_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := amount][1 := currency_code][2 := preburn_address], 3));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Libra_CancelBurnEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value, preburn_address: $Value)
{
    assume is#$Vector($struct);
    amount := $SelectField($struct, $Libra_CancelBurnEvent_amount);
    assume $IsValidU64(amount);
    currency_code := $SelectField($struct, $Libra_CancelBurnEvent_currency_code);
    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    preburn_address := $SelectField($struct, $Libra_CancelBurnEvent_preburn_address);
    assume is#$Address(preburn_address);
}

const unique $Libra_CurrencyInfo: $TypeName;
const $Libra_CurrencyInfo_total_value: $FieldName;
axiom $Libra_CurrencyInfo_total_value == 0;
const $Libra_CurrencyInfo_preburn_value: $FieldName;
axiom $Libra_CurrencyInfo_preburn_value == 1;
const $Libra_CurrencyInfo_to_lbr_exchange_rate: $FieldName;
axiom $Libra_CurrencyInfo_to_lbr_exchange_rate == 2;
const $Libra_CurrencyInfo_is_synthetic: $FieldName;
axiom $Libra_CurrencyInfo_is_synthetic == 3;
const $Libra_CurrencyInfo_scaling_factor: $FieldName;
axiom $Libra_CurrencyInfo_scaling_factor == 4;
const $Libra_CurrencyInfo_fractional_part: $FieldName;
axiom $Libra_CurrencyInfo_fractional_part == 5;
const $Libra_CurrencyInfo_currency_code: $FieldName;
axiom $Libra_CurrencyInfo_currency_code == 6;
const $Libra_CurrencyInfo_can_mint: $FieldName;
axiom $Libra_CurrencyInfo_can_mint == 7;
const $Libra_CurrencyInfo_mint_events: $FieldName;
axiom $Libra_CurrencyInfo_mint_events == 8;
const $Libra_CurrencyInfo_burn_events: $FieldName;
axiom $Libra_CurrencyInfo_burn_events == 9;
const $Libra_CurrencyInfo_preburn_events: $FieldName;
axiom $Libra_CurrencyInfo_preburn_events == 10;
const $Libra_CurrencyInfo_cancel_burn_events: $FieldName;
axiom $Libra_CurrencyInfo_cancel_burn_events == 11;
const $Libra_CurrencyInfo_exchange_rate_update_events: $FieldName;
axiom $Libra_CurrencyInfo_exchange_rate_update_events == 12;
function $Libra_CurrencyInfo_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($Libra_CurrencyInfo, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1))
}
var $Libra_CurrencyInfo_$memory: $Memory;
var $Libra_CurrencyInfo_$memory_$old: $Memory;
function {:inline} $Libra_CurrencyInfo_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 13
      && $IsValidU128($SelectField($this, $Libra_CurrencyInfo_total_value))
      && $IsValidU64($SelectField($this, $Libra_CurrencyInfo_preburn_value))
      && $FixedPoint32_FixedPoint32_$is_well_typed($SelectField($this, $Libra_CurrencyInfo_to_lbr_exchange_rate))
      && is#$Boolean($SelectField($this, $Libra_CurrencyInfo_is_synthetic))
      && $IsValidU64($SelectField($this, $Libra_CurrencyInfo_scaling_factor))
      && $IsValidU64($SelectField($this, $Libra_CurrencyInfo_fractional_part))
      && $Vector_$is_well_formed($SelectField($this, $Libra_CurrencyInfo_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $Libra_CurrencyInfo_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_CurrencyInfo_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_CurrencyInfo_currency_code),$$0)))
      && is#$Boolean($SelectField($this, $Libra_CurrencyInfo_can_mint))
      && $Event_EventHandle_$is_well_typed($SelectField($this, $Libra_CurrencyInfo_mint_events))
      && $Event_EventHandle_$is_well_typed($SelectField($this, $Libra_CurrencyInfo_burn_events))
      && $Event_EventHandle_$is_well_typed($SelectField($this, $Libra_CurrencyInfo_preburn_events))
      && $Event_EventHandle_$is_well_typed($SelectField($this, $Libra_CurrencyInfo_cancel_burn_events))
      && $Event_EventHandle_$is_well_typed($SelectField($this, $Libra_CurrencyInfo_exchange_rate_update_events))
}
function {:inline} $Libra_CurrencyInfo_$invariant_holds($this: $Value): bool {
    $FixedPoint32_FixedPoint32_$invariant_holds($SelectField($this, $Libra_CurrencyInfo_to_lbr_exchange_rate))
      && $Event_EventHandle_$invariant_holds($SelectField($this, $Libra_CurrencyInfo_mint_events))
      && $Event_EventHandle_$invariant_holds($SelectField($this, $Libra_CurrencyInfo_burn_events))
      && $Event_EventHandle_$invariant_holds($SelectField($this, $Libra_CurrencyInfo_preburn_events))
      && $Event_EventHandle_$invariant_holds($SelectField($this, $Libra_CurrencyInfo_cancel_burn_events))
      && $Event_EventHandle_$invariant_holds($SelectField($this, $Libra_CurrencyInfo_exchange_rate_update_events))
      && b#$Boolean($Boolean(b#$Boolean($Boolean(i#$Integer($Integer(0)) < i#$Integer($SelectField($this, $Libra_CurrencyInfo_scaling_factor)))) && b#$Boolean($Boolean(i#$Integer($SelectField($this, $Libra_CurrencyInfo_scaling_factor)) <= i#$Integer($Integer(10000000000))))))
}

function {:inline} $Libra_CurrencyInfo_$is_well_formed($this: $Value): bool {
    $Libra_CurrencyInfo_$is_well_typed($this) && $Libra_CurrencyInfo_$invariant_holds($this)}

procedure {:inline 1} $Libra_CurrencyInfo_$unpack_ref_deep($tv0: $TypeValue, $before: $Value) {
    assume $Libra_CurrencyInfo_$invariant_holds($before);
}

procedure {:inline 1} $Libra_CurrencyInfo_$unpack_ref($tv0: $TypeValue, $before: $Value) {
    assume $Libra_CurrencyInfo_$invariant_holds($before);
}

procedure {:inline 1} $Libra_CurrencyInfo_$pack_ref_deep($tv0: $TypeValue, $after: $Value) {
    assert b#$Boolean($Boolean(b#$Boolean($Boolean(i#$Integer($Integer(0)) < i#$Integer($SelectField($after, $Libra_CurrencyInfo_scaling_factor)))) && b#$Boolean($Boolean(i#$Integer($SelectField($after, $Libra_CurrencyInfo_scaling_factor)) <= i#$Integer($Integer(10000000000))))));
}

procedure {:inline 1} $Libra_CurrencyInfo_$pack_ref($tv0: $TypeValue, $after: $Value) {
    assert b#$Boolean($Boolean(b#$Boolean($Boolean(i#$Integer($Integer(0)) < i#$Integer($SelectField($after, $Libra_CurrencyInfo_scaling_factor)))) && b#$Boolean($Boolean(i#$Integer($SelectField($after, $Libra_CurrencyInfo_scaling_factor)) <= i#$Integer($Integer(10000000000))))));
}

procedure {:inline 1} $Libra_CurrencyInfo_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, total_value: $Value, preburn_value: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value, can_mint: $Value, mint_events: $Value, burn_events: $Value, preburn_events: $Value, cancel_burn_events: $Value, exchange_rate_update_events: $Value) returns ($struct: $Value)
{
    assume $IsValidU128(total_value);
    assume $IsValidU64(preburn_value);
    assume $FixedPoint32_FixedPoint32_$is_well_formed(to_lbr_exchange_rate);
    assume is#$Boolean(is_synthetic);
    assume $IsValidU64(scaling_factor);
    assume $IsValidU64(fractional_part);
    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    assume is#$Boolean(can_mint);
    assume $Event_EventHandle_$is_well_formed(mint_events);
    assume $Event_EventHandle_$is_well_formed(burn_events);
    assume $Event_EventHandle_$is_well_formed(preburn_events);
    assume $Event_EventHandle_$is_well_formed(cancel_burn_events);
    assume $Event_EventHandle_$is_well_formed(exchange_rate_update_events);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := total_value][1 := preburn_value][2 := to_lbr_exchange_rate][3 := is_synthetic][4 := scaling_factor][5 := fractional_part][6 := currency_code][7 := can_mint][8 := mint_events][9 := burn_events][10 := preburn_events][11 := cancel_burn_events][12 := exchange_rate_update_events], 13));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
    assert b#$Boolean($Boolean(b#$Boolean($Boolean(i#$Integer($Integer(0)) < i#$Integer($SelectField($struct, $Libra_CurrencyInfo_scaling_factor)))) && b#$Boolean($Boolean(i#$Integer($SelectField($struct, $Libra_CurrencyInfo_scaling_factor)) <= i#$Integer($Integer(10000000000))))));
}

procedure {:inline 1} $Libra_CurrencyInfo_unpack($tv0: $TypeValue, $struct: $Value) returns (total_value: $Value, preburn_value: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value, can_mint: $Value, mint_events: $Value, burn_events: $Value, preburn_events: $Value, cancel_burn_events: $Value, exchange_rate_update_events: $Value)
{
    assume is#$Vector($struct);
    total_value := $SelectField($struct, $Libra_CurrencyInfo_total_value);
    assume $IsValidU128(total_value);
    preburn_value := $SelectField($struct, $Libra_CurrencyInfo_preburn_value);
    assume $IsValidU64(preburn_value);
    to_lbr_exchange_rate := $SelectField($struct, $Libra_CurrencyInfo_to_lbr_exchange_rate);
    assume $FixedPoint32_FixedPoint32_$is_well_formed(to_lbr_exchange_rate);
    is_synthetic := $SelectField($struct, $Libra_CurrencyInfo_is_synthetic);
    assume is#$Boolean(is_synthetic);
    scaling_factor := $SelectField($struct, $Libra_CurrencyInfo_scaling_factor);
    assume $IsValidU64(scaling_factor);
    fractional_part := $SelectField($struct, $Libra_CurrencyInfo_fractional_part);
    assume $IsValidU64(fractional_part);
    currency_code := $SelectField($struct, $Libra_CurrencyInfo_currency_code);
    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    can_mint := $SelectField($struct, $Libra_CurrencyInfo_can_mint);
    assume is#$Boolean(can_mint);
    mint_events := $SelectField($struct, $Libra_CurrencyInfo_mint_events);
    assume $Event_EventHandle_$is_well_formed(mint_events);
    burn_events := $SelectField($struct, $Libra_CurrencyInfo_burn_events);
    assume $Event_EventHandle_$is_well_formed(burn_events);
    preburn_events := $SelectField($struct, $Libra_CurrencyInfo_preburn_events);
    assume $Event_EventHandle_$is_well_formed(preburn_events);
    cancel_burn_events := $SelectField($struct, $Libra_CurrencyInfo_cancel_burn_events);
    assume $Event_EventHandle_$is_well_formed(cancel_burn_events);
    exchange_rate_update_events := $SelectField($struct, $Libra_CurrencyInfo_exchange_rate_update_events);
    assume $Event_EventHandle_$is_well_formed(exchange_rate_update_events);
}

const unique $Libra_MintCapability: $TypeName;
const $Libra_MintCapability_dummy_field: $FieldName;
axiom $Libra_MintCapability_dummy_field == 0;
function $Libra_MintCapability_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($Libra_MintCapability, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1))
}
var $Libra_MintCapability_$memory: $Memory;
var $Libra_MintCapability_$memory_$old: $Memory;
function {:inline} $Libra_MintCapability_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $Libra_MintCapability_dummy_field))
}
function {:inline} $Libra_MintCapability_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $Libra_MintCapability_$is_well_formed($this: $Value): bool {
    $Libra_MintCapability_$is_well_typed($this) && $Libra_MintCapability_$invariant_holds($this)}

procedure {:inline 1} $Libra_MintCapability_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Libra_MintCapability_unpack($tv0: $TypeValue, $struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $Libra_MintCapability_dummy_field);
    assume is#$Boolean(dummy_field);
}

const unique $Libra_MintEvent: $TypeName;
const $Libra_MintEvent_amount: $FieldName;
axiom $Libra_MintEvent_amount == 0;
const $Libra_MintEvent_currency_code: $FieldName;
axiom $Libra_MintEvent_currency_code == 1;
function $Libra_MintEvent_type_value(): $TypeValue {
    $StructType($Libra_MintEvent, $EmptyTypeValueArray)
}
var $Libra_MintEvent_$memory: $Memory;
var $Libra_MintEvent_$memory_$old: $Memory;
function {:inline} $Libra_MintEvent_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 2
      && $IsValidU64($SelectField($this, $Libra_MintEvent_amount))
      && $Vector_$is_well_formed($SelectField($this, $Libra_MintEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $Libra_MintEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_MintEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_MintEvent_currency_code),$$0)))
}
function {:inline} $Libra_MintEvent_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $Libra_MintEvent_$is_well_formed($this: $Value): bool {
    $Libra_MintEvent_$is_well_typed($this) && $Libra_MintEvent_$invariant_holds($this)}

procedure {:inline 1} $Libra_MintEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(amount);
    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := amount][1 := currency_code], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Libra_MintEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value)
{
    assume is#$Vector($struct);
    amount := $SelectField($struct, $Libra_MintEvent_amount);
    assume $IsValidU64(amount);
    currency_code := $SelectField($struct, $Libra_MintEvent_currency_code);
    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
}

const unique $Libra_Preburn: $TypeName;
const $Libra_Preburn_to_burn: $FieldName;
axiom $Libra_Preburn_to_burn == 0;
function $Libra_Preburn_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($Libra_Preburn, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1))
}
var $Libra_Preburn_$memory: $Memory;
var $Libra_Preburn_$memory_$old: $Memory;
function {:inline} $Libra_Preburn_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && $Libra_Libra_$is_well_typed($SelectField($this, $Libra_Preburn_to_burn))
}
function {:inline} $Libra_Preburn_$invariant_holds($this: $Value): bool {
    $Libra_Libra_$invariant_holds($SelectField($this, $Libra_Preburn_to_burn))
}

function {:inline} $Libra_Preburn_$is_well_formed($this: $Value): bool {
    $Libra_Preburn_$is_well_typed($this) && $Libra_Preburn_$invariant_holds($this)}

procedure {:inline 1} $Libra_Preburn_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, to_burn: $Value) returns ($struct: $Value)
{
    assume $Libra_Libra_$is_well_formed(to_burn);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := to_burn], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Libra_Preburn_unpack($tv0: $TypeValue, $struct: $Value) returns (to_burn: $Value)
{
    assume is#$Vector($struct);
    to_burn := $SelectField($struct, $Libra_Preburn_to_burn);
    assume $Libra_Libra_$is_well_formed(to_burn);
}

const unique $Libra_PreburnEvent: $TypeName;
const $Libra_PreburnEvent_amount: $FieldName;
axiom $Libra_PreburnEvent_amount == 0;
const $Libra_PreburnEvent_currency_code: $FieldName;
axiom $Libra_PreburnEvent_currency_code == 1;
const $Libra_PreburnEvent_preburn_address: $FieldName;
axiom $Libra_PreburnEvent_preburn_address == 2;
function $Libra_PreburnEvent_type_value(): $TypeValue {
    $StructType($Libra_PreburnEvent, $EmptyTypeValueArray)
}
var $Libra_PreburnEvent_$memory: $Memory;
var $Libra_PreburnEvent_$memory_$old: $Memory;
function {:inline} $Libra_PreburnEvent_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 3
      && $IsValidU64($SelectField($this, $Libra_PreburnEvent_amount))
      && $Vector_$is_well_formed($SelectField($this, $Libra_PreburnEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $Libra_PreburnEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_PreburnEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_PreburnEvent_currency_code),$$0)))
      && is#$Address($SelectField($this, $Libra_PreburnEvent_preburn_address))
}
function {:inline} $Libra_PreburnEvent_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $Libra_PreburnEvent_$is_well_formed($this: $Value): bool {
    $Libra_PreburnEvent_$is_well_typed($this) && $Libra_PreburnEvent_$invariant_holds($this)}

procedure {:inline 1} $Libra_PreburnEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value, preburn_address: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(amount);
    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    assume is#$Address(preburn_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := amount][1 := currency_code][2 := preburn_address], 3));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Libra_PreburnEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value, preburn_address: $Value)
{
    assume is#$Vector($struct);
    amount := $SelectField($struct, $Libra_PreburnEvent_amount);
    assume $IsValidU64(amount);
    currency_code := $SelectField($struct, $Libra_PreburnEvent_currency_code);
    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    preburn_address := $SelectField($struct, $Libra_PreburnEvent_preburn_address);
    assume is#$Address(preburn_address);
}

const unique $Libra_ToLBRExchangeRateUpdateEvent: $TypeName;
const $Libra_ToLBRExchangeRateUpdateEvent_currency_code: $FieldName;
axiom $Libra_ToLBRExchangeRateUpdateEvent_currency_code == 0;
const $Libra_ToLBRExchangeRateUpdateEvent_new_to_lbr_exchange_rate: $FieldName;
axiom $Libra_ToLBRExchangeRateUpdateEvent_new_to_lbr_exchange_rate == 1;
function $Libra_ToLBRExchangeRateUpdateEvent_type_value(): $TypeValue {
    $StructType($Libra_ToLBRExchangeRateUpdateEvent, $EmptyTypeValueArray)
}
var $Libra_ToLBRExchangeRateUpdateEvent_$memory: $Memory;
var $Libra_ToLBRExchangeRateUpdateEvent_$memory_$old: $Memory;
function {:inline} $Libra_ToLBRExchangeRateUpdateEvent_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 2
      && $Vector_$is_well_formed($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_currency_code),$$0)))
      && $IsValidU64($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_new_to_lbr_exchange_rate))
}
function {:inline} $Libra_ToLBRExchangeRateUpdateEvent_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $Libra_ToLBRExchangeRateUpdateEvent_$is_well_formed($this: $Value): bool {
    $Libra_ToLBRExchangeRateUpdateEvent_$is_well_typed($this) && $Libra_ToLBRExchangeRateUpdateEvent_$invariant_holds($this)}

procedure {:inline 1} $Libra_ToLBRExchangeRateUpdateEvent_pack($file_id: int, $byte_index: int, $var_idx: int, currency_code: $Value, new_to_lbr_exchange_rate: $Value) returns ($struct: $Value)
{
    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    assume $IsValidU64(new_to_lbr_exchange_rate);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := currency_code][1 := new_to_lbr_exchange_rate], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Libra_ToLBRExchangeRateUpdateEvent_unpack($struct: $Value) returns (currency_code: $Value, new_to_lbr_exchange_rate: $Value)
{
    assume is#$Vector($struct);
    currency_code := $SelectField($struct, $Libra_ToLBRExchangeRateUpdateEvent_currency_code);
    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    new_to_lbr_exchange_rate := $SelectField($struct, $Libra_ToLBRExchangeRateUpdateEvent_new_to_lbr_exchange_rate);
    assume $IsValidU64(new_to_lbr_exchange_rate);
}



// ** functions of module Libra

procedure {:inline 1} $Libra_initialize_$def(config_account: $Value) returns ()
{
    // declare local variables
    var $t1: $Value; // $AddressType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 10491, 0, config_account); }

    // bytecode translation starts here
    // $t1 := move(config_account)
    call $t1 := $CopyOrMoveValue(config_account);

    // LibraTimestamp::assert_genesis()
    call $LibraTimestamp_assert_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 10579, $abort_code);
      goto Abort;
    }

    // CoreAddresses::assert_libra_root($t1)
    call $CoreAddresses_assert_libra_root($t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 10654, $abort_code);
      goto Abort;
    }

    // RegisteredCurrencies::initialize($t1)
    call $RegisteredCurrencies_initialize($t1);
    if ($abort_flag) {
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Libra_initialize_$direct_inter(config_account: $Value) returns ()
{
    assume is#$Address(config_account);

    call $Libra_initialize_$def(config_account);
}


procedure {:inline 1} $Libra_initialize_$direct_intra(config_account: $Value) returns ()
{
    assume is#$Address(config_account);

    call $Libra_initialize_$def(config_account);
}


procedure {:inline 1} $Libra_initialize(config_account: $Value) returns ()
{
    assume is#$Address(config_account);

    call $Libra_initialize_$def(config_account);
}


procedure {:inline 1} $Libra_currency_code_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $Libra_CurrencyInfo_type_value($tv0)
    var $t2: $Value; // $Vector_type_value($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 50948, $abort_code);
      goto Abort;
    }

    // $t0 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t1 := get_global<Libra::CurrencyInfo<#0>>($t0)
    call $t1 := $GetGlobal($Libra_CurrencyInfo_$memory, $t0, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 47586, $abort_code);
      goto Abort;
    }

    // $t2 := get_field<Libra::CurrencyInfo<#0>>.currency_code($t1)
    call $t2 := $GetFieldFromValue($t1, $Libra_CurrencyInfo_currency_code);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(15, 47584, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_currency_code_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_currency_code)))));
ensures $Vector_$is_well_formed($ret0) && (forall $$0: int :: {$select_vector($ret0,$$0)} $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0,$$0)));

procedure {:inline 1} $Libra_currency_code_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_currency_code)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) <= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) >= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) >= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) <= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_to_lbr_exchange_rate), old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_to_lbr_exchange_rate))))))));
ensures $Vector_$is_well_formed($ret0) && (forall $$0: int :: {$select_vector($ret0,$$0)} $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0,$$0)));

procedure {:inline 1} $Libra_currency_code($tv0: $TypeValue) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_currency_code)))));
ensures $Vector_$is_well_formed($ret0) && (forall $$0: int :: {$select_vector($ret0,$$0)} $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0,$$0)));

procedure {:inline 1} $Libra_value_$def($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $Libra_Libra_type_value($tv0)
    var $t2: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 34425, 0, coin); }

    // bytecode translation starts here
    // $t1 := move(coin)
    call $t1 := $CopyOrMoveValue(coin);

    // $t2 := get_field<Libra::Libra<#0>>.value($t1)
    call $t2 := $GetFieldFromValue($t1, $Libra_Libra_value);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(15, 34491, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_value_$direct_inter($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_$is_well_formed(coin);

    call $ret0 := $Libra_value_$def($tv0, coin);
}


procedure {:inline 1} $Libra_value_$direct_intra($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_$is_well_formed(coin);

    call $ret0 := $Libra_value_$def($tv0, coin);
}


procedure {:inline 1} $Libra_value($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_$is_well_formed(coin);

    call $ret0 := $Libra_value_$def($tv0, coin);
}


procedure {:inline 1} $Libra_approx_lbr_for_coin_$def($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var from_value: $Value; // $IntegerType()
    var $t2: $Value; // $Libra_Libra_type_value($tv0)
    var $t3: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 45408, 0, coin); }

    // bytecode translation starts here
    // $t2 := move(coin)
    call $t2 := $CopyOrMoveValue(coin);

    // from_value := Libra::value<#0>($t2)
    call from_value := $Libra_value($tv0, $t2);
    if ($abort_flag) {
      goto Abort;
    }

    // $t3 := Libra::approx_lbr_for_value<#0>(from_value)
    call $t3 := $Libra_approx_lbr_for_value($tv0, from_value);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 44505, $abort_code);
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(15, 45560, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_approx_lbr_for_coin_$direct_inter($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_$is_well_formed(coin);

    call $ret0 := $Libra_approx_lbr_for_coin_$def($tv0, coin);
}


procedure {:inline 1} $Libra_approx_lbr_for_coin_$direct_intra($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_$is_well_formed(coin);

    call $ret0 := $Libra_approx_lbr_for_coin_$def($tv0, coin);
}


procedure {:inline 1} $Libra_approx_lbr_for_coin($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_$is_well_formed(coin);

    call $ret0 := $Libra_approx_lbr_for_coin_$def($tv0, coin);
}


procedure {:inline 1} $Libra_approx_lbr_for_value_$def($tv0: $TypeValue, from_value: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var lbr_exchange_rate: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 44494, 0, from_value); }

    // bytecode translation starts here
    // $t2 := move(from_value)
    call $t2 := $CopyOrMoveValue(from_value);

    // lbr_exchange_rate := Libra::lbr_exchange_rate<#0>()
    call lbr_exchange_rate := $Libra_lbr_exchange_rate($tv0);
    if ($abort_flag) {
      goto Abort;
    }

    // $t3 := FixedPoint32::multiply_u64($t2, lbr_exchange_rate)
    call $t3 := $FixedPoint32_multiply_u64($t2, lbr_exchange_rate);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 44679, $abort_code);
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(15, 44665, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_approx_lbr_for_value_$direct_inter($tv0: $TypeValue, from_value: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(from_value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(from_value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(from_value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Libra_spec_approx_lbr_for_value($Libra_CurrencyInfo_$memory, $tv0, from_value)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Libra_approx_lbr_for_value_$direct_intra($tv0: $TypeValue, from_value: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(from_value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(from_value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(from_value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Libra_spec_approx_lbr_for_value($Libra_CurrencyInfo_$memory, $tv0, from_value)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) <= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) >= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) >= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) <= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_to_lbr_exchange_rate), old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_to_lbr_exchange_rate))))))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Libra_approx_lbr_for_value($tv0: $TypeValue, from_value: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(from_value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(from_value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(from_value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Libra_spec_approx_lbr_for_value($Libra_CurrencyInfo_$memory, $tv0, from_value)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $Libra_assert_is_SCS_currency_$def($tv0: $TypeValue) returns ()
{
    // declare local variables
    var tmp#$0: $Value; // $BooleanType()
    var tmp#$1: $Value; // $IntegerType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 50948, $abort_code);
      goto Abort;
    }

    // $t2 := Libra::is_SCS_currency<#0>()
    call $t2 := $Libra_is_SCS_currency($tv0);
    if ($abort_flag) {
      goto Abort;
    }

    // $t3 := 1
    $t3 := $Integer(1);

    // $t4 := Errors::invalid_state($t3)
    call $t4 := $Errors_invalid_state($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 51472, $abort_code);
      goto Abort;
    }

    // if ($t2) goto L0 else goto L1
    if (b#$Boolean($t2)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t4)
    if (true) { assume $DebugTrackAbort(15, 51428, i#$Integer($t4)); }
    $abort_code := i#$Integer($t4);
    goto Abort;

    // L0:
L0:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Libra_assert_is_SCS_currency_$direct_inter($tv0: $TypeValue) returns ()
{
    call $Libra_assert_is_SCS_currency_$def($tv0);
}


procedure {:inline 1} $Libra_assert_is_SCS_currency_$direct_intra($tv0: $TypeValue) returns ()
{
    call $Libra_assert_is_SCS_currency_$def($tv0);
}


procedure {:inline 1} $Libra_assert_is_SCS_currency($tv0: $TypeValue) returns ()
{
    call $Libra_assert_is_SCS_currency_$def($tv0);
}


procedure {:inline 1} $Libra_assert_is_currency_$def($tv0: $TypeValue) returns ()
{
    // declare local variables
    var tmp#$0: $Value; // $BooleanType()
    var tmp#$1: $Value; // $IntegerType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t2 := Libra::is_currency<#0>()
    call $t2 := $Libra_is_currency($tv0);
    if ($abort_flag) {
      goto Abort;
    }

    // $t3 := 1
    $t3 := $Integer(1);

    // $t4 := Errors::not_published($t3)
    call $t4 := $Errors_not_published($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 51029, $abort_code);
      goto Abort;
    }

    // if ($t2) goto L0 else goto L1
    if (b#$Boolean($t2)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t4)
    if (true) { assume $DebugTrackAbort(15, 50989, i#$Integer($t4)); }
    $abort_code := i#$Integer($t4);
    goto Abort;

    // L0:
L0:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Libra_assert_is_currency_$direct_inter($tv0: $TypeValue) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5))));

procedure {:inline 1} $Libra_assert_is_currency_$direct_intra($tv0: $TypeValue) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) <= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) >= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) >= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) <= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_to_lbr_exchange_rate), old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_to_lbr_exchange_rate))))))));

procedure {:inline 1} $Libra_assert_is_currency($tv0: $TypeValue) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5))));

procedure {:inline 1} $Libra_burn_$def($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ()
{
    // declare local variables
    var addr: $Value; // $AddressType()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $Libra_BurnCapability_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 13313, 0, account); }
    if (true) { assume $DebugTrackLocal(15, 13313, 1, preburn_address); }

    // bytecode translation starts here
    // $t5 := move(account)
    call $t5 := $CopyOrMoveValue(account);

    // $t6 := move(preburn_address)
    call $t6 := $CopyOrMoveValue(preburn_address);

    // addr := Signer::address_of($t5)
    call addr := $Signer_address_of($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 13481, $abort_code);
      goto Abort;
    }

    // $t7 := exists<Libra::BurnCapability<#0>>(addr)
    $t7 := $ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr);

    // $t8 := 0
    $t8 := $Integer(0);

    // $t9 := Errors::requires_capability($t8)
    call $t9 := $Errors_requires_capability($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 13565, $abort_code);
      goto Abort;
    }

    // if ($t7) goto L0 else goto L1
    if (b#$Boolean($t7)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t9)
    if (true) { assume $DebugTrackAbort(15, 13510, i#$Integer($t9)); }
    $abort_code := i#$Integer($t9);
    goto Abort;

    // L0:
L0:

    // $t10 := get_global<Libra::BurnCapability<#0>>(addr)
    call $t10 := $GetGlobal($Libra_BurnCapability_$memory, addr, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 13676, $abort_code);
      goto Abort;
    }

    // Libra::burn_with_capability<#0>($t6, $t10)
    call $Libra_burn_with_capability($tv0, $t6, $t10);
    if ($abort_flag) {
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Libra_burn_$direct_inter($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ()
{
    assume is#$Address(account);

    assume is#$Address(preburn_address);

    call $Libra_burn_$def($tv0, account, preburn_address);
}


procedure {:inline 1} $Libra_burn_$direct_intra($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ()
{
    assume is#$Address(account);

    assume is#$Address(preburn_address);

    call $Libra_burn_$def($tv0, account, preburn_address);
}


procedure {:inline 1} $Libra_burn($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ()
{
    assume is#$Address(account);

    assume is#$Address(preburn_address);

    call $Libra_burn_$def($tv0, account, preburn_address);
}


procedure {:inline 1} $Libra_burn_now_$def($tv0: $TypeValue, coin: $Value, preburn: $Value, preburn_address: $Value, capability: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var $t6: $Value; // $Libra_Libra_type_value($tv0)
    var $t7: $Value; // $Libra_Preburn_type_value($tv0)
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $Libra_BurnCapability_type_value($tv0)
    var $t10: $Mutation; // ReferenceType($Libra_Preburn_type_value($tv0))
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $Libra_Preburn_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 31526, 0, coin); }
    if (true) { assume $DebugTrackLocal(15, 31526, 1, preburn); }
    if (true) { assume $DebugTrackLocal(15, 31526, 2, preburn_address); }
    if (true) { assume $DebugTrackLocal(15, 31526, 3, capability); }

    // bytecode translation starts here
    // $t6 := move(coin)
    call $t6 := $CopyOrMoveValue(coin);

    // $t7 := move(preburn)
    call $t7 := $CopyOrMoveValue(preburn);

    // $t8 := move(preburn_address)
    call $t8 := $CopyOrMoveValue(preburn_address);

    // $t9 := move(capability)
    call $t9 := $CopyOrMoveValue(capability);

    // $t10 := borrow_local($t7)
    call $t10 := $BorrowLoc(7, $t7);

    // unpack_ref($t10)

    // $t11 := get_field<Libra::Libra<#0>>.value($t6)
    call $t11 := $GetFieldFromValue($t6, $Libra_Libra_value);

    // $t12 := 0
    $t12 := $Integer(0);

    // $t13 := >($t11, $t12)
    call $t13 := $Gt($t11, $t12);

    // $t14 := 7
    $t14 := $Integer(7);

    // $t15 := Errors::invalid_argument($t14)
    call $t15 := $Errors_invalid_argument($t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 31778, $abort_code);
      goto Abort;
    }

    // if ($t13) goto L0 else goto L1
    if (b#$Boolean($t13)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t10)

    // pack_ref($t10)

    // destroy($t9)

    // abort($t15)
    if (true) { assume $DebugTrackAbort(15, 31747, i#$Integer($t15)); }
    $abort_code := i#$Integer($t15);
    goto Abort;

    // L0:
L0:

    // $t16 := read_ref($t10)
    call $t16 := $ReadRef($t10);
    assert $Libra_Preburn_$invariant_holds($t16);

    // $t16 := Libra::preburn_with_resource<#0>($t6, $t16, $t8)
    call $t16 := $Libra_preburn_with_resource($tv0, $t6, $t16, $t8);
    if ($abort_flag) {
      goto Abort;
    }

    // write_ref($t10, $t16)
    call $t10 := $WriteRef($t10, $t16);

    // $t16 := read_ref($t10)
    call $t16 := $ReadRef($t10);
    assert $Libra_Preburn_$invariant_holds($t16);

    // $t16 := Libra::burn_with_resource_cap<#0>($t16, $t8, $t9)
    call $t16 := $Libra_burn_with_resource_cap($tv0, $t16, $t8, $t9);
    if ($abort_flag) {
      goto Abort;
    }

    // write_ref($t10, $t16)
    call $t10 := $WriteRef($t10, $t16);

    // pack_ref($t10)

    // write_back[LocalRoot($t7)]($t10)
    call $t7 := $WritebackToValue($t10, 7, $t7);

    // return $t7
    $ret0 := $t7;
    if (true) { assume $DebugTrackLocal(15, 31935, 17, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_burn_now_$direct_inter($tv0: $TypeValue, coin: $Value, preburn: $Value, preburn_address: $Value, capability: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_$is_well_formed(coin);

    assume $Libra_Preburn_$is_well_formed(preburn);

    assume is#$Address(preburn_address);

    assume $Libra_BurnCapability_$is_well_formed(capability);

    call $ret0 := $Libra_burn_now_$def($tv0, coin, preburn, preburn_address, capability);
}


procedure {:inline 1} $Libra_burn_now_$direct_intra($tv0: $TypeValue, coin: $Value, preburn: $Value, preburn_address: $Value, capability: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_$is_well_formed(coin);

    assume $Libra_Preburn_$is_well_formed(preburn);

    assume is#$Address(preburn_address);

    assume $Libra_BurnCapability_$is_well_formed(capability);

    call $ret0 := $Libra_burn_now_$def($tv0, coin, preburn, preburn_address, capability);
}


procedure {:inline 1} $Libra_burn_now($tv0: $TypeValue, coin: $Value, preburn: $Value, preburn_address: $Value, capability: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_$is_well_formed(coin);

    assume $Libra_Preburn_$is_well_formed(preburn);

    assume is#$Address(preburn_address);

    assume $Libra_BurnCapability_$is_well_formed(capability);

    call $ret0 := $Libra_burn_now_$def($tv0, coin, preburn, preburn_address, capability);
}


procedure {:inline 1} $Libra_burn_with_capability_$def($tv0: $TypeValue, preburn_address: $Value, capability: $Value) returns ()
{
    // declare local variables
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $Libra_BurnCapability_type_value($tv0)
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Mutation; // ReferenceType($Libra_Preburn_type_value($tv0))
    var $t10: $Value; // $Libra_Preburn_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 24739, 0, preburn_address); }
    if (true) { assume $DebugTrackLocal(15, 24739, 1, capability); }

    // bytecode translation starts here
    // $t4 := move(preburn_address)
    call $t4 := $CopyOrMoveValue(preburn_address);

    // $t5 := move(capability)
    call $t5 := $CopyOrMoveValue(capability);

    // $t6 := exists<Libra::Preburn<#0>>($t4)
    $t6 := $ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t4);

    // $t7 := 2
    $t7 := $Integer(2);

    // $t8 := Errors::not_published($t7)
    call $t8 := $Errors_not_published($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 25024, $abort_code);
      goto Abort;
    }

    // if ($t6) goto L0 else goto L1
    if (b#$Boolean($t6)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t5)

    // abort($t8)
    if (true) { assume $DebugTrackAbort(15, 24965, i#$Integer($t8)); }
    $abort_code := i#$Integer($t8);
    goto Abort;

    // L0:
L0:

    // $t9 := borrow_global<Libra::Preburn<#0>>($t4)
    call $t9 := $BorrowGlobal($Libra_Preburn_$memory, $t4, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 25094, $abort_code);
      goto Abort;
    }

    // unpack_ref($t9)

    // $t10 := read_ref($t9)
    call $t10 := $ReadRef($t9);
    assert $Libra_Preburn_$invariant_holds($t10);

    // $t10 := Libra::burn_with_resource_cap<#0>($t10, $t4, $t5)
    call $t10 := $Libra_burn_with_resource_cap($tv0, $t10, $t4, $t5);
    if ($abort_flag) {
      goto Abort;
    }

    // write_ref($t9, $t10)
    call $t9 := $WriteRef($t9, $t10);

    // pack_ref($t9)

    // write_back[Libra::Preburn]($t9)
    call $Libra_Preburn_$memory := $WritebackToGlobal($Libra_Preburn_$memory, $t9);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Libra_burn_with_capability_$direct_inter($tv0: $TypeValue, preburn_address: $Value, capability: $Value) returns ()
{
    assume is#$Address(preburn_address);

    assume $Libra_BurnCapability_$is_well_formed(capability);

    call $Libra_burn_with_capability_$def($tv0, preburn_address, capability);
}


procedure {:inline 1} $Libra_burn_with_capability_$direct_intra($tv0: $TypeValue, preburn_address: $Value, capability: $Value) returns ()
{
    assume is#$Address(preburn_address);

    assume $Libra_BurnCapability_$is_well_formed(capability);

    call $Libra_burn_with_capability_$def($tv0, preburn_address, capability);
}


procedure {:inline 1} $Libra_burn_with_capability($tv0: $TypeValue, preburn_address: $Value, capability: $Value) returns ()
{
    assume is#$Address(preburn_address);

    assume $Libra_BurnCapability_$is_well_formed(capability);

    call $Libra_burn_with_capability_$def($tv0, preburn_address, capability);
}


procedure {:inline 1} $Libra_burn_with_resource_cap_$def($tv0: $TypeValue, preburn: $Value, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var currency_code: $Value; // $Vector_type_value($IntegerType())
    var info: $Mutation; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var tmp#$5: $Value; // $BooleanType()
    var tmp#$6: $Value; // $IntegerType()
    var tmp#$7: $Value; // $BooleanType()
    var tmp#$8: $Value; // $IntegerType()
    var tmp#$9: $Value; // $BooleanType()
    var tmp#$10: $Value; // $IntegerType()
    var value: $Value; // $IntegerType()
    var $t12: $Value; // $Libra_Preburn_type_value($tv0)
    var $t13: $Value; // $AddressType()
    var $t14: $Mutation; // ReferenceType($Libra_Preburn_type_value($tv0))
    var $t15: $Value; // $Libra_Libra_type_value($tv0)
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $BooleanType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Mutation; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t22: $Value; // $Libra_Libra_type_value($tv0)
    var $t23: $Value; // $Libra_Libra_type_value($tv0)
    var $t24: $Value; // $AddressType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $BooleanType()
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $IntegerType()
    var $t30: $Value; // $IntegerType()
    var $t31: $Value; // $IntegerType()
    var $t32: $Value; // $IntegerType()
    var $t33: $Mutation; // ReferenceType($IntegerType())
    var $t34: $Value; // $IntegerType()
    var $t35: $Value; // $BooleanType()
    var $t36: $Value; // $IntegerType()
    var $t37: $Value; // $IntegerType()
    var $t38: $Value; // $IntegerType()
    var $t39: $Value; // $IntegerType()
    var $t40: $Mutation; // ReferenceType($IntegerType())
    var $t41: $Value; // $BooleanType()
    var $t42: $Value; // $BooleanType()
    var $t43: $Mutation; // ReferenceType($Event_EventHandle_type_value($Libra_BurnEvent_type_value()))
    var $t44: $Value; // $Libra_BurnEvent_type_value()
    var $t45: $Value; // $Event_EventHandle_type_value($Libra_BurnEvent_type_value())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 25978, 0, preburn); }
    if (true) { assume $DebugTrackLocal(15, 25978, 1, preburn_address); }
    if (true) { assume $DebugTrackLocal(15, 25978, 2, _capability); }

    // bytecode translation starts here
    // $t12 := move(preburn)
    call $t12 := $CopyOrMoveValue(preburn);

    // $t13 := move(preburn_address)
    call $t13 := $CopyOrMoveValue(preburn_address);

    // $t14 := borrow_local($t12)
    call $t14 := $BorrowLoc(12, $t12);

    // currency_code := Libra::currency_code<#0>()
    call currency_code := $Libra_currency_code($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 47470, $abort_code);
      goto Abort;
    }

    // $t15 := get_field<Libra::Preburn<#0>>.to_burn($t14)
    call $t15 := $GetFieldFromReference($t14, $Libra_Preburn_to_burn);
    assert $Libra_Libra_$invariant_holds($t15);

    // $t16 := get_field<Libra::Libra<#0>>.value($t15)
    call $t16 := $GetFieldFromValue($t15, $Libra_Libra_value);

    // $t17 := 0
    $t17 := $Integer(0);

    // $t18 := >($t16, $t17)
    call $t18 := $Gt($t16, $t17);

    // $t19 := 4
    $t19 := $Integer(4);

    // $t20 := Errors::invalid_state($t19)
    call $t20 := $Errors_invalid_state($t19);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 26325, $abort_code);
      goto Abort;
    }

    // if ($t18) goto L0 else goto L1
    if (b#$Boolean($t18)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t14)

    // abort($t20)
    if (true) { assume $DebugTrackAbort(15, 26283, i#$Integer($t20)); }
    $abort_code := i#$Integer($t20);
    goto Abort;

    // L0:
L0:

    // $t21 := borrow_field<Libra::Preburn<#0>>.to_burn($t14)
    call $t21 := $BorrowField($t14, $Libra_Preburn_to_burn);

    // $t22 := read_ref($t21)
    call $t22 := $ReadRef($t21);
    assert $Libra_Libra_$invariant_holds($t22);

    // ($t23, $t22) := Libra::withdraw_all<#0>($t22)
    call $t23, $t22 := $Libra_withdraw_all($tv0, $t22);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 36326, $abort_code);
      goto Abort;
    }

    // write_ref($t21, $t22)
    call $t21 := $WriteRef($t21, $t22);
    if (true) { assume $DebugTrackLocal(15, 36326, 4, $Dereference(info)); }

    // write_back[Reference($t14)]($t21)
    call $t14 := $WritebackToReference($t21, $t14);

    // write_back[LocalRoot($t12)]($t14)
    call $t12 := $WritebackToValue($t14, 12, $t12);

    // value := unpack Libra::Libra<#0>($t23)
    call value := $Libra_Libra_unpack($tv0, $t23);
    if (true) { assume $DebugTrackLocal(15, 26413, 11, value); }

    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 50948, $abort_code);
      goto Abort;
    }

    // $t24 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t24 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // info := borrow_global<Libra::CurrencyInfo<#0>>($t24)
    call info := $BorrowGlobal($Libra_CurrencyInfo_$memory, $t24, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 26657, $abort_code);
      goto Abort;
    }

    // unpack_ref(info)
    call $Libra_CurrencyInfo_$unpack_ref($tv0, $Dereference(info));

    // $t25 := get_field<Libra::CurrencyInfo<#0>>.total_value(info)
    call $t25 := $GetFieldFromReference(info, $Libra_CurrencyInfo_total_value);

    // $t26 := (u128)(value)
    call $t26 := $CastU128(value);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 26775, $abort_code);
      goto Abort;
    }

    // $t27 := >=($t25, $t26)
    call $t27 := $Ge($t25, $t26);

    // $t28 := 1
    $t28 := $Integer(1);

    // $t29 := Errors::limit_exceeded($t28)
    call $t29 := $Errors_limit_exceeded($t28);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 26800, $abort_code);
      goto Abort;
    }

    // if ($t27) goto L2 else goto L3
    if (b#$Boolean($t27)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // destroy(info)

    // pack_ref(info)
    call $Libra_CurrencyInfo_$pack_ref($tv0, $Dereference(info));

    // abort($t29)
    if (true) { assume $DebugTrackAbort(15, 26748, i#$Integer($t29)); }
    $abort_code := i#$Integer($t29);
    goto Abort;

    // L2:
L2:

    // $t30 := get_field<Libra::CurrencyInfo<#0>>.total_value(info)
    call $t30 := $GetFieldFromReference(info, $Libra_CurrencyInfo_total_value);

    // $t31 := (u128)(value)
    call $t31 := $CastU128(value);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 26879, $abort_code);
      goto Abort;
    }

    // $t32 := -($t30, $t31)
    call $t32 := $Sub($t30, $t31);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 26877, $abort_code);
      goto Abort;
    }

    // $t33 := borrow_field<Libra::CurrencyInfo<#0>>.total_value(info)
    call $t33 := $BorrowField(info, $Libra_CurrencyInfo_total_value);

    // unpack_ref($t33)

    // write_ref($t33, $t32)
    call $t33 := $WriteRef($t33, $t32);
    if (true) { assume $DebugTrackLocal(15, 26841, 4, $Dereference(info)); }

    // pack_ref($t33)

    // write_back[Reference(info)]($t33)
    call info := $WritebackToReference($t33, info);

    // $t34 := get_field<Libra::CurrencyInfo<#0>>.preburn_value(info)
    call $t34 := $GetFieldFromReference(info, $Libra_CurrencyInfo_preburn_value);

    // $t35 := >=($t34, value)
    call $t35 := $Ge($t34, value);

    // $t36 := 2
    $t36 := $Integer(2);

    // $t37 := Errors::limit_exceeded($t36)
    call $t37 := $Errors_limit_exceeded($t36);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 26948, $abort_code);
      goto Abort;
    }

    // if ($t35) goto L4 else goto L5
    if (b#$Boolean($t35)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // destroy(info)

    // pack_ref(info)
    call $Libra_CurrencyInfo_$pack_ref($tv0, $Dereference(info));

    // write_back[Libra::CurrencyInfo](info)
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, info);

    // abort($t37)
    if (true) { assume $DebugTrackAbort(15, 26904, i#$Integer($t37)); }
    $abort_code := i#$Integer($t37);
    goto Abort;

    // L4:
L4:

    // $t38 := get_field<Libra::CurrencyInfo<#0>>.preburn_value(info)
    call $t38 := $GetFieldFromReference(info, $Libra_CurrencyInfo_preburn_value);

    // $t39 := -($t38, value)
    call $t39 := $Sub($t38, value);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 27023, $abort_code);
      goto Abort;
    }

    // $t40 := borrow_field<Libra::CurrencyInfo<#0>>.preburn_value(info)
    call $t40 := $BorrowField(info, $Libra_CurrencyInfo_preburn_value);

    // unpack_ref($t40)

    // write_ref($t40, $t39)
    call $t40 := $WriteRef($t40, $t39);
    if (true) { assume $DebugTrackLocal(15, 26983, 4, $Dereference(info)); }

    // pack_ref($t40)

    // write_back[Reference(info)]($t40)
    call info := $WritebackToReference($t40, info);

    // $t41 := get_field<Libra::CurrencyInfo<#0>>.is_synthetic(info)
    call $t41 := $GetFieldFromReference(info, $Libra_CurrencyInfo_is_synthetic);

    // $t42 := !($t41)
    call $t42 := $Not($t41);

    // if ($t42) goto L6 else goto L7
    if (b#$Boolean($t42)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // goto L8
    goto L8;

    // L6:
L6:

    // $t43 := borrow_field<Libra::CurrencyInfo<#0>>.burn_events(info)
    call $t43 := $BorrowField(info, $Libra_CurrencyInfo_burn_events);

    // unpack_ref($t43)

    // $t44 := pack Libra::BurnEvent(value, currency_code, $t13)
    call $t44 := $Libra_BurnEvent_pack(0, 0, 0, value, currency_code, $t13);

    // $t45 := read_ref($t43)
    call $t45 := $ReadRef($t43);
    assert $Event_EventHandle_$invariant_holds($t45);

    // $t45 := Event::emit_event<Libra::BurnEvent>($t45, $t44)
    call $t45 := $Event_emit_event($Libra_BurnEvent_type_value(), $t45, $t44);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 27144, $abort_code);
      goto Abort;
    }

    // write_ref($t43, $t45)
    call $t43 := $WriteRef($t43, $t45);
    if (true) { assume $DebugTrackLocal(15, 27144, 4, $Dereference(info)); }

    // pack_ref($t43)

    // write_back[Reference(info)]($t43)
    call info := $WritebackToReference($t43, info);

    // pack_ref(info)
    call $Libra_CurrencyInfo_$pack_ref($tv0, $Dereference(info));

    // write_back[Libra::CurrencyInfo](info)
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, info);

    // goto L9
    goto L9;

    // L8:
L8:

    // destroy(info)

    // pack_ref(info)
    call $Libra_CurrencyInfo_$pack_ref($tv0, $Dereference(info));

    // write_back[Libra::CurrencyInfo](info)
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, info);

    // goto L9
    goto L9;

    // L9:
L9:

    // return $t12
    $ret0 := $t12;
    if (true) { assume $DebugTrackLocal(15, 27372, 46, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_burn_with_resource_cap_$direct_intra($tv0: $TypeValue, preburn: $Value, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value)
{
    assume $Libra_Preburn_$is_well_typed(preburn);

    assume is#$Address(preburn_address);

    assume $Libra_BurnCapability_$is_well_formed(_capability);

    call $ret0 := $Libra_burn_with_resource_cap_$def($tv0, preburn, preburn_address, _capability);
}


procedure {:inline 1} $Libra_burn_with_resource_cap($tv0: $TypeValue, preburn: $Value, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value)
{
    assume $Libra_Preburn_$is_well_typed(preburn);

    assume is#$Address(preburn_address);

    assume $Libra_BurnCapability_$is_well_formed(_capability);

    call $ret0 := $Libra_burn_with_resource_cap_$def($tv0, preburn, preburn_address, _capability);
}


procedure {:inline 1} $Libra_cancel_burn_$def($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var addr: $Value; // $AddressType()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $Libra_BurnCapability_type_value($tv0)
    var $t11: $Value; // $Libra_Libra_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 15054, 0, account); }
    if (true) { assume $DebugTrackLocal(15, 15054, 1, preburn_address); }

    // bytecode translation starts here
    // $t5 := move(account)
    call $t5 := $CopyOrMoveValue(account);

    // $t6 := move(preburn_address)
    call $t6 := $CopyOrMoveValue(preburn_address);

    // addr := Signer::address_of($t5)
    call addr := $Signer_address_of($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 15246, $abort_code);
      goto Abort;
    }

    // $t7 := exists<Libra::BurnCapability<#0>>(addr)
    $t7 := $ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr);

    // $t8 := 0
    $t8 := $Integer(0);

    // $t9 := Errors::requires_capability($t8)
    call $t9 := $Errors_requires_capability($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 15330, $abort_code);
      goto Abort;
    }

    // if ($t7) goto L0 else goto L1
    if (b#$Boolean($t7)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t9)
    if (true) { assume $DebugTrackAbort(15, 15275, i#$Integer($t9)); }
    $abort_code := i#$Integer($t9);
    goto Abort;

    // L0:
L0:

    // $t10 := get_global<Libra::BurnCapability<#0>>(addr)
    call $t10 := $GetGlobal($Libra_BurnCapability_$memory, addr, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 15448, $abort_code);
      goto Abort;
    }

    // $t11 := Libra::cancel_burn_with_capability<#0>($t6, $t10)
    call $t11 := $Libra_cancel_burn_with_capability($tv0, $t6, $t10);
    if ($abort_flag) {
      goto Abort;
    }

    // return $t11
    $ret0 := $t11;
    if (true) { assume $DebugTrackLocal(15, 15378, 12, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_cancel_burn_$direct_inter($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    assume is#$Address(preburn_address);

    call $ret0 := $Libra_cancel_burn_$def($tv0, account, preburn_address);
}


procedure {:inline 1} $Libra_cancel_burn_$direct_intra($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    assume is#$Address(preburn_address);

    call $ret0 := $Libra_cancel_burn_$def($tv0, account, preburn_address);
}


procedure {:inline 1} $Libra_cancel_burn($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    assume is#$Address(preburn_address);

    call $ret0 := $Libra_cancel_burn_$def($tv0, account, preburn_address);
}


procedure {:inline 1} $Libra_cancel_burn_with_capability_$def($tv0: $TypeValue, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var amount: $Value; // $IntegerType()
    var coin: $Value; // $Libra_Libra_type_value($tv0)
    var currency_code: $Value; // $Vector_type_value($IntegerType())
    var info: $Mutation; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var preburn: $Mutation; // ReferenceType($Libra_Preburn_type_value($tv0))
    var tmp#$7: $Value; // $BooleanType()
    var tmp#$8: $Value; // $IntegerType()
    var tmp#$9: $Value; // $BooleanType()
    var tmp#$10: $Value; // $IntegerType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Mutation; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t16: $Value; // $Libra_Libra_type_value($tv0)
    var $t17: $Value; // $Libra_Libra_type_value($tv0)
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $BooleanType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Mutation; // ReferenceType($IntegerType())
    var $t26: $Value; // $BooleanType()
    var $t27: $Value; // $BooleanType()
    var $t28: $Mutation; // ReferenceType($Event_EventHandle_type_value($Libra_CancelBurnEvent_type_value()))
    var $t29: $Value; // $Libra_CancelBurnEvent_type_value()
    var $t30: $Value; // $Event_EventHandle_type_value($Libra_CancelBurnEvent_type_value())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 28749, 0, preburn_address); }
    if (true) { assume $DebugTrackLocal(15, 28749, 1, _capability); }

    // bytecode translation starts here
    // $t11 := move(preburn_address)
    call $t11 := $CopyOrMoveValue(preburn_address);

    // $t12 := exists<Libra::Preburn<#0>>($t11)
    $t12 := $ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t11);

    // $t13 := 2
    $t13 := $Integer(2);

    // $t14 := Errors::not_published($t13)
    call $t14 := $Errors_not_published($t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 29051, $abort_code);
      goto Abort;
    }

    // if ($t12) goto L0 else goto L1
    if (b#$Boolean($t12)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t14)
    if (true) { assume $DebugTrackAbort(15, 28992, i#$Integer($t14)); }
    $abort_code := i#$Integer($t14);
    goto Abort;

    // L0:
L0:

    // preburn := borrow_global<Libra::Preburn<#0>>($t11)
    call preburn := $BorrowGlobal($Libra_Preburn_$memory, $t11, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 29099, $abort_code);
      goto Abort;
    }

    // unpack_ref(preburn)

    // $t15 := borrow_field<Libra::Preburn<#0>>.to_burn(preburn)
    call $t15 := $BorrowField(preburn, $Libra_Preburn_to_burn);

    // unpack_ref($t15)

    // $t16 := read_ref($t15)
    call $t16 := $ReadRef($t15);
    assert $Libra_Libra_$invariant_holds($t16);

    // ($t17, $t16) := Libra::withdraw_all<#0>($t16)
    call $t17, $t16 := $Libra_withdraw_all($tv0, $t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 36326, $abort_code);
      goto Abort;
    }

    // write_ref($t15, $t16)
    call $t15 := $WriteRef($t15, $t16);
    if (true) { assume $DebugTrackLocal(15, 36326, 5, $Dereference(info)); }
    if (true) { assume $DebugTrackLocal(15, 36326, 6, $Dereference(preburn)); }

    // pack_ref($t15)

    // write_back[Reference(preburn)]($t15)
    call preburn := $WritebackToReference($t15, preburn);

    // pack_ref(preburn)

    // write_back[Libra::Preburn](preburn)
    call $Libra_Preburn_$memory := $WritebackToGlobal($Libra_Preburn_$memory, preburn);

    // coin := $t17
    call coin := $CopyOrMoveValue($t17);
    if (true) { assume $DebugTrackLocal(15, 29166, 3, coin); }

    // currency_code := Libra::currency_code<#0>()
    call currency_code := $Libra_currency_code($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 47470, $abort_code);
      goto Abort;
    }

    // $t18 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t18 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // info := borrow_global<Libra::CurrencyInfo<#0>>($t18)
    call info := $BorrowGlobal($Libra_CurrencyInfo_$memory, $t18, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 29326, $abort_code);
      goto Abort;
    }

    // unpack_ref(info)
    call $Libra_CurrencyInfo_$unpack_ref($tv0, $Dereference(info));

    // amount := Libra::value<#0>(coin)
    call amount := $Libra_value($tv0, coin);
    if ($abort_flag) {
      goto Abort;
    }

    // $t19 := get_field<Libra::CurrencyInfo<#0>>.preburn_value(info)
    call $t19 := $GetFieldFromReference(info, $Libra_CurrencyInfo_preburn_value);

    // $t20 := >=($t19, amount)
    call $t20 := $Ge($t19, amount);

    // $t21 := 2
    $t21 := $Integer(2);

    // $t22 := Errors::limit_exceeded($t21)
    call $t22 := $Errors_limit_exceeded($t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 29497, $abort_code);
      goto Abort;
    }

    // if ($t20) goto L2 else goto L3
    if (b#$Boolean($t20)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // destroy(info)

    // pack_ref(info)
    call $Libra_CurrencyInfo_$pack_ref($tv0, $Dereference(info));

    // abort($t22)
    if (true) { assume $DebugTrackAbort(15, 29452, i#$Integer($t22)); }
    $abort_code := i#$Integer($t22);
    goto Abort;

    // L2:
L2:

    // $t23 := get_field<Libra::CurrencyInfo<#0>>.preburn_value(info)
    call $t23 := $GetFieldFromReference(info, $Libra_CurrencyInfo_preburn_value);

    // $t24 := -($t23, amount)
    call $t24 := $Sub($t23, amount);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 29572, $abort_code);
      goto Abort;
    }

    // $t25 := borrow_field<Libra::CurrencyInfo<#0>>.preburn_value(info)
    call $t25 := $BorrowField(info, $Libra_CurrencyInfo_preburn_value);

    // unpack_ref($t25)

    // write_ref($t25, $t24)
    call $t25 := $WriteRef($t25, $t24);
    if (true) { assume $DebugTrackLocal(15, 29532, 5, $Dereference(info)); }
    if (true) { assume $DebugTrackLocal(15, 29532, 6, $Dereference(preburn)); }

    // pack_ref($t25)

    // write_back[Reference(info)]($t25)
    call info := $WritebackToReference($t25, info);

    // $t26 := get_field<Libra::CurrencyInfo<#0>>.is_synthetic(info)
    call $t26 := $GetFieldFromReference(info, $Libra_CurrencyInfo_is_synthetic);

    // $t27 := !($t26)
    call $t27 := $Not($t26);

    // if ($t27) goto L4 else goto L5
    if (b#$Boolean($t27)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // goto L6
    goto L6;

    // L4:
L4:

    // $t28 := borrow_field<Libra::CurrencyInfo<#0>>.cancel_burn_events(info)
    call $t28 := $BorrowField(info, $Libra_CurrencyInfo_cancel_burn_events);

    // unpack_ref($t28)

    // $t29 := pack Libra::CancelBurnEvent(amount, currency_code, $t11)
    call $t29 := $Libra_CancelBurnEvent_pack(0, 0, 0, amount, currency_code, $t11);

    // $t30 := read_ref($t28)
    call $t30 := $ReadRef($t28);
    assert $Event_EventHandle_$invariant_holds($t30);

    // $t30 := Event::emit_event<Libra::CancelBurnEvent>($t30, $t29)
    call $t30 := $Event_emit_event($Libra_CancelBurnEvent_type_value(), $t30, $t29);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 29780, $abort_code);
      goto Abort;
    }

    // write_ref($t28, $t30)
    call $t28 := $WriteRef($t28, $t30);
    if (true) { assume $DebugTrackLocal(15, 29780, 5, $Dereference(info)); }
    if (true) { assume $DebugTrackLocal(15, 29780, 6, $Dereference(preburn)); }

    // pack_ref($t28)

    // write_back[Reference(info)]($t28)
    call info := $WritebackToReference($t28, info);

    // pack_ref(info)
    call $Libra_CurrencyInfo_$pack_ref($tv0, $Dereference(info));

    // write_back[Libra::CurrencyInfo](info)
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, info);

    // goto L7
    goto L7;

    // L6:
L6:

    // destroy(info)

    // pack_ref(info)
    call $Libra_CurrencyInfo_$pack_ref($tv0, $Dereference(info));

    // write_back[Libra::CurrencyInfo](info)
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, info);

    // goto L7
    goto L7;

    // L7:
L7:

    // return coin
    $ret0 := coin;
    if (true) { assume $DebugTrackLocal(15, 30025, 31, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_cancel_burn_with_capability_$direct_inter($tv0: $TypeValue, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value)
{
    assume is#$Address(preburn_address);

    assume $Libra_BurnCapability_$is_well_formed(_capability);

    call $ret0 := $Libra_cancel_burn_with_capability_$def($tv0, preburn_address, _capability);
}


procedure {:inline 1} $Libra_cancel_burn_with_capability_$direct_intra($tv0: $TypeValue, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value)
{
    assume is#$Address(preburn_address);

    assume $Libra_BurnCapability_$is_well_formed(_capability);

    call $ret0 := $Libra_cancel_burn_with_capability_$def($tv0, preburn_address, _capability);
}


procedure {:inline 1} $Libra_cancel_burn_with_capability($tv0: $TypeValue, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value)
{
    assume is#$Address(preburn_address);

    assume $Libra_BurnCapability_$is_well_formed(_capability);

    call $ret0 := $Libra_cancel_burn_with_capability_$def($tv0, preburn_address, _capability);
}


procedure {:inline 1} $Libra_create_preburn_$def($tv0: $TypeValue, tc_account: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $Libra_Libra_type_value($tv0)
    var $t3: $Value; // $Libra_Preburn_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 20964, 0, tc_account); }

    // bytecode translation starts here
    // $t1 := move(tc_account)
    call $t1 := $CopyOrMoveValue(tc_account);

    // Roles::assert_treasury_compliance($t1)
    call $Roles_assert_treasury_compliance($t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 21071, $abort_code);
      goto Abort;
    }

    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 50948, $abort_code);
      goto Abort;
    }

    // $t2 := Libra::zero<#0>()
    call $t2 := $Libra_zero($tv0);
    if ($abort_flag) {
      goto Abort;
    }

    // $t3 := pack Libra::Preburn<#0>($t2)
    call $t3 := $Libra_Preburn_pack(0, 0, 0, $tv0, $t2);

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(15, 21159, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_create_preburn_$direct_inter($tv0: $TypeValue, tc_account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(tc_account);

    call $ret0 := $Libra_create_preburn_$def($tv0, tc_account);
}


procedure {:inline 1} $Libra_create_preburn_$direct_intra($tv0: $TypeValue, tc_account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(tc_account);

    call $ret0 := $Libra_create_preburn_$def($tv0, tc_account);
}


procedure {:inline 1} $Libra_create_preburn($tv0: $TypeValue, tc_account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(tc_account);

    call $ret0 := $Libra_create_preburn_$def($tv0, tc_account);
}


procedure {:inline 1} $Libra_deposit_$def($tv0: $TypeValue, coin: $Value, check: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var value: $Value; // $IntegerType()
    var $t5: $Value; // $Libra_Libra_type_value($tv0)
    var $t6: $Value; // $Libra_Libra_type_value($tv0)
    var $t7: $Mutation; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $BooleanType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Mutation; // ReferenceType($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 37236, 0, coin); }
    if (true) { assume $DebugTrackLocal(15, 37236, 1, check); }

    // bytecode translation starts here
    // $t5 := move(coin)
    call $t5 := $CopyOrMoveValue(coin);

    // $t6 := move(check)
    call $t6 := $CopyOrMoveValue(check);

    // $t7 := borrow_local($t5)
    call $t7 := $BorrowLoc(5, $t5);

    // unpack_ref($t7)

    // value := unpack Libra::Libra<#0>($t6)
    call value := $Libra_Libra_unpack($tv0, $t6);
    if (true) { assume $DebugTrackLocal(15, 37331, 4, value); }

    // $t8 := 18446744073709551615
    $t8 := $Integer(18446744073709551615);

    // $t9 := get_field<Libra::Libra<#0>>.value($t7)
    call $t9 := $GetFieldFromReference($t7, $Libra_Libra_value);

    // $t10 := -($t8, $t9)
    call $t10 := $Sub($t8, $t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 37379, $abort_code);
      goto Abort;
    }

    // $t11 := >=($t10, value)
    call $t11 := $Ge($t10, value);

    // $t12 := 7
    $t12 := $Integer(7);

    // $t13 := Errors::limit_exceeded($t12)
    call $t13 := $Errors_limit_exceeded($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 37410, $abort_code);
      goto Abort;
    }

    // if ($t11) goto L0 else goto L1
    if (b#$Boolean($t11)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t7)

    // pack_ref($t7)

    // abort($t13)
    if (true) { assume $DebugTrackAbort(15, 37364, i#$Integer($t13)); }
    $abort_code := i#$Integer($t13);
    goto Abort;

    // L0:
L0:

    // $t14 := get_field<Libra::Libra<#0>>.value($t7)
    call $t14 := $GetFieldFromReference($t7, $Libra_Libra_value);

    // $t15 := +($t14, value)
    call $t15 := $AddU64($t14, value);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 37466, $abort_code);
      goto Abort;
    }

    // $t16 := borrow_field<Libra::Libra<#0>>.value($t7)
    call $t16 := $BorrowField($t7, $Libra_Libra_value);

    // unpack_ref($t16)

    // write_ref($t16, $t15)
    call $t16 := $WriteRef($t16, $t15);

    // pack_ref($t16)

    // write_back[Reference($t7)]($t16)
    call $t7 := $WritebackToReference($t16, $t7);

    // pack_ref($t7)

    // write_back[LocalRoot($t5)]($t7)
    call $t5 := $WritebackToValue($t7, 5, $t5);

    // return $t5
    $ret0 := $t5;
    if (true) { assume $DebugTrackLocal(15, 37473, 17, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_deposit_$direct_inter($tv0: $TypeValue, coin: $Value, check: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin, $Libra_Libra_value)) + i#$Integer($SelectField(check, $Libra_Libra_value)))) > i#$Integer($Integer(18446744073709551615))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin, $Libra_Libra_value)) + i#$Integer($SelectField(check, $Libra_Libra_value)))) > i#$Integer($Integer(18446744073709551615))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin, $Libra_Libra_value)) + i#$Integer($SelectField(check, $Libra_Libra_value)))) > i#$Integer($Integer(18446744073709551615))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), $Integer(i#$Integer(old($SelectField(coin, $Libra_Libra_value))) + i#$Integer($SelectField(check, $Libra_Libra_value)))))));
ensures $Libra_Libra_$is_well_formed($ret0);

procedure {:inline 1} $Libra_deposit_$direct_intra($tv0: $TypeValue, coin: $Value, check: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin, $Libra_Libra_value)) + i#$Integer($SelectField(check, $Libra_Libra_value)))) > i#$Integer($Integer(18446744073709551615))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin, $Libra_Libra_value)) + i#$Integer($SelectField(check, $Libra_Libra_value)))) > i#$Integer($Integer(18446744073709551615))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin, $Libra_Libra_value)) + i#$Integer($SelectField(check, $Libra_Libra_value)))) > i#$Integer($Integer(18446744073709551615))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), $Integer(i#$Integer(old($SelectField(coin, $Libra_Libra_value))) + i#$Integer($SelectField(check, $Libra_Libra_value)))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) <= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) >= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) >= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) <= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_to_lbr_exchange_rate), old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_to_lbr_exchange_rate))))))));
ensures $Libra_Libra_$is_well_formed($ret0);

procedure {:inline 1} $Libra_deposit($tv0: $TypeValue, coin: $Value, check: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin, $Libra_Libra_value)) + i#$Integer($SelectField(check, $Libra_Libra_value)))) > i#$Integer($Integer(18446744073709551615))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin, $Libra_Libra_value)) + i#$Integer($SelectField(check, $Libra_Libra_value)))) > i#$Integer($Integer(18446744073709551615))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin, $Libra_Libra_value)) + i#$Integer($SelectField(check, $Libra_Libra_value)))) > i#$Integer($Integer(18446744073709551615))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), $Integer(i#$Integer(old($SelectField(coin, $Libra_Libra_value))) + i#$Integer($SelectField(check, $Libra_Libra_value)))))));
ensures $Libra_Libra_$is_well_formed($ret0);

procedure {:inline 1} $Libra_destroy_zero_$def($tv0: $TypeValue, coin: $Value) returns ()
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var value: $Value; // $IntegerType()
    var $t4: $Value; // $Libra_Libra_type_value($tv0)
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 38070, 0, coin); }

    // bytecode translation starts here
    // $t4 := move(coin)
    call $t4 := $CopyOrMoveValue(coin);

    // value := unpack Libra::Libra<#0>($t4)
    call value := $Libra_Libra_unpack($tv0, $t4);
    if (true) { assume $DebugTrackLocal(15, 38141, 3, value); }

    // $t5 := 0
    $t5 := $Integer(0);

    // $t6 := ==(value, $t5)
    $t6 := $Boolean($IsEqual(value, $t5));

    // $t7 := 8
    $t7 := $Integer(8);

    // $t8 := Errors::invalid_argument($t7)
    call $t8 := $Errors_invalid_argument($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 38200, $abort_code);
      goto Abort;
    }

    // if ($t6) goto L0 else goto L1
    if (b#$Boolean($t6)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t8)
    if (true) { assume $DebugTrackAbort(15, 38173, i#$Integer($t8)); }
    $abort_code := i#$Integer($t8);
    goto Abort;

    // L0:
L0:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Libra_destroy_zero_$direct_inter($tv0: $TypeValue, coin: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) > i#$Integer($Integer(0))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) > i#$Integer($Integer(0))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) > i#$Integer($Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7))));

procedure {:inline 1} $Libra_destroy_zero_$direct_intra($tv0: $TypeValue, coin: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) > i#$Integer($Integer(0))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) > i#$Integer($Integer(0))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) > i#$Integer($Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) <= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) >= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) >= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) <= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_to_lbr_exchange_rate), old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_to_lbr_exchange_rate))))))));

procedure {:inline 1} $Libra_destroy_zero($tv0: $TypeValue, coin: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) > i#$Integer($Integer(0))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) > i#$Integer($Integer(0))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) > i#$Integer($Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7))));

procedure {:inline 1} $Libra_fractional_part_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $Libra_CurrencyInfo_type_value($tv0)
    var $t2: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 50948, $abort_code);
      goto Abort;
    }

    // $t0 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t1 := get_global<Libra::CurrencyInfo<#0>>($t0)
    call $t1 := $GetGlobal($Libra_CurrencyInfo_$memory, $t0, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 47241, $abort_code);
      goto Abort;
    }

    // $t2 := get_field<Libra::CurrencyInfo<#0>>.fractional_part($t1)
    call $t2 := $GetFieldFromValue($t1, $Libra_CurrencyInfo_fractional_part);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(15, 47241, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_fractional_part_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_fractional_part_$def($tv0);
}


procedure {:inline 1} $Libra_fractional_part_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_fractional_part_$def($tv0);
}


procedure {:inline 1} $Libra_fractional_part($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_fractional_part_$def($tv0);
}


procedure {:inline 1} $Libra_is_SCS_currency_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
    // declare local variables
    var info: $Value; // $Libra_CurrencyInfo_type_value($tv0)
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 50948, $abort_code);
      goto Abort;
    }

    // $t1 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t1 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // info := get_global<Libra::CurrencyInfo<#0>>($t1)
    call info := $GetGlobal($Libra_CurrencyInfo_$memory, $t1, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 45986, $abort_code);
      goto Abort;
    }
    if (true) { assume $DebugTrackLocal(15, 45986, 0, info); }

    // $t2 := get_field<Libra::CurrencyInfo<#0>>.is_synthetic(info)
    call $t2 := $GetFieldFromValue(info, $Libra_CurrencyInfo_is_synthetic);

    // $t3 := !($t2)
    call $t3 := $Not($t2);

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(15, 46073, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_is_SCS_currency_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_is_SCS_currency_$def($tv0);
}


procedure {:inline 1} $Libra_is_SCS_currency_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_is_SCS_currency_$def($tv0);
}


procedure {:inline 1} $Libra_is_SCS_currency($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_is_SCS_currency_$def($tv0);
}


procedure {:inline 1} $Libra_is_currency_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t1 := exists<Libra::CurrencyInfo<#0>>($t0)
    $t1 := $ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t0);

    // return $t1
    $ret0 := $t1;
    if (true) { assume $DebugTrackLocal(15, 45776, 2, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_is_currency_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_is_currency_$def($tv0);
}


procedure {:inline 1} $Libra_is_currency_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_is_currency_$def($tv0);
}


procedure {:inline 1} $Libra_is_currency($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_is_currency_$def($tv0);
}


procedure {:inline 1} $Libra_is_synthetic_currency_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
    // declare local variables
    var addr: $Value; // $AddressType()
    var tmp#$1: $Value; // $BooleanType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $Libra_CurrencyInfo_type_value($tv0)
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // addr := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call addr := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t2 := exists<Libra::CurrencyInfo<#0>>(addr)
    $t2 := $ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr);

    // if ($t2) goto L0 else goto L1
    if (b#$Boolean($t2)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t3 := get_global<Libra::CurrencyInfo<#0>>(addr)
    call $t3 := $GetGlobal($Libra_CurrencyInfo_$memory, addr, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 46432, $abort_code);
      goto Abort;
    }

    // $t4 := get_field<Libra::CurrencyInfo<#0>>.is_synthetic($t3)
    call $t4 := $GetFieldFromValue($t3, $Libra_CurrencyInfo_is_synthetic);

    // tmp#$1 := $t4
    call tmp#$1 := $CopyOrMoveValue($t4);
    if (true) { assume $DebugTrackLocal(15, 46380, 1, tmp#$1); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t5 := false
    $t5 := $Boolean(false);

    // tmp#$1 := $t5
    call tmp#$1 := $CopyOrMoveValue($t5);
    if (true) { assume $DebugTrackLocal(15, 46380, 1, tmp#$1); }

    // goto L3
    goto L3;

    // L3:
L3:

    // return tmp#$1
    $ret0 := tmp#$1;
    if (true) { assume $DebugTrackLocal(15, 46380, 6, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_is_synthetic_currency_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_is_synthetic_currency_$def($tv0);
}


procedure {:inline 1} $Libra_is_synthetic_currency_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_is_synthetic_currency_$def($tv0);
}


procedure {:inline 1} $Libra_is_synthetic_currency($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_is_synthetic_currency_$def($tv0);
}


procedure {:inline 1} $Libra_join_$def($tv0: $TypeValue, coin1: $Value, coin2: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t2: $Value; // $Libra_Libra_type_value($tv0)
    var $t3: $Value; // $Libra_Libra_type_value($tv0)
    var $t4: $Mutation; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t5: $Value; // $Libra_Libra_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 36711, 0, coin1); }
    if (true) { assume $DebugTrackLocal(15, 36711, 1, coin2); }

    // bytecode translation starts here
    // $t2 := move(coin1)
    call $t2 := $CopyOrMoveValue(coin1);

    // $t3 := move(coin2)
    call $t3 := $CopyOrMoveValue(coin2);

    // $t4 := borrow_local($t2)
    call $t4 := $BorrowLoc(2, $t2);

    // unpack_ref($t4)

    // $t5 := read_ref($t4)
    call $t5 := $ReadRef($t4);
    assert $Libra_Libra_$invariant_holds($t5);

    // $t5 := Libra::deposit<#0>($t5, $t3)
    call $t5 := $Libra_deposit($tv0, $t5, $t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 37247, $abort_code);
      goto Abort;
    }

    // write_ref($t4, $t5)
    call $t4 := $WriteRef($t4, $t5);

    // pack_ref($t4)

    // write_back[LocalRoot($t2)]($t4)
    call $t2 := $WritebackToValue($t4, 2, $t2);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(15, 36849, 6, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_join_$direct_inter($tv0: $TypeValue, coin1: $Value, coin2: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin1, $Libra_Libra_value)) + i#$Integer($SelectField(coin2, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin1, $Libra_Libra_value)) + i#$Integer($SelectField(coin2, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin1, $Libra_Libra_value)) + i#$Integer($SelectField(coin2, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), $Integer(i#$Integer($SelectField(coin1, $Libra_Libra_value)) + i#$Integer($SelectField(coin2, $Libra_Libra_value)))))));
ensures $Libra_Libra_$is_well_formed($ret0);

procedure {:inline 1} $Libra_join_$direct_intra($tv0: $TypeValue, coin1: $Value, coin2: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin1, $Libra_Libra_value)) + i#$Integer($SelectField(coin2, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin1, $Libra_Libra_value)) + i#$Integer($SelectField(coin2, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin1, $Libra_Libra_value)) + i#$Integer($SelectField(coin2, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), $Integer(i#$Integer($SelectField(coin1, $Libra_Libra_value)) + i#$Integer($SelectField(coin2, $Libra_Libra_value)))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) <= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) >= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) >= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) <= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_to_lbr_exchange_rate), old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_to_lbr_exchange_rate))))))));
ensures $Libra_Libra_$is_well_formed($ret0);

procedure {:inline 1} $Libra_join($tv0: $TypeValue, coin1: $Value, coin2: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin1, $Libra_Libra_value)) + i#$Integer($SelectField(coin2, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin1, $Libra_Libra_value)) + i#$Integer($SelectField(coin2, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin1, $Libra_Libra_value)) + i#$Integer($SelectField(coin2, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), $Integer(i#$Integer($SelectField(coin1, $Libra_Libra_value)) + i#$Integer($SelectField(coin2, $Libra_Libra_value)))))));
ensures $Libra_Libra_$is_well_formed($ret0);

procedure {:inline 1} $Libra_lbr_exchange_rate_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $Libra_CurrencyInfo_type_value($tv0)
    var $t2: $Value; // $FixedPoint32_FixedPoint32_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 50948, $abort_code);
      goto Abort;
    }

    // $t0 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t1 := get_global<Libra::CurrencyInfo<#0>>($t0)
    call $t1 := $GetGlobal($Libra_CurrencyInfo_$memory, $t0, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 49664, $abort_code);
      goto Abort;
    }

    // $t2 := get_field<Libra::CurrencyInfo<#0>>.to_lbr_exchange_rate($t1)
    call $t2 := $GetFieldFromValue($t1, $Libra_CurrencyInfo_to_lbr_exchange_rate);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(15, 49662, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_lbr_exchange_rate_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_lbr_exchange_rate_$def($tv0);
}


procedure {:inline 1} $Libra_lbr_exchange_rate_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_lbr_exchange_rate_$def($tv0);
}


procedure {:inline 1} $Libra_lbr_exchange_rate($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_lbr_exchange_rate_$def($tv0);
}


procedure {:inline 1} $Libra_market_cap_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $Libra_CurrencyInfo_type_value($tv0)
    var $t2: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 50948, $abort_code);
      goto Abort;
    }

    // $t0 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t1 := get_global<Libra::CurrencyInfo<#0>>($t0)
    call $t1 := $GetGlobal($Libra_CurrencyInfo_$memory, $t0, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 44020, $abort_code);
      goto Abort;
    }

    // $t2 := get_field<Libra::CurrencyInfo<#0>>.total_value($t1)
    call $t2 := $GetFieldFromValue($t1, $Libra_CurrencyInfo_total_value);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(15, 44020, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_market_cap_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_market_cap_$def($tv0);
}


procedure {:inline 1} $Libra_market_cap_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_market_cap_$def($tv0);
}


procedure {:inline 1} $Libra_market_cap($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_market_cap_$def($tv0);
}


procedure {:inline 1} $Libra_mint_$def($tv0: $TypeValue, account: $Value, value: $Value, $Libra_CurrencyInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
{
    // declare local variables
    var addr: $Value; // $AddressType()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $Libra_MintCapability_type_value($tv0)
    var $t11: $Value; // $Libra_Libra_type_value($tv0)
    var $Libra_CurrencyInfo_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 12179, 0, account); }
    if (true) { assume $DebugTrackLocal(15, 12179, 1, value); }
    $Libra_CurrencyInfo_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := true];

    // bytecode translation starts here
    // $t5 := move(account)
    call $t5 := $CopyOrMoveValue(account);

    // $t6 := move(value)
    call $t6 := $CopyOrMoveValue(value);

    // addr := Signer::address_of($t5)
    call addr := $Signer_address_of($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 12323, $abort_code);
      goto Abort;
    }

    // $t7 := exists<Libra::MintCapability<#0>>(addr)
    $t7 := $ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr);

    // $t8 := 10
    $t8 := $Integer(10);

    // $t9 := Errors::requires_capability($t8)
    call $t9 := $Errors_requires_capability($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 12407, $abort_code);
      goto Abort;
    }

    // if ($t7) goto L0 else goto L1
    if (b#$Boolean($t7)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t9)
    if (true) { assume $DebugTrackAbort(15, 12352, i#$Integer($t9)); }
    $abort_code := i#$Integer($t9);
    goto Abort;

    // L0:
L0:

    // $t10 := get_global<Libra::MintCapability<#0>>(addr)
    call $t10 := $GetGlobal($Libra_MintCapability_$memory, addr, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 12508, $abort_code);
      goto Abort;
    }

    // $t11 := Libra::mint_with_capability<#0>($t6, $t10)
    call $t11 := $Libra_mint_with_capability($tv0, $t6, $t10, $Libra_CurrencyInfo_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 16127, $abort_code);
      goto Abort;
    }

    // return $t11
    $ret0 := $t11;
    if (true) { assume $DebugTrackLocal(15, 12455, 12, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_mint_$direct_inter($tv0: $TypeValue, account: $Value, value: $Value, $Libra_CurrencyInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
requires $Libra_CurrencyInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())];
{
    assume is#$Address(account);

    assume $IsValidU64(value);

    call $ret0 := $Libra_mint_$def($tv0, account, value, $Libra_CurrencyInfo_$CallerDomain);
}


procedure {:inline 1} $Libra_mint_$direct_intra($tv0: $TypeValue, account: $Value, value: $Value, $Libra_CurrencyInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
requires $Libra_CurrencyInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())];
{
    assume is#$Address(account);

    assume $IsValidU64(value);

    call $ret0 := $Libra_mint_$def($tv0, account, value, $Libra_CurrencyInfo_$CallerDomain);
}


procedure {:inline 1} $Libra_mint($tv0: $TypeValue, account: $Value, value: $Value, $Libra_CurrencyInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
requires $Libra_CurrencyInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())];
{
    assume is#$Address(account);

    assume $IsValidU64(value);

    call $ret0 := $Libra_mint_$def($tv0, account, value, $Libra_CurrencyInfo_$CallerDomain);
}


procedure {:inline 1} $Libra_mint_with_capability_$def($tv0: $TypeValue, value: $Value, _capability: $Value, $Libra_CurrencyInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
{
    // declare local variables
    var currency_code: $Value; // $Vector_type_value($IntegerType())
    var info: $Mutation; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var tmp#$6: $Value; // $BooleanType()
    var tmp#$7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Mutation; // ReferenceType($IntegerType())
    var $t24: $Value; // $BooleanType()
    var $t25: $Value; // $BooleanType()
    var $t26: $Mutation; // ReferenceType($Event_EventHandle_type_value($Libra_MintEvent_type_value()))
    var $t27: $Value; // $Libra_MintEvent_type_value()
    var $t28: $Value; // $Event_EventHandle_type_value($Libra_MintEvent_type_value())
    var $t29: $Value; // $Libra_Libra_type_value($tv0)
    var $Libra_CurrencyInfo_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 16116, 0, value); }
    if (true) { assume $DebugTrackLocal(15, 16116, 1, _capability); }
    $Libra_CurrencyInfo_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := true];

    // bytecode translation starts here
    // $t8 := move(value)
    call $t8 := $CopyOrMoveValue(value);

    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 50948, $abort_code);
      goto Abort;
    }

    // currency_code := Libra::currency_code<#0>()
    call currency_code := $Libra_currency_code($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 47470, $abort_code);
      goto Abort;
    }

    // $t9 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t9 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // info := borrow_global<Libra::CurrencyInfo<#0>>($t9)
    assert $Libra_CurrencyInfo_$SelfDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($t9)];
    call info := $BorrowGlobal($Libra_CurrencyInfo_$memory, $t9, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 16444, $abort_code);
      goto Abort;
    }

    // unpack_ref(info)
    call $Libra_CurrencyInfo_$unpack_ref($tv0, $Dereference(info));

    // $t10 := get_field<Libra::CurrencyInfo<#0>>.can_mint(info)
    call $t10 := $GetFieldFromReference(info, $Libra_CurrencyInfo_can_mint);

    // $t11 := 5
    $t11 := $Integer(5);

    // $t12 := Errors::invalid_state($t11)
    call $t12 := $Errors_invalid_state($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 16565, $abort_code);
      goto Abort;
    }

    // if ($t10) goto L0 else goto L1
    if (b#$Boolean($t10)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy(info)

    // pack_ref(info)
    call $Libra_CurrencyInfo_$pack_ref($tv0, $Dereference(info));

    // abort($t12)
    if (true) { assume $DebugTrackAbort(15, 16535, i#$Integer($t12)); }
    $abort_code := i#$Integer($t12);
    goto Abort;

    // L0:
L0:

    // $t13 := 340282366920938463463374607431768211455
    $t13 := $Integer(340282366920938463463374607431768211455);

    // $t14 := get_field<Libra::CurrencyInfo<#0>>.total_value(info)
    call $t14 := $GetFieldFromReference(info, $Libra_CurrencyInfo_total_value);

    // $t15 := -($t13, $t14)
    call $t15 := $Sub($t13, $t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 16627, $abort_code);
      goto Abort;
    }

    // $t16 := (u128)($t8)
    call $t16 := $CastU128($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 16649, $abort_code);
      goto Abort;
    }

    // $t17 := >=($t15, $t16)
    call $t17 := $Ge($t15, $t16);

    // $t18 := 1
    $t18 := $Integer(1);

    // $t19 := Errors::limit_exceeded($t18)
    call $t19 := $Errors_limit_exceeded($t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 16674, $abort_code);
      goto Abort;
    }

    // if ($t17) goto L2 else goto L3
    if (b#$Boolean($t17)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // destroy(info)

    // pack_ref(info)
    call $Libra_CurrencyInfo_$pack_ref($tv0, $Dereference(info));

    // abort($t19)
    if (true) { assume $DebugTrackAbort(15, 16611, i#$Integer($t19)); }
    $abort_code := i#$Integer($t19);
    goto Abort;

    // L2:
L2:

    // $t20 := get_field<Libra::CurrencyInfo<#0>>.total_value(info)
    call $t20 := $GetFieldFromReference(info, $Libra_CurrencyInfo_total_value);

    // $t21 := (u128)($t8)
    call $t21 := $CastU128($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 16753, $abort_code);
      goto Abort;
    }

    // $t22 := +($t20, $t21)
    call $t22 := $AddU128($t20, $t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 16751, $abort_code);
      goto Abort;
    }

    // $t23 := borrow_field<Libra::CurrencyInfo<#0>>.total_value(info)
    call $t23 := $BorrowField(info, $Libra_CurrencyInfo_total_value);

    // unpack_ref($t23)

    // write_ref($t23, $t22)
    call $t23 := $WriteRef($t23, $t22);
    if (true) { assume $DebugTrackLocal(15, 16715, 3, $Dereference(info)); }

    // pack_ref($t23)

    // write_back[Reference(info)]($t23)
    call info := $WritebackToReference($t23, info);

    // $t24 := get_field<Libra::CurrencyInfo<#0>>.is_synthetic(info)
    call $t24 := $GetFieldFromReference(info, $Libra_CurrencyInfo_is_synthetic);

    // $t25 := !($t24)
    call $t25 := $Not($t24);

    // if ($t25) goto L4 else goto L5
    if (b#$Boolean($t25)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // goto L6
    goto L6;

    // L4:
L4:

    // $t26 := borrow_field<Libra::CurrencyInfo<#0>>.mint_events(info)
    call $t26 := $BorrowField(info, $Libra_CurrencyInfo_mint_events);

    // unpack_ref($t26)

    // $t27 := pack Libra::MintEvent($t8, currency_code)
    call $t27 := $Libra_MintEvent_pack(0, 0, 0, $t8, currency_code);

    // $t28 := read_ref($t26)
    call $t28 := $ReadRef($t26);
    assert $Event_EventHandle_$invariant_holds($t28);

    // $t28 := Event::emit_event<Libra::MintEvent>($t28, $t27)
    call $t28 := $Event_emit_event($Libra_MintEvent_type_value(), $t28, $t27);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 16882, $abort_code);
      goto Abort;
    }

    // write_ref($t26, $t28)
    call $t26 := $WriteRef($t26, $t28);
    if (true) { assume $DebugTrackLocal(15, 16882, 3, $Dereference(info)); }

    // pack_ref($t26)

    // write_back[Reference(info)]($t26)
    call info := $WritebackToReference($t26, info);

    // pack_ref(info)
    call $Libra_CurrencyInfo_$pack_ref($tv0, $Dereference(info));

    // write_back[Libra::CurrencyInfo](info)
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, info);

    // goto L7
    goto L7;

    // L6:
L6:

    // destroy(info)

    // pack_ref(info)
    call $Libra_CurrencyInfo_$pack_ref($tv0, $Dereference(info));

    // write_back[Libra::CurrencyInfo](info)
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, info);

    // goto L7
    goto L7;

    // L7:
L7:

    // $t29 := pack Libra::Libra<#0>($t8)
    call $t29 := $Libra_Libra_pack(0, 0, 0, $tv0, $t8);

    // return $t29
    $ret0 := $t29;
    if (true) { assume $DebugTrackLocal(15, 17083, 30, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_mint_with_capability_$direct_inter($tv0: $TypeValue, value: $Value, _capability: $Value, $Libra_CurrencyInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
requires $Libra_CurrencyInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())];
ensures b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint)))))
    || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_currency_info$51($Libra_CurrencyInfo_$memory, $tv0), $UpdateField(old($Libra_currency_info$51($Libra_CurrencyInfo_$memory, $tv0)), $Libra_CurrencyInfo_total_value, $Integer(i#$Integer(old($SelectField($Libra_currency_info$51($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))) + i#$Integer(value)))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), value))));
ensures $Libra_Libra_$is_well_formed($ret0);
modifies $Libra_CurrencyInfo_$memory;
ensures contents#$Memory($Libra_CurrencyInfo_$memory) == old(contents#$Memory($Libra_CurrencyInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())]];
ensures domain#$Memory($Libra_CurrencyInfo_$memory) == old(domain#$Memory($Libra_CurrencyInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := domain#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())]];

procedure {:inline 1} $Libra_mint_with_capability_$direct_intra($tv0: $TypeValue, value: $Value, _capability: $Value, $Libra_CurrencyInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
requires $Libra_CurrencyInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())];
ensures b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint)))))
    || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_currency_info$51($Libra_CurrencyInfo_$memory, $tv0), $UpdateField(old($Libra_currency_info$51($Libra_CurrencyInfo_$memory, $tv0)), $Libra_CurrencyInfo_total_value, $Integer(i#$Integer(old($SelectField($Libra_currency_info$51($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))) + i#$Integer(value)))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), value))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) >= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) >= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) <= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_to_lbr_exchange_rate), old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_to_lbr_exchange_rate))))))));
ensures $Libra_Libra_$is_well_formed($ret0);
modifies $Libra_CurrencyInfo_$memory;
ensures contents#$Memory($Libra_CurrencyInfo_$memory) == old(contents#$Memory($Libra_CurrencyInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())]];
ensures domain#$Memory($Libra_CurrencyInfo_$memory) == old(domain#$Memory($Libra_CurrencyInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := domain#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())]];

procedure {:inline 1} $Libra_mint_with_capability($tv0: $TypeValue, value: $Value, _capability: $Value, $Libra_CurrencyInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
requires $Libra_CurrencyInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())];
ensures b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint)))))
    || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_currency_info$51($Libra_CurrencyInfo_$memory, $tv0), $UpdateField(old($Libra_currency_info$51($Libra_CurrencyInfo_$memory, $tv0)), $Libra_CurrencyInfo_total_value, $Integer(i#$Integer(old($SelectField($Libra_currency_info$51($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))) + i#$Integer(value)))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), value))));
ensures $Libra_Libra_$is_well_formed($ret0);
modifies $Libra_CurrencyInfo_$memory;
ensures contents#$Memory($Libra_CurrencyInfo_$memory) == old(contents#$Memory($Libra_CurrencyInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())]];
ensures domain#$Memory($Libra_CurrencyInfo_$memory) == old(domain#$Memory($Libra_CurrencyInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := domain#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())]];

procedure {:inline 1} $Libra_preburn_to_$def($tv0: $TypeValue, account: $Value, coin: $Value) returns ()
{
    // declare local variables
    var sender: $Value; // $AddressType()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $Libra_Libra_type_value($tv0)
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Mutation; // ReferenceType($Libra_Preburn_type_value($tv0))
    var $t11: $Value; // $Libra_Preburn_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 23224, 0, account); }
    if (true) { assume $DebugTrackLocal(15, 23224, 1, coin); }

    // bytecode translation starts here
    // $t5 := move(account)
    call $t5 := $CopyOrMoveValue(account);

    // $t6 := move(coin)
    call $t6 := $CopyOrMoveValue(coin);

    // sender := Signer::address_of($t5)
    call sender := $Signer_address_of($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 23381, $abort_code);
      goto Abort;
    }

    // $t7 := exists<Libra::Preburn<#0>>(sender)
    $t7 := $ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), sender);

    // $t8 := 2
    $t8 := $Integer(2);

    // $t9 := Errors::not_published($t8)
    call $t9 := $Errors_not_published($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 23460, $abort_code);
      goto Abort;
    }

    // if ($t7) goto L0 else goto L1
    if (b#$Boolean($t7)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t9)
    if (true) { assume $DebugTrackAbort(15, 23410, i#$Integer($t9)); }
    $abort_code := i#$Integer($t9);
    goto Abort;

    // L0:
L0:

    // $t10 := borrow_global<Libra::Preburn<#0>>(sender)
    call $t10 := $BorrowGlobal($Libra_Preburn_$memory, sender, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 23522, $abort_code);
      goto Abort;
    }

    // unpack_ref($t10)

    // $t11 := read_ref($t10)
    call $t11 := $ReadRef($t10);
    assert $Libra_Preburn_$invariant_holds($t11);

    // $t11 := Libra::preburn_with_resource<#0>($t6, $t11, sender)
    call $t11 := $Libra_preburn_with_resource($tv0, $t6, $t11, sender);
    if ($abort_flag) {
      goto Abort;
    }

    // write_ref($t10, $t11)
    call $t10 := $WriteRef($t10, $t11);

    // pack_ref($t10)

    // write_back[Libra::Preburn]($t10)
    call $Libra_Preburn_$memory := $WritebackToGlobal($Libra_Preburn_$memory, $t10);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Libra_preburn_to_$direct_inter($tv0: $TypeValue, account: $Value, coin: $Value) returns ()
{
    assume is#$Address(account);

    assume $Libra_Libra_$is_well_formed(coin);

    call $Libra_preburn_to_$def($tv0, account, coin);
}


procedure {:inline 1} $Libra_preburn_to_$direct_intra($tv0: $TypeValue, account: $Value, coin: $Value) returns ()
{
    assume is#$Address(account);

    assume $Libra_Libra_$is_well_formed(coin);

    call $Libra_preburn_to_$def($tv0, account, coin);
}


procedure {:inline 1} $Libra_preburn_to($tv0: $TypeValue, account: $Value, coin: $Value) returns ()
{
    assume is#$Address(account);

    assume $Libra_Libra_$is_well_formed(coin);

    call $Libra_preburn_to_$def($tv0, account, coin);
}


procedure {:inline 1} $Libra_preburn_value_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $Libra_CurrencyInfo_type_value($tv0)
    var $t2: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 50948, $abort_code);
      goto Abort;
    }

    // $t0 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t1 := get_global<Libra::CurrencyInfo<#0>>($t0)
    call $t1 := $GetGlobal($Libra_CurrencyInfo_$memory, $t0, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 33868, $abort_code);
      goto Abort;
    }

    // $t2 := get_field<Libra::CurrencyInfo<#0>>.preburn_value($t1)
    call $t2 := $GetFieldFromValue($t1, $Libra_CurrencyInfo_preburn_value);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(15, 33868, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_preburn_value_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_preburn_value_$def($tv0);
}


procedure {:inline 1} $Libra_preburn_value_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_preburn_value_$def($tv0);
}


procedure {:inline 1} $Libra_preburn_value($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_preburn_value_$def($tv0);
}


procedure {:inline 1} $Libra_preburn_with_resource_$def($tv0: $TypeValue, coin: $Value, preburn: $Value, preburn_address: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var coin_value: $Value; // $IntegerType()
    var currency_code: $Value; // $Vector_type_value($IntegerType())
    var info: $Mutation; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var tmp#$6: $Value; // $BooleanType()
    var tmp#$7: $Value; // $IntegerType()
    var tmp#$8: $Value; // $BooleanType()
    var tmp#$9: $Value; // $IntegerType()
    var $t10: $Value; // $Libra_Libra_type_value($tv0)
    var $t11: $Value; // $Libra_Preburn_type_value($tv0)
    var $t12: $Value; // $AddressType()
    var $t13: $Mutation; // ReferenceType($Libra_Preburn_type_value($tv0))
    var $t14: $Value; // $Libra_Libra_type_value($tv0)
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Mutation; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t21: $Value; // $Libra_Libra_type_value($tv0)
    var $t22: $Value; // $AddressType()
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $BooleanType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $IntegerType()
    var $t30: $Value; // $IntegerType()
    var $t31: $Mutation; // ReferenceType($IntegerType())
    var $t32: $Value; // $BooleanType()
    var $t33: $Value; // $BooleanType()
    var $t34: $Mutation; // ReferenceType($Event_EventHandle_type_value($Libra_PreburnEvent_type_value()))
    var $t35: $Value; // $Libra_PreburnEvent_type_value()
    var $t36: $Value; // $Event_EventHandle_type_value($Libra_PreburnEvent_type_value())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 18747, 0, coin); }
    if (true) { assume $DebugTrackLocal(15, 18747, 1, preburn); }
    if (true) { assume $DebugTrackLocal(15, 18747, 2, preburn_address); }

    // bytecode translation starts here
    // $t10 := move(coin)
    call $t10 := $CopyOrMoveValue(coin);

    // $t11 := move(preburn)
    call $t11 := $CopyOrMoveValue(preburn);

    // $t12 := move(preburn_address)
    call $t12 := $CopyOrMoveValue(preburn_address);

    // $t13 := borrow_local($t11)
    call $t13 := $BorrowLoc(11, $t11);

    // unpack_ref($t13)

    // coin_value := Libra::value<#0>($t10)
    call coin_value := $Libra_value($tv0, $t10);
    if ($abort_flag) {
      goto Abort;
    }

    // $t14 := get_field<Libra::Preburn<#0>>.to_burn($t13)
    call $t14 := $GetFieldFromReference($t13, $Libra_Preburn_to_burn);
    assert $Libra_Libra_$invariant_holds($t14);

    // $t15 := Libra::value<#0>($t14)
    call $t15 := $Libra_value($tv0, $t14);
    if ($abort_flag) {
      goto Abort;
    }

    // $t16 := 0
    $t16 := $Integer(0);

    // $t17 := ==($t15, $t16)
    $t17 := $Boolean($IsEqual($t15, $t16));

    // $t18 := 3
    $t18 := $Integer(3);

    // $t19 := Errors::invalid_state($t18)
    call $t19 := $Errors_invalid_state($t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 19056, $abort_code);
      goto Abort;
    }

    // if ($t17) goto L0 else goto L1
    if (b#$Boolean($t17)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t13)

    // pack_ref($t13)

    // abort($t19)
    if (true) { assume $DebugTrackAbort(15, 19011, i#$Integer($t19)); }
    $abort_code := i#$Integer($t19);
    goto Abort;

    // L0:
L0:

    // $t20 := borrow_field<Libra::Preburn<#0>>.to_burn($t13)
    call $t20 := $BorrowField($t13, $Libra_Preburn_to_burn);

    // unpack_ref($t20)

    // $t21 := read_ref($t20)
    call $t21 := $ReadRef($t20);
    assert $Libra_Libra_$invariant_holds($t21);

    // $t21 := Libra::deposit<#0>($t21, $t10)
    call $t21 := $Libra_deposit($tv0, $t21, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 37247, $abort_code);
      goto Abort;
    }

    // write_ref($t20, $t21)
    call $t20 := $WriteRef($t20, $t21);
    if (true) { assume $DebugTrackLocal(15, 37247, 5, $Dereference(info)); }

    // pack_ref($t20)

    // write_back[Reference($t13)]($t20)
    call $t13 := $WritebackToReference($t20, $t13);

    // pack_ref($t13)

    // write_back[LocalRoot($t11)]($t13)
    call $t11 := $WritebackToValue($t13, 11, $t11);

    // currency_code := Libra::currency_code<#0>()
    call currency_code := $Libra_currency_code($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 47470, $abort_code);
      goto Abort;
    }

    // $t22 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t22 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // info := borrow_global<Libra::CurrencyInfo<#0>>($t22)
    call info := $BorrowGlobal($Libra_CurrencyInfo_$memory, $t22, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 19210, $abort_code);
      goto Abort;
    }

    // unpack_ref(info)
    call $Libra_CurrencyInfo_$unpack_ref($tv0, $Dereference(info));

    // $t23 := 18446744073709551615
    $t23 := $Integer(18446744073709551615);

    // $t24 := get_field<Libra::CurrencyInfo<#0>>.preburn_value(info)
    call $t24 := $GetFieldFromReference(info, $Libra_CurrencyInfo_preburn_value);

    // $t25 := -($t23, $t24)
    call $t25 := $Sub($t23, $t24);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 19316, $abort_code);
      goto Abort;
    }

    // $t26 := >=($t25, coin_value)
    call $t26 := $Ge($t25, coin_value);

    // $t27 := 7
    $t27 := $Integer(7);

    // $t28 := Errors::limit_exceeded($t27)
    call $t28 := $Errors_limit_exceeded($t27);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 19360, $abort_code);
      goto Abort;
    }

    // if ($t26) goto L2 else goto L3
    if (b#$Boolean($t26)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // destroy(info)

    // pack_ref(info)
    call $Libra_CurrencyInfo_$pack_ref($tv0, $Dereference(info));

    // abort($t28)
    if (true) { assume $DebugTrackAbort(15, 19301, i#$Integer($t28)); }
    $abort_code := i#$Integer($t28);
    goto Abort;

    // L2:
L2:

    // $t29 := get_field<Libra::CurrencyInfo<#0>>.preburn_value(info)
    call $t29 := $GetFieldFromReference(info, $Libra_CurrencyInfo_preburn_value);

    // $t30 := +($t29, coin_value)
    call $t30 := $AddU64($t29, coin_value);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 19432, $abort_code);
      goto Abort;
    }

    // $t31 := borrow_field<Libra::CurrencyInfo<#0>>.preburn_value(info)
    call $t31 := $BorrowField(info, $Libra_CurrencyInfo_preburn_value);

    // unpack_ref($t31)

    // write_ref($t31, $t30)
    call $t31 := $WriteRef($t31, $t30);
    if (true) { assume $DebugTrackLocal(15, 19392, 5, $Dereference(info)); }

    // pack_ref($t31)

    // write_back[Reference(info)]($t31)
    call info := $WritebackToReference($t31, info);

    // $t32 := get_field<Libra::CurrencyInfo<#0>>.is_synthetic(info)
    call $t32 := $GetFieldFromReference(info, $Libra_CurrencyInfo_is_synthetic);

    // $t33 := !($t32)
    call $t33 := $Not($t32);

    // if ($t33) goto L4 else goto L5
    if (b#$Boolean($t33)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // goto L6
    goto L6;

    // L4:
L4:

    // $t34 := borrow_field<Libra::CurrencyInfo<#0>>.preburn_events(info)
    call $t34 := $BorrowField(info, $Libra_CurrencyInfo_preburn_events);

    // unpack_ref($t34)

    // $t35 := pack Libra::PreburnEvent(coin_value, currency_code, $t12)
    call $t35 := $Libra_PreburnEvent_pack(0, 0, 0, coin_value, currency_code, $t12);

    // $t36 := read_ref($t34)
    call $t36 := $ReadRef($t34);
    assert $Event_EventHandle_$invariant_holds($t36);

    // $t36 := Event::emit_event<Libra::PreburnEvent>($t36, $t35)
    call $t36 := $Event_emit_event($Libra_PreburnEvent_type_value(), $t36, $t35);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 19561, $abort_code);
      goto Abort;
    }

    // write_ref($t34, $t36)
    call $t34 := $WriteRef($t34, $t36);
    if (true) { assume $DebugTrackLocal(15, 19561, 5, $Dereference(info)); }

    // pack_ref($t34)

    // write_back[Reference(info)]($t34)
    call info := $WritebackToReference($t34, info);

    // pack_ref(info)
    call $Libra_CurrencyInfo_$pack_ref($tv0, $Dereference(info));

    // write_back[Libra::CurrencyInfo](info)
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, info);

    // goto L7
    goto L7;

    // L6:
L6:

    // destroy(info)

    // pack_ref(info)
    call $Libra_CurrencyInfo_$pack_ref($tv0, $Dereference(info));

    // write_back[Libra::CurrencyInfo](info)
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, info);

    // goto L7
    goto L7;

    // L7:
L7:

    // return $t11
    $ret0 := $t11;
    if (true) { assume $DebugTrackLocal(15, 19799, 37, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_preburn_with_resource_$direct_inter($tv0: $TypeValue, coin: $Value, preburn: $Value, preburn_address: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_$is_well_formed(coin);

    assume $Libra_Preburn_$is_well_formed(preburn);

    assume is#$Address(preburn_address);

    call $ret0 := $Libra_preburn_with_resource_$def($tv0, coin, preburn, preburn_address);
}


procedure {:inline 1} $Libra_preburn_with_resource_$direct_intra($tv0: $TypeValue, coin: $Value, preburn: $Value, preburn_address: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_$is_well_formed(coin);

    assume $Libra_Preburn_$is_well_formed(preburn);

    assume is#$Address(preburn_address);

    call $ret0 := $Libra_preburn_with_resource_$def($tv0, coin, preburn, preburn_address);
}


procedure {:inline 1} $Libra_preburn_with_resource($tv0: $TypeValue, coin: $Value, preburn: $Value, preburn_address: $Value) returns ($ret0: $Value)
{
    assume $Libra_Libra_$is_well_formed(coin);

    assume $Libra_Preburn_$is_well_formed(preburn);

    assume is#$Address(preburn_address);

    call $ret0 := $Libra_preburn_with_resource_$def($tv0, coin, preburn, preburn_address);
}


procedure {:inline 1} $Libra_publish_burn_capability_$def($tv0: $TypeValue, tc_account: $Value, cap: $Value) returns ()
{
    // declare local variables
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $Libra_BurnCapability_type_value($tv0)
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 10955, 0, tc_account); }
    if (true) { assume $DebugTrackLocal(15, 10955, 1, cap); }

    // bytecode translation starts here
    // $t4 := move(tc_account)
    call $t4 := $CopyOrMoveValue(tc_account);

    // $t5 := move(cap)
    call $t5 := $CopyOrMoveValue(cap);

    // Roles::assert_treasury_compliance($t4)
    call $Roles_assert_treasury_compliance($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 11092, $abort_code);
      goto Abort;
    }

    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 50948, $abort_code);
      goto Abort;
    }

    // $t6 := Signer::address_of($t4)
    call $t6 := $Signer_address_of($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 11242, $abort_code);
      goto Abort;
    }

    // $t7 := exists<Libra::BurnCapability<#0>>($t6)
    $t7 := $ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t6);

    // $t8 := !($t7)
    call $t8 := $Not($t7);

    // $t9 := 0
    $t9 := $Integer(0);

    // $t10 := Errors::already_published($t9)
    call $t10 := $Errors_already_published($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 11287, $abort_code);
      goto Abort;
    }

    // if ($t8) goto L0 else goto L1
    if (b#$Boolean($t8)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t4)

    // abort($t10)
    if (true) { assume $DebugTrackAbort(15, 11180, i#$Integer($t10)); }
    $abort_code := i#$Integer($t10);
    goto Abort;

    // L0:
L0:

    // move_to<Libra::BurnCapability<#0>>($t5, $t4)
    call $Libra_BurnCapability_$memory := $MoveTo($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t5, $t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 11342, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Libra_publish_burn_capability_$direct_inter($tv0: $TypeValue, tc_account: $Value, cap: $Value) returns ()
{
    assume is#$Address(tc_account);

    assume $Libra_BurnCapability_$is_well_formed(cap);

    call $Libra_publish_burn_capability_$def($tv0, tc_account, cap);
}


procedure {:inline 1} $Libra_publish_burn_capability_$direct_intra($tv0: $TypeValue, tc_account: $Value, cap: $Value) returns ()
{
    assume is#$Address(tc_account);

    assume $Libra_BurnCapability_$is_well_formed(cap);

    call $Libra_publish_burn_capability_$def($tv0, tc_account, cap);
}


procedure {:inline 1} $Libra_publish_burn_capability($tv0: $TypeValue, tc_account: $Value, cap: $Value) returns ()
{
    assume is#$Address(tc_account);

    assume $Libra_BurnCapability_$is_well_formed(cap);

    call $Libra_publish_burn_capability_$def($tv0, tc_account, cap);
}


procedure {:inline 1} $Libra_publish_preburn_to_account_$def($tv0: $TypeValue, account: $Value, tc_account: $Value, $Libra_Preburn_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $Libra_Preburn_type_value($tv0)
    var $Libra_Preburn_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 21532, 0, account); }
    if (true) { assume $DebugTrackLocal(15, 21532, 1, tc_account); }
    $Libra_Preburn_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($Signer_spec_address_of(account)) := true];

    // bytecode translation starts here
    // $t6 := move(account)
    call $t6 := $CopyOrMoveValue(account);

    // $t7 := move(tc_account)
    call $t7 := $CopyOrMoveValue(tc_account);

    // Roles::assert_designated_dealer($t6)
    call $Roles_assert_designated_dealer($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 21680, $abort_code);
      goto Abort;
    }

    // Roles::assert_treasury_compliance($t7)
    call $Roles_assert_treasury_compliance($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 21730, $abort_code);
      goto Abort;
    }

    // $t8 := Libra::is_synthetic_currency<#0>()
    call $t8 := $Libra_is_synthetic_currency($tv0);
    if ($abort_flag) {
      goto Abort;
    }

    // $t9 := !($t8)
    call $t9 := $Not($t8);

    // $t10 := 6
    $t10 := $Integer(6);

    // $t11 := Errors::invalid_argument($t10)
    call $t11 := $Errors_invalid_argument($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 21829, $abort_code);
      goto Abort;
    }

    // if ($t9) goto L0 else goto L1
    if (b#$Boolean($t9)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t7)

    // destroy($t6)

    // abort($t11)
    if (true) { assume $DebugTrackAbort(15, 21778, i#$Integer($t11)); }
    $abort_code := i#$Integer($t11);
    goto Abort;

    // L0:
L0:

    // $t12 := Signer::address_of($t6)
    call $t12 := $Signer_address_of($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 21922, $abort_code);
      goto Abort;
    }

    // $t13 := exists<Libra::Preburn<#0>>($t12)
    $t13 := $ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t12);

    // $t14 := !($t13)
    call $t14 := $Not($t13);

    // $t15 := 2
    $t15 := $Integer(2);

    // $t16 := Errors::already_published($t15)
    call $t16 := $Errors_already_published($t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 21952, $abort_code);
      goto Abort;
    }

    // if ($t14) goto L2 else goto L3
    if (b#$Boolean($t14)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // destroy($t7)

    // destroy($t6)

    // abort($t16)
    if (true) { assume $DebugTrackAbort(15, 21880, i#$Integer($t16)); }
    $abort_code := i#$Integer($t16);
    goto Abort;

    // L2:
L2:

    // $t17 := Libra::create_preburn<#0>($t7)
    call $t17 := $Libra_create_preburn($tv0, $t7);
    if ($abort_flag) {
      goto Abort;
    }

    // move_to<Libra::Preburn<#0>>($t17, $t6)
    assert $Libra_Preburn_$SelfDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($Signer_spec_address_of($t6))];
    call $Libra_Preburn_$memory := $MoveTo($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t17, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 21990, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Libra_publish_preburn_to_account_$direct_inter($tv0: $TypeValue, account: $Value, tc_account: $Value, $Libra_Preburn_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Libra_Preburn_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($Signer_spec_address_of(account))];
{
    assume is#$Address(account);

    assume is#$Address(tc_account);

    call $Libra_publish_preburn_to_account_$def($tv0, account, tc_account, $Libra_Preburn_$CallerDomain);
}


procedure {:inline 1} $Libra_publish_preburn_to_account_$direct_intra($tv0: $TypeValue, account: $Value, tc_account: $Value, $Libra_Preburn_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Libra_Preburn_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($Signer_spec_address_of(account))];
{
    assume is#$Address(account);

    assume is#$Address(tc_account);

    call $Libra_publish_preburn_to_account_$def($tv0, account, tc_account, $Libra_Preburn_$CallerDomain);
}


procedure {:inline 1} $Libra_publish_preburn_to_account($tv0: $TypeValue, account: $Value, tc_account: $Value, $Libra_Preburn_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Libra_Preburn_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($Signer_spec_address_of(account))];
{
    assume is#$Address(account);

    assume is#$Address(tc_account);

    call $Libra_publish_preburn_to_account_$def($tv0, account, tc_account, $Libra_Preburn_$CallerDomain);
}


procedure {:inline 1} $Libra_register_SCS_currency_$def($tv0: $TypeValue, lr_account: $Value, tc_account: $Value, to_lbr_exchange_rate: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value) returns ()
{
    // declare local variables
    var burn_cap: $Value; // $Libra_BurnCapability_type_value($tv0)
    var mint_cap: $Value; // $Libra_MintCapability_type_value($tv0)
    var tmp#$8: $Value; // $BooleanType()
    var tmp#$9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $Vector_type_value($IntegerType())
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $Libra_MintCapability_type_value($tv0)
    var $t18: $Value; // $Libra_BurnCapability_type_value($tv0)
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $BooleanType()
    var $t21: $Value; // $BooleanType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 42337, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(15, 42337, 1, tc_account); }
    if (true) { assume $DebugTrackLocal(15, 42337, 2, to_lbr_exchange_rate); }
    if (true) { assume $DebugTrackLocal(15, 42337, 3, scaling_factor); }
    if (true) { assume $DebugTrackLocal(15, 42337, 4, fractional_part); }
    if (true) { assume $DebugTrackLocal(15, 42337, 5, currency_code); }

    // bytecode translation starts here
    // $t10 := move(lr_account)
    call $t10 := $CopyOrMoveValue(lr_account);

    // $t11 := move(tc_account)
    call $t11 := $CopyOrMoveValue(tc_account);

    // $t12 := move(to_lbr_exchange_rate)
    call $t12 := $CopyOrMoveValue(to_lbr_exchange_rate);

    // $t13 := move(scaling_factor)
    call $t13 := $CopyOrMoveValue(scaling_factor);

    // $t14 := move(fractional_part)
    call $t14 := $CopyOrMoveValue(fractional_part);

    // $t15 := move(currency_code)
    call $t15 := $CopyOrMoveValue(currency_code);

    // Roles::assert_treasury_compliance($t11)
    call $Roles_assert_treasury_compliance($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 42600, $abort_code);
      goto Abort;
    }

    // $t16 := false
    $t16 := $Boolean(false);

    // ($t17, $t18) := Libra::register_currency<#0>($t10, $t12, $t16, $t13, $t14, $t15)
    call $t17, $t18 := $Libra_register_currency($tv0, $t10, $t12, $t16, $t13, $t14, $t15);
    if ($abort_flag) {
      goto Abort;
    }

    // burn_cap := $t18
    call burn_cap := $CopyOrMoveValue($t18);
    if (true) { assume $DebugTrackLocal(15, 42663, 6, burn_cap); }

    // mint_cap := $t17
    call mint_cap := $CopyOrMoveValue($t17);
    if (true) { assume $DebugTrackLocal(15, 42653, 7, mint_cap); }

    // $t19 := Signer::address_of($t11)
    call $t19 := $Signer_address_of($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 43004, $abort_code);
      goto Abort;
    }

    // $t20 := exists<Libra::MintCapability<#0>>($t19)
    $t20 := $ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t19);

    // $t21 := !($t20)
    call $t21 := $Not($t20);

    // $t22 := 10
    $t22 := $Integer(10);

    // $t23 := Errors::already_published($t22)
    call $t23 := $Errors_already_published($t22);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 43049, $abort_code);
      goto Abort;
    }

    // if ($t21) goto L0 else goto L1
    if (b#$Boolean($t21)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t11)

    // abort($t23)
    if (true) { assume $DebugTrackAbort(15, 42942, i#$Integer($t23)); }
    $abort_code := i#$Integer($t23);
    goto Abort;

    // L0:
L0:

    // move_to<Libra::MintCapability<#0>>(mint_cap, $t11)
    call $Libra_MintCapability_$memory := $MoveTo($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), mint_cap, $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 43104, $abort_code);
      goto Abort;
    }

    // Libra::publish_burn_capability<#0>($t11, burn_cap)
    call $Libra_publish_burn_capability($tv0, $t11, burn_cap);
    if ($abort_flag) {
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Libra_register_SCS_currency_$direct_inter($tv0: $TypeValue, lr_account: $Value, tc_account: $Value, to_lbr_exchange_rate: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume is#$Address(tc_account);

    assume $FixedPoint32_FixedPoint32_$is_well_formed(to_lbr_exchange_rate);

    assume $IsValidU64(scaling_factor);

    assume $IsValidU64(fractional_part);

    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));

    call $Libra_register_SCS_currency_$def($tv0, lr_account, tc_account, to_lbr_exchange_rate, scaling_factor, fractional_part, currency_code);
}


procedure {:inline 1} $Libra_register_SCS_currency_$direct_intra($tv0: $TypeValue, lr_account: $Value, tc_account: $Value, to_lbr_exchange_rate: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume is#$Address(tc_account);

    assume $FixedPoint32_FixedPoint32_$is_well_formed(to_lbr_exchange_rate);

    assume $IsValidU64(scaling_factor);

    assume $IsValidU64(fractional_part);

    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));

    call $Libra_register_SCS_currency_$def($tv0, lr_account, tc_account, to_lbr_exchange_rate, scaling_factor, fractional_part, currency_code);
}


procedure {:inline 1} $Libra_register_SCS_currency($tv0: $TypeValue, lr_account: $Value, tc_account: $Value, to_lbr_exchange_rate: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume is#$Address(tc_account);

    assume $FixedPoint32_FixedPoint32_$is_well_formed(to_lbr_exchange_rate);

    assume $IsValidU64(scaling_factor);

    assume $IsValidU64(fractional_part);

    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));

    call $Libra_register_SCS_currency_$def($tv0, lr_account, tc_account, to_lbr_exchange_rate, scaling_factor, fractional_part, currency_code);
}


procedure {:inline 1} $Libra_scaling_factor_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $Libra_CurrencyInfo_type_value($tv0)
    var $t2: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 50948, $abort_code);
      goto Abort;
    }

    // $t0 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t1 := get_global<Libra::CurrencyInfo<#0>>($t0)
    call $t1 := $GetGlobal($Libra_CurrencyInfo_$memory, $t0, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 46724, $abort_code);
      goto Abort;
    }

    // $t2 := get_field<Libra::CurrencyInfo<#0>>.scaling_factor($t1)
    call $t2 := $GetFieldFromValue($t1, $Libra_CurrencyInfo_scaling_factor);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(15, 46724, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_scaling_factor_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_scaling_factor_$def($tv0);
}


procedure {:inline 1} $Libra_scaling_factor_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_scaling_factor_$def($tv0);
}


procedure {:inline 1} $Libra_scaling_factor($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_scaling_factor_$def($tv0);
}


procedure {:inline 1} $Libra_register_currency_$def($tv0: $TypeValue, lr_account: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    // declare local variables
    var tmp#$6: $Value; // $BooleanType()
    var tmp#$7: $Value; // $IntegerType()
    var tmp#$8: $Value; // $BooleanType()
    var tmp#$9: $Value; // $IntegerType()
    var tmp#$10: $Value; // $BooleanType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $Vector_type_value($IntegerType())
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $BooleanType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $BooleanType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $IntegerType()
    var $t30: $Value; // $BooleanType()
    var $t31: $Value; // $Event_EventHandle_type_value($Libra_MintEvent_type_value())
    var $t32: $Value; // $Event_EventHandle_type_value($Libra_BurnEvent_type_value())
    var $t33: $Value; // $Event_EventHandle_type_value($Libra_PreburnEvent_type_value())
    var $t34: $Value; // $Event_EventHandle_type_value($Libra_CancelBurnEvent_type_value())
    var $t35: $Value; // $Event_EventHandle_type_value($Libra_ToLBRExchangeRateUpdateEvent_type_value())
    var $t36: $Value; // $Libra_CurrencyInfo_type_value($tv0)
    var $t37: $Value; // $BooleanType()
    var $t38: $Value; // $Libra_MintCapability_type_value($tv0)
    var $t39: $Value; // $BooleanType()
    var $t40: $Value; // $Libra_BurnCapability_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 39370, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(15, 39370, 1, to_lbr_exchange_rate); }
    if (true) { assume $DebugTrackLocal(15, 39370, 2, is_synthetic); }
    if (true) { assume $DebugTrackLocal(15, 39370, 3, scaling_factor); }
    if (true) { assume $DebugTrackLocal(15, 39370, 4, fractional_part); }
    if (true) { assume $DebugTrackLocal(15, 39370, 5, currency_code); }

    // bytecode translation starts here
    // $t11 := move(lr_account)
    call $t11 := $CopyOrMoveValue(lr_account);

    // $t12 := move(to_lbr_exchange_rate)
    call $t12 := $CopyOrMoveValue(to_lbr_exchange_rate);

    // $t13 := move(is_synthetic)
    call $t13 := $CopyOrMoveValue(is_synthetic);

    // $t14 := move(scaling_factor)
    call $t14 := $CopyOrMoveValue(scaling_factor);

    // $t15 := move(fractional_part)
    call $t15 := $CopyOrMoveValue(fractional_part);

    // $t16 := move(currency_code)
    call $t16 := $CopyOrMoveValue(currency_code);

    // Roles::assert_libra_root($t11)
    call $Roles_assert_libra_root($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 39686, $abort_code);
      goto Abort;
    }

    // CoreAddresses::assert_currency_info($t11)
    call $CoreAddresses_assert_currency_info($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 39823, $abort_code);
      goto Abort;
    }

    // $t17 := Signer::address_of($t11)
    call $t17 := $Signer_address_of($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 39925, $abort_code);
      goto Abort;
    }

    // $t18 := exists<Libra::CurrencyInfo<#0>>($t17)
    $t18 := $ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t17);

    // $t19 := !($t18)
    call $t19 := $Not($t18);

    // $t20 := 1
    $t20 := $Integer(1);

    // $t21 := Errors::already_published($t20)
    call $t21 := $Errors_already_published($t20);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 39970, $abort_code);
      goto Abort;
    }

    // if ($t19) goto L0 else goto L1
    if (b#$Boolean($t19)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t11)

    // abort($t21)
    if (true) { assume $DebugTrackAbort(15, 39865, i#$Integer($t21)); }
    $abort_code := i#$Integer($t21);
    goto Abort;

    // L0:
L0:

    // $t22 := 0
    $t22 := $Integer(0);

    // $t23 := <($t22, $t14)
    call $t23 := $Lt($t22, $t14);

    // if ($t23) goto L2 else goto L3
    if (b#$Boolean($t23)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // goto L4
    goto L4;

    // L2:
L2:

    // $t24 := 10000000000
    $t24 := $Integer(10000000000);

    // tmp#$10 := <=($t14, $t24)
    call tmp#$10 := $Le($t14, $t24);
    if (true) { assume $DebugTrackLocal(15, 40067, 10, tmp#$10); }

    // goto L5
    goto L5;

    // L4:
L4:

    // $t25 := false
    $t25 := $Boolean(false);

    // tmp#$10 := $t25
    call tmp#$10 := $CopyOrMoveValue($t25);
    if (true) { assume $DebugTrackLocal(15, 40030, 10, tmp#$10); }

    // goto L5
    goto L5;

    // L5:
L5:

    // $t26 := 1
    $t26 := $Integer(1);

    // $t27 := Errors::invalid_argument($t26)
    call $t27 := $Errors_invalid_argument($t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 40098, $abort_code);
      goto Abort;
    }

    // if (tmp#$10) goto L6 else goto L7
    if (b#$Boolean(tmp#$10)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // destroy($t11)

    // abort($t27)
    if (true) { assume $DebugTrackAbort(15, 40023, i#$Integer($t27)); }
    $abort_code := i#$Integer($t27);
    goto Abort;

    // L6:
L6:

    // $t28 := 0
    $t28 := $Integer(0);

    // $t29 := 0
    $t29 := $Integer(0);

    // $t30 := true
    $t30 := $Boolean(true);

    // $t31 := Event::new_event_handle<Libra::MintEvent>($t11)
    call $t31 := $Event_new_event_handle($Libra_MintEvent_type_value(), $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 40468, $abort_code);
      goto Abort;
    }

    // $t32 := Event::new_event_handle<Libra::BurnEvent>($t11)
    call $t32 := $Event_new_event_handle($Libra_BurnEvent_type_value(), $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 40541, $abort_code);
      goto Abort;
    }

    // $t33 := Event::new_event_handle<Libra::PreburnEvent>($t11)
    call $t33 := $Event_new_event_handle($Libra_PreburnEvent_type_value(), $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 40617, $abort_code);
      goto Abort;
    }

    // $t34 := Event::new_event_handle<Libra::CancelBurnEvent>($t11)
    call $t34 := $Event_new_event_handle($Libra_CancelBurnEvent_type_value(), $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 40700, $abort_code);
      goto Abort;
    }

    // $t35 := Event::new_event_handle<Libra::ToLBRExchangeRateUpdateEvent>($t11)
    call $t35 := $Event_new_event_handle($Libra_ToLBRExchangeRateUpdateEvent_type_value(), $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 40795, $abort_code);
      goto Abort;
    }

    // $t36 := pack Libra::CurrencyInfo<#0>($t28, $t29, $t12, $t13, $t14, $t15, $t16, $t30, $t31, $t32, $t33, $t34, $t35)
    call $t36 := $Libra_CurrencyInfo_pack(0, 0, 0, $tv0, $t28, $t29, $t12, $t13, $t14, $t15, $t16, $t30, $t31, $t32, $t33, $t34, $t35);

    // move_to<Libra::CurrencyInfo<#0>>($t36, $t11)
    call $Libra_CurrencyInfo_$memory := $MoveTo($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t36, $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 40141, $abort_code);
      goto Abort;
    }

    // RegisteredCurrencies::add_currency_code($t11, $t16)
    call $RegisteredCurrencies_add_currency_code($t11, $t16);
    if ($abort_flag) {
      goto Abort;
    }

    // $t37 := false
    $t37 := $Boolean(false);

    // $t38 := pack Libra::MintCapability<#0>($t37)
    call $t38 := $Libra_MintCapability_pack(0, 0, 0, $tv0, $t37);

    // $t39 := false
    $t39 := $Boolean(false);

    // $t40 := pack Libra::BurnCapability<#0>($t39)
    call $t40 := $Libra_BurnCapability_pack(0, 0, 0, $tv0, $t39);

    // return ($t38, $t40)
    $ret0 := $t38;
    if (true) { assume $DebugTrackLocal(15, 40985, 41, $ret0); }
    $ret1 := $t40;
    if (true) { assume $DebugTrackLocal(15, 40985, 42, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}

procedure {:inline 1} $Libra_register_currency_$direct_inter($tv0: $TypeValue, lr_account: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume is#$Address(lr_account);

    assume $FixedPoint32_FixedPoint32_$is_well_formed(to_lbr_exchange_rate);

    assume is#$Boolean(is_synthetic);

    assume $IsValidU64(scaling_factor);

    assume $IsValidU64(fractional_part);

    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));

    call $ret0, $ret1 := $Libra_register_currency_$def($tv0, lr_account, to_lbr_exchange_rate, is_synthetic, scaling_factor, fractional_part, currency_code);
}


procedure {:inline 1} $Libra_register_currency_$direct_intra($tv0: $TypeValue, lr_account: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume is#$Address(lr_account);

    assume $FixedPoint32_FixedPoint32_$is_well_formed(to_lbr_exchange_rate);

    assume is#$Boolean(is_synthetic);

    assume $IsValidU64(scaling_factor);

    assume $IsValidU64(fractional_part);

    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));

    call $ret0, $ret1 := $Libra_register_currency_$def($tv0, lr_account, to_lbr_exchange_rate, is_synthetic, scaling_factor, fractional_part, currency_code);
}


procedure {:inline 1} $Libra_register_currency($tv0: $TypeValue, lr_account: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume is#$Address(lr_account);

    assume $FixedPoint32_FixedPoint32_$is_well_formed(to_lbr_exchange_rate);

    assume is#$Boolean(is_synthetic);

    assume $IsValidU64(scaling_factor);

    assume $IsValidU64(fractional_part);

    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));

    call $ret0, $ret1 := $Libra_register_currency_$def($tv0, lr_account, to_lbr_exchange_rate, is_synthetic, scaling_factor, fractional_part, currency_code);
}


procedure {:inline 1} $Libra_remove_burn_capability_$def($tv0: $TypeValue, account: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var addr: $Value; // $AddressType()
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $Libra_BurnCapability_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 32887, 0, account); }

    // bytecode translation starts here
    // $t4 := move(account)
    call $t4 := $CopyOrMoveValue(account);

    // addr := Signer::address_of($t4)
    call addr := $Signer_address_of($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 33032, $abort_code);
      goto Abort;
    }

    // $t5 := exists<Libra::BurnCapability<#0>>(addr)
    $t5 := $ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr);

    // $t6 := 0
    $t6 := $Integer(0);

    // $t7 := Errors::requires_capability($t6)
    call $t7 := $Errors_requires_capability($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 33116, $abort_code);
      goto Abort;
    }

    // if ($t5) goto L0 else goto L1
    if (b#$Boolean($t5)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t7)
    if (true) { assume $DebugTrackAbort(15, 33061, i#$Integer($t7)); }
    $abort_code := i#$Integer($t7);
    goto Abort;

    // L0:
L0:

    // $t8 := move_from<Libra::BurnCapability<#0>>(addr)
    call $Libra_BurnCapability_$memory, $t8 := $MoveFrom($Libra_BurnCapability_$memory, addr, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 33164, $abort_code);
      goto Abort;
    }

    // return $t8
    $ret0 := $t8;
    if (true) { assume $DebugTrackLocal(15, 33164, 9, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_remove_burn_capability_$direct_inter($tv0: $TypeValue, account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Libra_remove_burn_capability_$def($tv0, account);
}


procedure {:inline 1} $Libra_remove_burn_capability_$direct_intra($tv0: $TypeValue, account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Libra_remove_burn_capability_$def($tv0, account);
}


procedure {:inline 1} $Libra_remove_burn_capability($tv0: $TypeValue, account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $Libra_remove_burn_capability_$def($tv0, account);
}


procedure {:inline 1} $Libra_split_$def($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    // declare local variables
    var other: $Value; // $Libra_Libra_type_value($tv0)
    var $t3: $Value; // $Libra_Libra_type_value($tv0)
    var $t4: $Value; // $IntegerType()
    var $t5: $Mutation; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t6: $Value; // $Libra_Libra_type_value($tv0)
    var $t7: $Value; // $Libra_Libra_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 34750, 0, coin); }
    if (true) { assume $DebugTrackLocal(15, 34750, 1, amount); }

    // bytecode translation starts here
    // $t3 := move(coin)
    call $t3 := $CopyOrMoveValue(coin);

    // $t4 := move(amount)
    call $t4 := $CopyOrMoveValue(amount);

    // $t5 := borrow_local($t3)
    call $t5 := $BorrowLoc(3, $t3);

    // unpack_ref($t5)

    // $t6 := read_ref($t5)
    call $t6 := $ReadRef($t5);
    assert $Libra_Libra_$invariant_holds($t6);

    // ($t7, $t6) := Libra::withdraw<#0>($t6, $t4)
    call $t7, $t6 := $Libra_withdraw($tv0, $t6, $t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 35506, $abort_code);
      goto Abort;
    }

    // write_ref($t5, $t6)
    call $t5 := $WriteRef($t5, $t6);

    // pack_ref($t5)

    // write_back[LocalRoot($t3)]($t5)
    call $t3 := $WritebackToValue($t5, 3, $t3);

    // other := $t7
    call other := $CopyOrMoveValue($t7);
    if (true) { assume $DebugTrackLocal(15, 34863, 2, other); }

    // return ($t3, other)
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(15, 34908, 8, $ret0); }
    $ret1 := other;
    if (true) { assume $DebugTrackLocal(15, 34908, 9, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}

procedure {:inline 1} $Libra_split_$direct_inter($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume $Libra_Libra_$is_well_formed(coin);

    assume $IsValidU64(amount);

    call $ret0, $ret1 := $Libra_split_$def($tv0, coin, amount);
}


procedure {:inline 1} $Libra_split_$direct_intra($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume $Libra_Libra_$is_well_formed(coin);

    assume $IsValidU64(amount);

    call $ret0, $ret1 := $Libra_split_$def($tv0, coin, amount);
}


procedure {:inline 1} $Libra_split($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    assume $Libra_Libra_$is_well_formed(coin);

    assume $IsValidU64(amount);

    call $ret0, $ret1 := $Libra_split_$def($tv0, coin, amount);
}


procedure {:inline 1} $Libra_update_lbr_exchange_rate_$def($tv0: $TypeValue, tc_account: $Value, lbr_exchange_rate: $Value) returns ()
{
    // declare local variables
    var currency_info: $Mutation; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t5: $Value; // $AddressType()
    var $t6: $Mutation; // ReferenceType($FixedPoint32_FixedPoint32_type_value())
    var $t7: $Mutation; // ReferenceType($Event_EventHandle_type_value($Libra_ToLBRExchangeRateUpdateEvent_type_value()))
    var $t8: $Value; // $Vector_type_value($IntegerType())
    var $t9: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $Libra_ToLBRExchangeRateUpdateEvent_type_value()
    var $t12: $Value; // $Event_EventHandle_type_value($Libra_ToLBRExchangeRateUpdateEvent_type_value())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 48004, 0, tc_account); }
    if (true) { assume $DebugTrackLocal(15, 48004, 1, lbr_exchange_rate); }

    // bytecode translation starts here
    // $t3 := move(tc_account)
    call $t3 := $CopyOrMoveValue(tc_account);

    // $t4 := move(lbr_exchange_rate)
    call $t4 := $CopyOrMoveValue(lbr_exchange_rate);

    // Roles::assert_treasury_compliance($t3)
    call $Roles_assert_treasury_compliance($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 48169, $abort_code);
      goto Abort;
    }

    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 50948, $abort_code);
      goto Abort;
    }

    // $t5 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t5 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // currency_info := borrow_global<Libra::CurrencyInfo<#0>>($t5)
    call currency_info := $BorrowGlobal($Libra_CurrencyInfo_$memory, $t5, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 48281, $abort_code);
      goto Abort;
    }

    // unpack_ref(currency_info)
    call $Libra_CurrencyInfo_$unpack_ref($tv0, $Dereference(currency_info));

    // $t6 := borrow_field<Libra::CurrencyInfo<#0>>.to_lbr_exchange_rate(currency_info)
    call $t6 := $BorrowField(currency_info, $Libra_CurrencyInfo_to_lbr_exchange_rate);

    // unpack_ref($t6)

    // write_ref($t6, $t4)
    call $t6 := $WriteRef($t6, $t4);
    if (true) { assume $DebugTrackLocal(15, 48376, 2, $Dereference(currency_info)); }

    // pack_ref($t6)

    // write_back[Reference(currency_info)]($t6)
    call currency_info := $WritebackToReference($t6, currency_info);

    // $t7 := borrow_field<Libra::CurrencyInfo<#0>>.exchange_rate_update_events(currency_info)
    call $t7 := $BorrowField(currency_info, $Libra_CurrencyInfo_exchange_rate_update_events);

    // unpack_ref($t7)

    // $t8 := get_field<Libra::CurrencyInfo<#0>>.currency_code(currency_info)
    call $t8 := $GetFieldFromReference(currency_info, $Libra_CurrencyInfo_currency_code);

    // $t9 := get_field<Libra::CurrencyInfo<#0>>.to_lbr_exchange_rate(currency_info)
    call $t9 := $GetFieldFromReference(currency_info, $Libra_CurrencyInfo_to_lbr_exchange_rate);
    assert $FixedPoint32_FixedPoint32_$invariant_holds($t9);

    // $t10 := FixedPoint32::get_raw_value($t9)
    call $t10 := $FixedPoint32_get_raw_value($t9);
    if ($abort_flag) {
      goto Abort;
    }

    // $t11 := pack Libra::ToLBRExchangeRateUpdateEvent($t8, $t10)
    call $t11 := $Libra_ToLBRExchangeRateUpdateEvent_pack(0, 0, 0, $t8, $t10);

    // $t12 := read_ref($t7)
    call $t12 := $ReadRef($t7);
    assert $Event_EventHandle_$invariant_holds($t12);

    // $t12 := Event::emit_event<Libra::ToLBRExchangeRateUpdateEvent>($t12, $t11)
    call $t12 := $Event_emit_event($Libra_ToLBRExchangeRateUpdateEvent_type_value(), $t12, $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 48447, $abort_code);
      goto Abort;
    }

    // write_ref($t7, $t12)
    call $t7 := $WriteRef($t7, $t12);
    if (true) { assume $DebugTrackLocal(15, 48447, 2, $Dereference(currency_info)); }

    // pack_ref($t7)

    // write_back[Reference(currency_info)]($t7)
    call currency_info := $WritebackToReference($t7, currency_info);

    // pack_ref(currency_info)
    call $Libra_CurrencyInfo_$pack_ref($tv0, $Dereference(currency_info));

    // write_back[Libra::CurrencyInfo](currency_info)
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, currency_info);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Libra_update_lbr_exchange_rate_$direct_inter($tv0: $TypeValue, tc_account: $Value, lbr_exchange_rate: $Value) returns ()
{
    assume is#$Address(tc_account);

    assume $FixedPoint32_FixedPoint32_$is_well_formed(lbr_exchange_rate);

    call $Libra_update_lbr_exchange_rate_$def($tv0, tc_account, lbr_exchange_rate);
}


procedure {:inline 1} $Libra_update_lbr_exchange_rate_$direct_intra($tv0: $TypeValue, tc_account: $Value, lbr_exchange_rate: $Value) returns ()
{
    assume is#$Address(tc_account);

    assume $FixedPoint32_FixedPoint32_$is_well_formed(lbr_exchange_rate);

    call $Libra_update_lbr_exchange_rate_$def($tv0, tc_account, lbr_exchange_rate);
}


procedure {:inline 1} $Libra_update_lbr_exchange_rate($tv0: $TypeValue, tc_account: $Value, lbr_exchange_rate: $Value) returns ()
{
    assume is#$Address(tc_account);

    assume $FixedPoint32_FixedPoint32_$is_well_formed(lbr_exchange_rate);

    call $Libra_update_lbr_exchange_rate_$def($tv0, tc_account, lbr_exchange_rate);
}


procedure {:inline 1} $Libra_update_minting_ability_$def($tv0: $TypeValue, tc_account: $Value, can_mint: $Value) returns ()
{
    // declare local variables
    var currency_info: $Mutation; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $AddressType()
    var $t6: $Mutation; // ReferenceType($BooleanType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 50298, 0, tc_account); }
    if (true) { assume $DebugTrackLocal(15, 50298, 1, can_mint); }

    // bytecode translation starts here
    // $t3 := move(tc_account)
    call $t3 := $CopyOrMoveValue(tc_account);

    // $t4 := move(can_mint)
    call $t4 := $CopyOrMoveValue(can_mint);

    // Roles::assert_treasury_compliance($t3)
    call $Roles_assert_treasury_compliance($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 50449, $abort_code);
      goto Abort;
    }

    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 50948, $abort_code);
      goto Abort;
    }

    // $t5 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t5 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // currency_info := borrow_global<Libra::CurrencyInfo<#0>>($t5)
    call currency_info := $BorrowGlobal($Libra_CurrencyInfo_$memory, $t5, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 50557, $abort_code);
      goto Abort;
    }

    // unpack_ref(currency_info)
    call $Libra_CurrencyInfo_$unpack_ref($tv0, $Dereference(currency_info));

    // $t6 := borrow_field<Libra::CurrencyInfo<#0>>.can_mint(currency_info)
    call $t6 := $BorrowField(currency_info, $Libra_CurrencyInfo_can_mint);

    // unpack_ref($t6)

    // write_ref($t6, $t4)
    call $t6 := $WriteRef($t6, $t4);
    if (true) { assume $DebugTrackLocal(15, 50648, 2, $Dereference(currency_info)); }

    // pack_ref($t6)

    // write_back[Reference(currency_info)]($t6)
    call currency_info := $WritebackToReference($t6, currency_info);

    // pack_ref(currency_info)
    call $Libra_CurrencyInfo_$pack_ref($tv0, $Dereference(currency_info));

    // write_back[Libra::CurrencyInfo](currency_info)
    call $Libra_CurrencyInfo_$memory := $WritebackToGlobal($Libra_CurrencyInfo_$memory, currency_info);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Libra_update_minting_ability_$direct_inter($tv0: $TypeValue, tc_account: $Value, can_mint: $Value) returns ()
{
    assume is#$Address(tc_account);

    assume is#$Boolean(can_mint);

    call $Libra_update_minting_ability_$def($tv0, tc_account, can_mint);
}


procedure {:inline 1} $Libra_update_minting_ability_$direct_intra($tv0: $TypeValue, tc_account: $Value, can_mint: $Value) returns ()
{
    assume is#$Address(tc_account);

    assume is#$Boolean(can_mint);

    call $Libra_update_minting_ability_$def($tv0, tc_account, can_mint);
}


procedure {:inline 1} $Libra_update_minting_ability($tv0: $TypeValue, tc_account: $Value, can_mint: $Value) returns ()
{
    assume is#$Address(tc_account);

    assume is#$Boolean(can_mint);

    call $Libra_update_minting_ability_$def($tv0, tc_account, can_mint);
}


procedure {:inline 1} $Libra_withdraw_$def($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    // declare local variables
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var $t4: $Value; // $Libra_Libra_type_value($tv0)
    var $t5: $Value; // $IntegerType()
    var $t6: $Mutation; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Mutation; // ReferenceType($IntegerType())
    var $t14: $Value; // $Libra_Libra_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 35495, 0, coin); }
    if (true) { assume $DebugTrackLocal(15, 35495, 1, amount); }

    // bytecode translation starts here
    // $t4 := move(coin)
    call $t4 := $CopyOrMoveValue(coin);

    // $t5 := move(amount)
    call $t5 := $CopyOrMoveValue(amount);

    // $t6 := borrow_local($t4)
    call $t6 := $BorrowLoc(4, $t4);

    // unpack_ref($t6)

    // $t7 := get_field<Libra::Libra<#0>>.value($t6)
    call $t7 := $GetFieldFromReference($t6, $Libra_Libra_value);

    // $t8 := >=($t7, $t5)
    call $t8 := $Ge($t7, $t5);

    // $t9 := 11
    $t9 := $Integer(11);

    // $t10 := Errors::limit_exceeded($t9)
    call $t10 := $Errors_limit_exceeded($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 35691, $abort_code);
      goto Abort;
    }

    // if ($t8) goto L0 else goto L1
    if (b#$Boolean($t8)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t6)

    // pack_ref($t6)

    // abort($t10)
    if (true) { assume $DebugTrackAbort(15, 35654, i#$Integer($t10)); }
    $abort_code := i#$Integer($t10);
    goto Abort;

    // L0:
L0:

    // $t11 := get_field<Libra::Libra<#0>>.value($t6)
    call $t11 := $GetFieldFromReference($t6, $Libra_Libra_value);

    // $t12 := -($t11, $t5)
    call $t12 := $Sub($t11, $t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 35768, $abort_code);
      goto Abort;
    }

    // $t13 := borrow_field<Libra::Libra<#0>>.value($t6)
    call $t13 := $BorrowField($t6, $Libra_Libra_value);

    // unpack_ref($t13)

    // write_ref($t13, $t12)
    call $t13 := $WriteRef($t13, $t12);

    // pack_ref($t13)

    // write_back[Reference($t6)]($t13)
    call $t6 := $WritebackToReference($t13, $t6);

    // pack_ref($t6)

    // write_back[LocalRoot($t4)]($t6)
    call $t4 := $WritebackToValue($t6, 4, $t4);

    // $t14 := pack Libra::Libra<#0>($t5)
    call $t14 := $Libra_Libra_pack(0, 0, 0, $tv0, $t5);

    // return ($t14, $t4)
    $ret0 := $t14;
    if (true) { assume $DebugTrackLocal(15, 35786, 15, $ret0); }
    $ret1 := $t4;
    if (true) { assume $DebugTrackLocal(15, 35786, 16, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}

procedure {:inline 1} $Libra_withdraw_$direct_inter($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount)))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount)))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount)))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret1, $Libra_Libra_value), $Integer(i#$Integer(old($SelectField(coin, $Libra_Libra_value))) - i#$Integer(amount))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), amount))));
ensures $Libra_Libra_$is_well_formed($ret0);
ensures $Libra_Libra_$is_well_formed($ret1);

procedure {:inline 1} $Libra_withdraw_$direct_intra($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount)))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount)))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount)))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret1, $Libra_Libra_value), $Integer(i#$Integer(old($SelectField(coin, $Libra_Libra_value))) - i#$Integer(amount))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), amount))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) <= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) >= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) >= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) <= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_to_lbr_exchange_rate), old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_to_lbr_exchange_rate))))))));
ensures $Libra_Libra_$is_well_formed($ret0);
ensures $Libra_Libra_$is_well_formed($ret1);

procedure {:inline 1} $Libra_withdraw($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount)))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount)))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount)))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret1, $Libra_Libra_value), $Integer(i#$Integer(old($SelectField(coin, $Libra_Libra_value))) - i#$Integer(amount))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), amount))));
ensures $Libra_Libra_$is_well_formed($ret0);
ensures $Libra_Libra_$is_well_formed($ret1);

procedure {:inline 1} $Libra_withdraw_all_$def($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    // declare local variables
    var val: $Value; // $IntegerType()
    var $t2: $Value; // $Libra_Libra_type_value($tv0)
    var $t3: $Mutation; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $Libra_Libra_type_value($tv0)
    var $t6: $Value; // $Libra_Libra_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 36315, 0, coin); }

    // bytecode translation starts here
    // $t2 := move(coin)
    call $t2 := $CopyOrMoveValue(coin);

    // $t3 := borrow_local($t2)
    call $t3 := $BorrowLoc(2, $t2);

    // unpack_ref($t3)

    // $t4 := get_field<Libra::Libra<#0>>.value($t3)
    call $t4 := $GetFieldFromReference($t3, $Libra_Libra_value);

    // val := $t4
    call val := $CopyOrMoveValue($t4);
    if (true) { assume $DebugTrackLocal(15, 36408, 1, val); }

    // $t5 := read_ref($t3)
    call $t5 := $ReadRef($t3);
    assert $Libra_Libra_$invariant_holds($t5);

    // ($t6, $t5) := Libra::withdraw<#0>($t5, val)
    call $t6, $t5 := $Libra_withdraw($tv0, $t5, val);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 35506, $abort_code);
      goto Abort;
    }

    // write_ref($t3, $t5)
    call $t3 := $WriteRef($t3, $t5);

    // pack_ref($t3)

    // write_back[LocalRoot($t2)]($t3)
    call $t2 := $WritebackToValue($t3, 2, $t2);

    // return ($t6, $t2)
    $ret0 := $t6;
    if (true) { assume $DebugTrackLocal(15, 36434, 7, $ret0); }
    $ret1 := $t2;
    if (true) { assume $DebugTrackLocal(15, 36434, 8, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}

procedure {:inline 1} $Libra_withdraw_all_$direct_inter($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value, $ret1: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), old($SelectField(coin, $Libra_Libra_value))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret1, $Libra_Libra_value), $Integer(0)))));
ensures $Libra_Libra_$is_well_formed($ret0);
ensures $Libra_Libra_$is_well_formed($ret1);

procedure {:inline 1} $Libra_withdraw_all_$direct_intra($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value, $ret1: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), old($SelectField(coin, $Libra_Libra_value))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret1, $Libra_Libra_value), $Integer(0)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) <= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) >= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) >= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) <= i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_to_lbr_exchange_rate), old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_to_lbr_exchange_rate))))))));
ensures $Libra_Libra_$is_well_formed($ret0);
ensures $Libra_Libra_$is_well_formed($ret1);

procedure {:inline 1} $Libra_withdraw_all($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value, $ret1: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), old($SelectField(coin, $Libra_Libra_value))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret1, $Libra_Libra_value), $Integer(0)))));
ensures $Libra_Libra_$is_well_formed($ret0);
ensures $Libra_Libra_$is_well_formed($ret1);

procedure {:inline 1} $Libra_zero_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $IntegerType()
    var $t1: $Value; // $Libra_Libra_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 50948, $abort_code);
      goto Abort;
    }

    // $t0 := 0
    $t0 := $Integer(0);

    // $t1 := pack Libra::Libra<#0>($t0)
    call $t1 := $Libra_Libra_pack(0, 0, 0, $tv0, $t0);

    // return $t1
    $ret0 := $t1;
    if (true) { assume $DebugTrackLocal(15, 34229, 2, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Libra_zero_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_zero_$def($tv0);
}


procedure {:inline 1} $Libra_zero_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_zero_$def($tv0);
}


procedure {:inline 1} $Libra_zero($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $Libra_zero_$def($tv0);
}




// ** spec vars of module Coin1



// ** spec funs of module Coin1



// ** structs of module Coin1

const unique $Coin1_Coin1: $TypeName;
const $Coin1_Coin1_dummy_field: $FieldName;
axiom $Coin1_Coin1_dummy_field == 0;
function $Coin1_Coin1_type_value(): $TypeValue {
    $StructType($Coin1_Coin1, $EmptyTypeValueArray)
}
var $Coin1_Coin1_$memory: $Memory;
var $Coin1_Coin1_$memory_$old: $Memory;
function {:inline} $Coin1_Coin1_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $Coin1_Coin1_dummy_field))
}
function {:inline} $Coin1_Coin1_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $Coin1_Coin1_$is_well_formed($this: $Value): bool {
    $Coin1_Coin1_$is_well_typed($this) && $Coin1_Coin1_$invariant_holds($this)}

procedure {:inline 1} $Coin1_Coin1_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Coin1_Coin1_unpack($struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $Coin1_Coin1_dummy_field);
    assume is#$Boolean(dummy_field);
}



// ** functions of module Coin1

procedure {:inline 1} $Coin1_initialize_$def(lr_account: $Value, tc_account: $Value) returns ()
{
    // declare local variables
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $Vector_type_value($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(5, 277, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(5, 277, 1, tc_account); }

    // bytecode translation starts here
    // $t2 := move(lr_account)
    call $t2 := $CopyOrMoveValue(lr_account);

    // $t3 := move(tc_account)
    call $t3 := $CopyOrMoveValue(tc_account);

    // LibraTimestamp::assert_genesis()
    call $LibraTimestamp_assert_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(5, 390, $abort_code);
      goto Abort;
    }

    // $t4 := 1
    $t4 := $Integer(1);

    // $t5 := 1
    $t5 := $Integer(1);

    // $t6 := FixedPoint32::create_from_rational($t4, $t5)
    call $t6 := $FixedPoint32_create_from_rational($t4, $t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(5, 527, $abort_code);
      goto Abort;
    }

    // $t7 := 1000000
    $t7 := $Integer(1000000);

    // $t8 := 100
    $t8 := $Integer(100);

    // $t9 := [67, 111, 105, 110, 49]
    $t9 := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := $Integer(67)][1 := $Integer(111)][2 := $Integer(105)][3 := $Integer(110)][4 := $Integer(49)], 5));

    // Libra::register_SCS_currency<Coin1::Coin1>($t2, $t3, $t6, $t7, $t8, $t9)
    call $Libra_register_SCS_currency($Coin1_Coin1_type_value(), $t2, $t3, $t6, $t7, $t8, $t9);
    if ($abort_flag) {
      goto Abort;
    }

    // AccountLimits::publish_unrestricted_limits<Coin1::Coin1>($t2)
    call $AccountLimits_publish_unrestricted_limits($Coin1_Coin1_type_value(), $t2);
    if ($abort_flag) {
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Coin1_initialize_$direct_inter(lr_account: $Value, tc_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume is#$Address(tc_account);

    call $Coin1_initialize_$def(lr_account, tc_account);
}


procedure {:inline 1} $Coin1_initialize_$direct_intra(lr_account: $Value, tc_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume is#$Address(tc_account);

    call $Coin1_initialize_$def(lr_account, tc_account);
}


procedure {:inline 1} $Coin1_initialize(lr_account: $Value, tc_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume is#$Address(tc_account);

    call $Coin1_initialize_$def(lr_account, tc_account);
}




// ** spec vars of module DesignatedDealer



// ** spec funs of module DesignatedDealer

function {:inline} $DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory: $Memory, $tv0: $TypeValue, dd_addr: $Value): $Value {
    $ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)
}

function {:inline} $DesignatedDealer_new_amount$9($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory, $DesignatedDealer_TierInfo_$memory: $Memory, $tv0: $TypeValue, amount: $Value, dd_addr: $Value): $Value {
    if (b#$Boolean($Boolean(i#$Integer($LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)) <= i#$Integer($Integer(i#$Integer($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start)) + i#$Integer($Integer(86400000000))))))) then ($Integer(i#$Integer($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_inflow)) + i#$Integer(amount))) else (amount)
}

function {:inline} $DesignatedDealer_dd_addr$10($tv0: $TypeValue, dd: $Value): $Value {
    $Signer_spec_address_of(dd)
}

function {:inline} $DesignatedDealer_dd_addr$11($tv0: $TypeValue, dd: $Value): $Value {
    $Signer_spec_address_of(dd)
}

function {:inline} $DesignatedDealer_tier_info$12($DesignatedDealer_TierInfo_$memory: $Memory, $tv0: $TypeValue, dd_addr: $Value): $Value {
    $ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)
}

function {:inline} $DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory: $Memory, $tv0: $TypeValue, dd_addr: $Value): $Value {
    $vlen_value($SelectField($DesignatedDealer_tier_info$12($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers))
}

function {:inline} $DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory: $Memory, $tv0: $TypeValue, dd_addr: $Value): $Value {
    $ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)
}

function {:inline} $DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory: $Memory, $tv0: $TypeValue, dd_addr: $Value): $Value {
    $ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)
}

function {:inline} $DesignatedDealer_current_time$16($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory, $tv0: $TypeValue): $Value {
    $LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)
}

function {:inline} $DesignatedDealer_currency_info$17($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue): $Value {
    $ResourceValue($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())
}

function {:inline} $DesignatedDealer_current_time$18($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory, $tv0: $TypeValue): $Value {
    $LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)
}



// ** structs of module DesignatedDealer

const unique $DesignatedDealer_Dealer: $TypeName;
const $DesignatedDealer_Dealer_mint_event_handle: $FieldName;
axiom $DesignatedDealer_Dealer_mint_event_handle == 0;
function $DesignatedDealer_Dealer_type_value(): $TypeValue {
    $StructType($DesignatedDealer_Dealer, $EmptyTypeValueArray)
}
var $DesignatedDealer_Dealer_$memory: $Memory;
var $DesignatedDealer_Dealer_$memory_$old: $Memory;
function {:inline} $DesignatedDealer_Dealer_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && $Event_EventHandle_$is_well_typed($SelectField($this, $DesignatedDealer_Dealer_mint_event_handle))
}
function {:inline} $DesignatedDealer_Dealer_$invariant_holds($this: $Value): bool {
    $Event_EventHandle_$invariant_holds($SelectField($this, $DesignatedDealer_Dealer_mint_event_handle))
}

function {:inline} $DesignatedDealer_Dealer_$is_well_formed($this: $Value): bool {
    $DesignatedDealer_Dealer_$is_well_typed($this) && $DesignatedDealer_Dealer_$invariant_holds($this)}

procedure {:inline 1} $DesignatedDealer_Dealer_pack($file_id: int, $byte_index: int, $var_idx: int, mint_event_handle: $Value) returns ($struct: $Value)
{
    assume $Event_EventHandle_$is_well_formed(mint_event_handle);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := mint_event_handle], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $DesignatedDealer_Dealer_unpack($struct: $Value) returns (mint_event_handle: $Value)
{
    assume is#$Vector($struct);
    mint_event_handle := $SelectField($struct, $DesignatedDealer_Dealer_mint_event_handle);
    assume $Event_EventHandle_$is_well_formed(mint_event_handle);
}

const unique $DesignatedDealer_ReceivedMintEvent: $TypeName;
const $DesignatedDealer_ReceivedMintEvent_currency_code: $FieldName;
axiom $DesignatedDealer_ReceivedMintEvent_currency_code == 0;
const $DesignatedDealer_ReceivedMintEvent_destination_address: $FieldName;
axiom $DesignatedDealer_ReceivedMintEvent_destination_address == 1;
const $DesignatedDealer_ReceivedMintEvent_amount: $FieldName;
axiom $DesignatedDealer_ReceivedMintEvent_amount == 2;
function $DesignatedDealer_ReceivedMintEvent_type_value(): $TypeValue {
    $StructType($DesignatedDealer_ReceivedMintEvent, $EmptyTypeValueArray)
}
var $DesignatedDealer_ReceivedMintEvent_$memory: $Memory;
var $DesignatedDealer_ReceivedMintEvent_$memory_$old: $Memory;
function {:inline} $DesignatedDealer_ReceivedMintEvent_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 3
      && $Vector_$is_well_formed($SelectField($this, $DesignatedDealer_ReceivedMintEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $DesignatedDealer_ReceivedMintEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $DesignatedDealer_ReceivedMintEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $DesignatedDealer_ReceivedMintEvent_currency_code),$$0)))
      && is#$Address($SelectField($this, $DesignatedDealer_ReceivedMintEvent_destination_address))
      && $IsValidU64($SelectField($this, $DesignatedDealer_ReceivedMintEvent_amount))
}
function {:inline} $DesignatedDealer_ReceivedMintEvent_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $DesignatedDealer_ReceivedMintEvent_$is_well_formed($this: $Value): bool {
    $DesignatedDealer_ReceivedMintEvent_$is_well_typed($this) && $DesignatedDealer_ReceivedMintEvent_$invariant_holds($this)}

procedure {:inline 1} $DesignatedDealer_ReceivedMintEvent_pack($file_id: int, $byte_index: int, $var_idx: int, currency_code: $Value, destination_address: $Value, amount: $Value) returns ($struct: $Value)
{
    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    assume is#$Address(destination_address);
    assume $IsValidU64(amount);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := currency_code][1 := destination_address][2 := amount], 3));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $DesignatedDealer_ReceivedMintEvent_unpack($struct: $Value) returns (currency_code: $Value, destination_address: $Value, amount: $Value)
{
    assume is#$Vector($struct);
    currency_code := $SelectField($struct, $DesignatedDealer_ReceivedMintEvent_currency_code);
    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    destination_address := $SelectField($struct, $DesignatedDealer_ReceivedMintEvent_destination_address);
    assume is#$Address(destination_address);
    amount := $SelectField($struct, $DesignatedDealer_ReceivedMintEvent_amount);
    assume $IsValidU64(amount);
}

const unique $DesignatedDealer_TierInfo: $TypeName;
const $DesignatedDealer_TierInfo_window_start: $FieldName;
axiom $DesignatedDealer_TierInfo_window_start == 0;
const $DesignatedDealer_TierInfo_window_inflow: $FieldName;
axiom $DesignatedDealer_TierInfo_window_inflow == 1;
const $DesignatedDealer_TierInfo_tiers: $FieldName;
axiom $DesignatedDealer_TierInfo_tiers == 2;
function $DesignatedDealer_TierInfo_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($DesignatedDealer_TierInfo, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1))
}
var $DesignatedDealer_TierInfo_$memory: $Memory;
var $DesignatedDealer_TierInfo_$memory_$old: $Memory;
function {:inline} $DesignatedDealer_TierInfo_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 3
      && $IsValidU64($SelectField($this, $DesignatedDealer_TierInfo_window_start))
      && $IsValidU64($SelectField($this, $DesignatedDealer_TierInfo_window_inflow))
      && $Vector_$is_well_formed($SelectField($this, $DesignatedDealer_TierInfo_tiers)) && (forall $$0: int :: {$select_vector($SelectField($this, $DesignatedDealer_TierInfo_tiers),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $DesignatedDealer_TierInfo_tiers)) ==> $IsValidU64($select_vector($SelectField($this, $DesignatedDealer_TierInfo_tiers),$$0)))
}
function {:inline} $DesignatedDealer_TierInfo_$invariant_holds($this: $Value): bool {
    b#$Boolean($Boolean(i#$Integer($vlen_value($SelectField($this, $DesignatedDealer_TierInfo_tiers))) <= i#$Integer($Integer(4))))
      && b#$Boolean($Boolean((var $range_1 := $Range($Integer(0), $vlen_value($SelectField($this, $DesignatedDealer_TierInfo_tiers))); (forall $i_0: int :: $InRange($range_1, $i_0) ==> (var i := $Integer($i_0); b#$Boolean($Boolean((var $range_3 := $Range($Integer(0), $vlen_value($SelectField($this, $DesignatedDealer_TierInfo_tiers))); (forall $i_2: int :: $InRange($range_3, $i_2) ==> (var j := $Integer($i_2); b#$Boolean($Boolean(b#$Boolean($Boolean(i#$Integer(i) < i#$Integer(j))) ==> b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($this, $DesignatedDealer_TierInfo_tiers), i)) < i#$Integer($select_vector_by_value($SelectField($this, $DesignatedDealer_TierInfo_tiers), j))))))))))))))))
}

function {:inline} $DesignatedDealer_TierInfo_$is_well_formed($this: $Value): bool {
    $DesignatedDealer_TierInfo_$is_well_typed($this) && $DesignatedDealer_TierInfo_$invariant_holds($this)}

procedure {:inline 1} $DesignatedDealer_TierInfo_$unpack_ref_deep($tv0: $TypeValue, $before: $Value) {
    assume $DesignatedDealer_TierInfo_$invariant_holds($before);
}

procedure {:inline 1} $DesignatedDealer_TierInfo_$unpack_ref($tv0: $TypeValue, $before: $Value) {
    assume $DesignatedDealer_TierInfo_$invariant_holds($before);
}

procedure {:inline 1} $DesignatedDealer_TierInfo_$pack_ref_deep($tv0: $TypeValue, $after: $Value) {
    assert b#$Boolean($Boolean(i#$Integer($vlen_value($SelectField($after, $DesignatedDealer_TierInfo_tiers))) <= i#$Integer($Integer(4))));
    assert b#$Boolean($Boolean((var $range_5 := $Range($Integer(0), $vlen_value($SelectField($after, $DesignatedDealer_TierInfo_tiers))); (forall $i_4: int :: $InRange($range_5, $i_4) ==> (var i := $Integer($i_4); b#$Boolean($Boolean((var $range_7 := $Range($Integer(0), $vlen_value($SelectField($after, $DesignatedDealer_TierInfo_tiers))); (forall $i_6: int :: $InRange($range_7, $i_6) ==> (var j := $Integer($i_6); b#$Boolean($Boolean(b#$Boolean($Boolean(i#$Integer(i) < i#$Integer(j))) ==> b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($after, $DesignatedDealer_TierInfo_tiers), i)) < i#$Integer($select_vector_by_value($SelectField($after, $DesignatedDealer_TierInfo_tiers), j))))))))))))))));
}

procedure {:inline 1} $DesignatedDealer_TierInfo_$pack_ref($tv0: $TypeValue, $after: $Value) {
    assert b#$Boolean($Boolean(i#$Integer($vlen_value($SelectField($after, $DesignatedDealer_TierInfo_tiers))) <= i#$Integer($Integer(4))));
    assert b#$Boolean($Boolean((var $range_9 := $Range($Integer(0), $vlen_value($SelectField($after, $DesignatedDealer_TierInfo_tiers))); (forall $i_8: int :: $InRange($range_9, $i_8) ==> (var i := $Integer($i_8); b#$Boolean($Boolean((var $range_11 := $Range($Integer(0), $vlen_value($SelectField($after, $DesignatedDealer_TierInfo_tiers))); (forall $i_10: int :: $InRange($range_11, $i_10) ==> (var j := $Integer($i_10); b#$Boolean($Boolean(b#$Boolean($Boolean(i#$Integer(i) < i#$Integer(j))) ==> b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($after, $DesignatedDealer_TierInfo_tiers), i)) < i#$Integer($select_vector_by_value($SelectField($after, $DesignatedDealer_TierInfo_tiers), j))))))))))))))));
}

procedure {:inline 1} $DesignatedDealer_TierInfo_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, window_start: $Value, window_inflow: $Value, tiers: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(window_start);
    assume $IsValidU64(window_inflow);
    assume $Vector_$is_well_formed(tiers) && (forall $$0: int :: {$select_vector(tiers,$$0)} $$0 >= 0 && $$0 < $vlen(tiers) ==> $IsValidU64($select_vector(tiers,$$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := window_start][1 := window_inflow][2 := tiers], 3));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
    assert b#$Boolean($Boolean(i#$Integer($vlen_value($SelectField($struct, $DesignatedDealer_TierInfo_tiers))) <= i#$Integer($Integer(4))));
    assert b#$Boolean($Boolean((var $range_1 := $Range($Integer(0), $vlen_value($SelectField($struct, $DesignatedDealer_TierInfo_tiers))); (forall $i_0: int :: $InRange($range_1, $i_0) ==> (var i := $Integer($i_0); b#$Boolean($Boolean((var $range_3 := $Range($Integer(0), $vlen_value($SelectField($struct, $DesignatedDealer_TierInfo_tiers))); (forall $i_2: int :: $InRange($range_3, $i_2) ==> (var j := $Integer($i_2); b#$Boolean($Boolean(b#$Boolean($Boolean(i#$Integer(i) < i#$Integer(j))) ==> b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($struct, $DesignatedDealer_TierInfo_tiers), i)) < i#$Integer($select_vector_by_value($SelectField($struct, $DesignatedDealer_TierInfo_tiers), j))))))))))))))));
}

procedure {:inline 1} $DesignatedDealer_TierInfo_unpack($tv0: $TypeValue, $struct: $Value) returns (window_start: $Value, window_inflow: $Value, tiers: $Value)
{
    assume is#$Vector($struct);
    window_start := $SelectField($struct, $DesignatedDealer_TierInfo_window_start);
    assume $IsValidU64(window_start);
    window_inflow := $SelectField($struct, $DesignatedDealer_TierInfo_window_inflow);
    assume $IsValidU64(window_inflow);
    tiers := $SelectField($struct, $DesignatedDealer_TierInfo_tiers);
    assume $Vector_$is_well_formed(tiers) && (forall $$0: int :: {$select_vector(tiers,$$0)} $$0 >= 0 && $$0 < $vlen(tiers) ==> $IsValidU64($select_vector(tiers,$$0)));
}



// ** functions of module DesignatedDealer

procedure {:inline 1} $DesignatedDealer_reset_window_$def($tv0: $TypeValue, tier_info: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var current_time: $Value; // $IntegerType()
    var tmp#$2: $Value; // $BooleanType()
    var $t3: $Value; // $DesignatedDealer_TierInfo_type_value($tv0)
    var $t4: $Mutation; // ReferenceType($DesignatedDealer_TierInfo_type_value($tv0))
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Mutation; // ReferenceType($IntegerType())
    var $t12: $Value; // $IntegerType()
    var $t13: $Mutation; // ReferenceType($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 17089, 0, tier_info); }

    // bytecode translation starts here
    // $t3 := move(tier_info)
    call $t3 := $CopyOrMoveValue(tier_info);

    // $t4 := borrow_local($t3)
    call $t4 := $BorrowLoc(3, $t3);

    // current_time := LibraTimestamp::now_microseconds()
    call current_time := $LibraTimestamp_now_microseconds();
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 17197, $abort_code);
      goto Abort;
    }

    // $t5 := 86400000000
    $t5 := $Integer(86400000000);

    // $t6 := >(current_time, $t5)
    call $t6 := $Gt(current_time, $t5);

    // if ($t6) goto L0 else goto L1
    if (b#$Boolean($t6)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t7 := 86400000000
    $t7 := $Integer(86400000000);

    // $t8 := -(current_time, $t7)
    call $t8 := $Sub(current_time, $t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 17268, $abort_code);
      goto Abort;
    }

    // $t9 := get_field<DesignatedDealer::TierInfo<#0>>.window_start($t4)
    call $t9 := $GetFieldFromReference($t4, $DesignatedDealer_TierInfo_window_start);

    // tmp#$2 := >($t8, $t9)
    call tmp#$2 := $Gt($t8, $t9);
    if (true) { assume $DebugTrackLocal(7, 17278, 2, tmp#$2); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t10 := false
    $t10 := $Boolean(false);

    // tmp#$2 := $t10
    call tmp#$2 := $CopyOrMoveValue($t10);
    if (true) { assume $DebugTrackLocal(7, 17229, 2, tmp#$2); }

    // goto L3
    goto L3;

    // L3:
L3:

    // if (tmp#$2) goto L4 else goto L5
    if (b#$Boolean(tmp#$2)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // goto L6
    goto L6;

    // L4:
L4:

    // $t11 := borrow_field<DesignatedDealer::TierInfo<#0>>.window_start($t4)
    call $t11 := $BorrowField($t4, $DesignatedDealer_TierInfo_window_start);

    // write_ref($t11, current_time)
    call $t11 := $WriteRef($t11, current_time);

    // write_back[Reference($t4)]($t11)
    call $t4 := $WritebackToReference($t11, $t4);

    // $t12 := 0
    $t12 := $Integer(0);

    // $t13 := borrow_field<DesignatedDealer::TierInfo<#0>>.window_inflow($t4)
    call $t13 := $BorrowField($t4, $DesignatedDealer_TierInfo_window_inflow);

    // write_ref($t13, $t12)
    call $t13 := $WriteRef($t13, $t12);

    // write_back[Reference($t4)]($t13)
    call $t4 := $WritebackToReference($t13, $t4);

    // write_back[LocalRoot($t3)]($t4)
    call $t3 := $WritebackToValue($t4, 3, $t3);

    // goto L7
    goto L7;

    // L6:
L6:

    // destroy($t4)

    // goto L7
    goto L7;

    // L7:
L7:

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(7, 17225, 14, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $DesignatedDealer_reset_window_$direct_intra($tv0: $TypeValue, tier_info: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean(if (b#$Boolean($Boolean(b#$Boolean($Boolean(i#$Integer($DesignatedDealer_current_time$18($LibraTimestamp_CurrentTimeMicroseconds_$memory, $tv0)) > i#$Integer($Integer(86400000000)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($DesignatedDealer_current_time$18($LibraTimestamp_CurrentTimeMicroseconds_$memory, $tv0)) - i#$Integer($Integer(86400000000)))) > i#$Integer($SelectField(old(tier_info), $DesignatedDealer_TierInfo_window_start))))))) then ($Boolean($IsEqual($ret0, $UpdateField($UpdateField(old(tier_info), $DesignatedDealer_TierInfo_window_start, $DesignatedDealer_current_time$18($LibraTimestamp_CurrentTimeMicroseconds_$memory, $tv0)), $DesignatedDealer_TierInfo_window_inflow, $Integer(0))))) else ($Boolean($IsEqual($ret0, old(tier_info))))));
ensures $DesignatedDealer_TierInfo_$is_well_typed($ret0);

procedure {:inline 1} $DesignatedDealer_reset_window($tv0: $TypeValue, tier_info: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean(if (b#$Boolean($Boolean(b#$Boolean($Boolean(i#$Integer($DesignatedDealer_current_time$18($LibraTimestamp_CurrentTimeMicroseconds_$memory, $tv0)) > i#$Integer($Integer(86400000000)))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($DesignatedDealer_current_time$18($LibraTimestamp_CurrentTimeMicroseconds_$memory, $tv0)) - i#$Integer($Integer(86400000000)))) > i#$Integer($SelectField(old(tier_info), $DesignatedDealer_TierInfo_window_start))))))) then ($Boolean($IsEqual($ret0, $UpdateField($UpdateField(old(tier_info), $DesignatedDealer_TierInfo_window_start, $DesignatedDealer_current_time$18($LibraTimestamp_CurrentTimeMicroseconds_$memory, $tv0)), $DesignatedDealer_TierInfo_window_inflow, $Integer(0))))) else ($Boolean($IsEqual($ret0, old(tier_info))))));
ensures $DesignatedDealer_TierInfo_$is_well_typed($ret0);

procedure {:inline 1} $DesignatedDealer_add_currency_$def($tv0: $TypeValue, dd: $Value, tc_account: $Value, $Libra_Preburn_$CallerDomain: [$TypeValueArray, int]bool, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var coin_scaling_factor: $Value; // $IntegerType()
    var dd_addr: $Value; // $AddressType()
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var tmp#$6: $Value; // $BooleanType()
    var tmp#$7: $Value; // $IntegerType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $Vector_type_value($IntegerType())
    var $t20: $Value; // $DesignatedDealer_TierInfo_type_value($tv0)
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $IntegerType()
    var $Libra_Preburn_$SelfDomain: [$TypeValueArray, int]bool;
    var $DesignatedDealer_TierInfo_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 5232, 0, dd); }
    if (true) { assume $DebugTrackLocal(7, 5232, 1, tc_account); }
    $Libra_Preburn_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd)) := true];
    $DesignatedDealer_TierInfo_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd)) := true];

    // bytecode translation starts here
    // $t8 := move(dd)
    call $t8 := $CopyOrMoveValue(dd);

    // $t9 := move(tc_account)
    call $t9 := $CopyOrMoveValue(tc_account);

    // Roles::assert_treasury_compliance($t9)
    call $Roles_assert_treasury_compliance($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 5339, $abort_code);
      goto Abort;
    }

    // dd_addr := Signer::address_of($t8)
    call dd_addr := $Signer_address_of($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 5409, $abort_code);
      goto Abort;
    }

    // $t10 := DesignatedDealer::exists_at(dd_addr)
    call $t10 := $DesignatedDealer_exists_at(dd_addr);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 15501, $abort_code);
      goto Abort;
    }

    // $t11 := 0
    $t11 := $Integer(0);

    // $t12 := Errors::not_published($t11)
    call $t12 := $Errors_not_published($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 5468, $abort_code);
      goto Abort;
    }

    // if ($t10) goto L0 else goto L1
    if (b#$Boolean($t10)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t9)

    // destroy($t8)

    // abort($t12)
    if (true) { assume $DebugTrackAbort(7, 5433, i#$Integer($t12)); }
    $abort_code := i#$Integer($t12);
    goto Abort;

    // L0:
L0:

    // Libra::publish_preburn_to_account<#0>($t8, $t9)
    call $Libra_publish_preburn_to_account($tv0, $t8, $t9, $Libra_Preburn_$SelfDomain);
    if ($abort_flag) {
      goto Abort;
    }

    // $t13 := exists<DesignatedDealer::TierInfo<#0>>(dd_addr)
    $t13 := $ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr);

    // $t14 := !($t13)
    call $t14 := $Not($t13);

    // $t15 := 0
    $t15 := $Integer(0);

    // $t16 := Errors::already_published($t15)
    call $t16 := $Errors_already_published($t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 5623, $abort_code);
      goto Abort;
    }

    // if ($t14) goto L2 else goto L3
    if (b#$Boolean($t14)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // destroy($t9)

    // destroy($t8)

    // abort($t16)
    if (true) { assume $DebugTrackAbort(7, 5570, i#$Integer($t16)); }
    $abort_code := i#$Integer($t16);
    goto Abort;

    // L2:
L2:

    // $t17 := LibraTimestamp::now_microseconds()
    call $t17 := $LibraTimestamp_now_microseconds();
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 5735, $abort_code);
      goto Abort;
    }

    // $t18 := 0
    $t18 := $Integer(0);

    // $t19 := Vector::empty<u64>()
    call $t19 := $Vector_empty($IntegerType());
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 5812, $abort_code);
      goto Abort;
    }

    // $t20 := pack DesignatedDealer::TierInfo<#0>($t17, $t18, $t19)
    call $t20 := $DesignatedDealer_TierInfo_pack(0, 0, 0, $tv0, $t17, $t18, $t19);

    // move_to<DesignatedDealer::TierInfo<#0>>($t20, $t8)
    assert $DesignatedDealer_TierInfo_$SelfDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($Signer_spec_address_of($t8))];
    call $DesignatedDealer_TierInfo_$memory := $MoveTo($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t20, $t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 5660, $abort_code);
      goto Abort;
    }

    // coin_scaling_factor := Libra::scaling_factor<#0>()
    call coin_scaling_factor := $Libra_scaling_factor($tv0);
    if ($abort_flag) {
      goto Abort;
    }

    // $t21 := 500000
    $t21 := $Integer(500000);

    // $t22 := *($t21, coin_scaling_factor)
    call $t22 := $MulU64($t21, coin_scaling_factor);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 6019, $abort_code);
      goto Abort;
    }

    // DesignatedDealer::add_tier<#0>($t9, dd_addr, $t22)
    call $DesignatedDealer_add_tier($tv0, $t9, dd_addr, $t22, $DesignatedDealer_TierInfo_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 7671, $abort_code);
      goto Abort;
    }

    // $t23 := 5000000
    $t23 := $Integer(5000000);

    // $t24 := *($t23, coin_scaling_factor)
    call $t24 := $MulU64($t23, coin_scaling_factor);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 6106, $abort_code);
      goto Abort;
    }

    // DesignatedDealer::add_tier<#0>($t9, dd_addr, $t24)
    call $DesignatedDealer_add_tier($tv0, $t9, dd_addr, $t24, $DesignatedDealer_TierInfo_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 7671, $abort_code);
      goto Abort;
    }

    // $t25 := 50000000
    $t25 := $Integer(50000000);

    // $t26 := *($t25, coin_scaling_factor)
    call $t26 := $MulU64($t25, coin_scaling_factor);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 6193, $abort_code);
      goto Abort;
    }

    // DesignatedDealer::add_tier<#0>($t9, dd_addr, $t26)
    call $DesignatedDealer_add_tier($tv0, $t9, dd_addr, $t26, $DesignatedDealer_TierInfo_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 7671, $abort_code);
      goto Abort;
    }

    // $t27 := 500000000
    $t27 := $Integer(500000000);

    // $t28 := *($t27, coin_scaling_factor)
    call $t28 := $MulU64($t27, coin_scaling_factor);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 6280, $abort_code);
      goto Abort;
    }

    // DesignatedDealer::add_tier<#0>($t9, dd_addr, $t28)
    call $DesignatedDealer_add_tier($tv0, $t9, dd_addr, $t28, $DesignatedDealer_TierInfo_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 7671, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $DesignatedDealer_add_currency_$direct_inter($tv0: $TypeValue, dd: $Value, tc_account: $Value, $Libra_Preburn_$CallerDomain: [$TypeValueArray, int]bool, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $Libra_Preburn_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd))];
requires $DesignatedDealer_TierInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd))];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)), $Roles_RoleId_role_id), $Integer(2))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$11($tv0, dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)))) ==> $abort_flag;
ensures b#$Boolean(old($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> $abort_flag;
ensures b#$Boolean(old($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)), $Roles_RoleId_role_id), $Integer(2)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$11($tv0, dd))))))
    || b#$Boolean(old($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd))))
    || b#$Boolean(old($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0)))
    || b#$Boolean(old($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)), $Roles_RoleId_role_id), $Integer(2))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$11($tv0, dd)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)), $Vector($ExtendValueArray($ExtendValueArray($ExtendValueArray($EmptyValueArray(), $LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)), $Integer(0)), $SelectField($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)), $DesignatedDealer_TierInfo_tiers)))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($vlen_value($SelectField($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)), $DesignatedDealer_TierInfo_tiers)), $Integer(4)))));
modifies $Libra_Preburn_$memory;
ensures contents#$Memory($Libra_Preburn_$memory) == old(contents#$Memory($Libra_Preburn_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd)) := contents#$Memory($Libra_Preburn_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd))]];
ensures domain#$Memory($Libra_Preburn_$memory) == old(domain#$Memory($Libra_Preburn_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd)) := domain#$Memory($Libra_Preburn_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd))]];
modifies $DesignatedDealer_TierInfo_$memory;
ensures contents#$Memory($DesignatedDealer_TierInfo_$memory) == old(contents#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd)) := contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd))]];
ensures domain#$Memory($DesignatedDealer_TierInfo_$memory) == old(domain#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd)) := domain#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd))]];

procedure {:inline 1} $DesignatedDealer_add_currency_$direct_intra($tv0: $TypeValue, dd: $Value, tc_account: $Value, $Libra_Preburn_$CallerDomain: [$TypeValueArray, int]bool, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $Libra_Preburn_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd))];
requires $DesignatedDealer_TierInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd))];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)), $Roles_RoleId_role_id), $Integer(2))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$11($tv0, dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)))) ==> $abort_flag;
ensures b#$Boolean(old($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> $abort_flag;
ensures b#$Boolean(old($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)), $Roles_RoleId_role_id), $Integer(2)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$11($tv0, dd))))))
    || b#$Boolean(old($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd))))
    || b#$Boolean(old($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0)))
    || b#$Boolean(old($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)), $Roles_RoleId_role_id), $Integer(2))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$11($tv0, dd)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)), $Vector($ExtendValueArray($ExtendValueArray($ExtendValueArray($EmptyValueArray(), $LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)), $Integer(0)), $SelectField($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)), $DesignatedDealer_TierInfo_tiers)))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($vlen_value($SelectField($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)), $DesignatedDealer_TierInfo_tiers)), $Integer(4)))));
modifies $Libra_Preburn_$memory;
ensures contents#$Memory($Libra_Preburn_$memory) == old(contents#$Memory($Libra_Preburn_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd)) := contents#$Memory($Libra_Preburn_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd))]];
ensures domain#$Memory($Libra_Preburn_$memory) == old(domain#$Memory($Libra_Preburn_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd)) := domain#$Memory($Libra_Preburn_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd))]];
modifies $DesignatedDealer_TierInfo_$memory;
ensures contents#$Memory($DesignatedDealer_TierInfo_$memory) == old(contents#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd)) := contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd))]];
ensures domain#$Memory($DesignatedDealer_TierInfo_$memory) == old(domain#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd)) := domain#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd))]];

procedure {:inline 1} $DesignatedDealer_add_currency($tv0: $TypeValue, dd: $Value, tc_account: $Value, $Libra_Preburn_$CallerDomain: [$TypeValueArray, int]bool, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $Libra_Preburn_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd))];
requires $DesignatedDealer_TierInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd))];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)), $Roles_RoleId_role_id), $Integer(2))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$11($tv0, dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)))) ==> $abort_flag;
ensures b#$Boolean(old($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0))) ==> $abort_flag;
ensures b#$Boolean(old($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)), $Roles_RoleId_role_id), $Integer(2)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$11($tv0, dd))))))
    || b#$Boolean(old($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd))))
    || b#$Boolean(old($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0)))
    || b#$Boolean(old($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)), $Roles_RoleId_role_id), $Integer(2))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$11($tv0, dd)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)), $Vector($ExtendValueArray($ExtendValueArray($ExtendValueArray($EmptyValueArray(), $LibraTimestamp_spec_now_microseconds($LibraTimestamp_CurrentTimeMicroseconds_$memory)), $Integer(0)), $SelectField($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)), $DesignatedDealer_TierInfo_tiers)))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($vlen_value($SelectField($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$11($tv0, dd)), $DesignatedDealer_TierInfo_tiers)), $Integer(4)))));
modifies $Libra_Preburn_$memory;
ensures contents#$Memory($Libra_Preburn_$memory) == old(contents#$Memory($Libra_Preburn_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd)) := contents#$Memory($Libra_Preburn_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd))]];
ensures domain#$Memory($Libra_Preburn_$memory) == old(domain#$Memory($Libra_Preburn_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd)) := domain#$Memory($Libra_Preburn_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd))]];
modifies $DesignatedDealer_TierInfo_$memory;
ensures contents#$Memory($DesignatedDealer_TierInfo_$memory) == old(contents#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd)) := contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd))]];
ensures domain#$Memory($DesignatedDealer_TierInfo_$memory) == old(domain#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd)) := domain#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$11($tv0, dd))]];

procedure {:inline 1} $DesignatedDealer_add_tier_$def($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_upperbound: $Value, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var last_tier: $Value; // $IntegerType()
    var number_of_tiers: $Value; // $IntegerType()
    var tiers: $Mutation; // ReferenceType($Vector_type_value($IntegerType()))
    var tmp#$6: $Value; // $BooleanType()
    var tmp#$7: $Value; // $IntegerType()
    var tmp#$8: $Value; // $BooleanType()
    var tmp#$9: $Value; // $IntegerType()
    var tmp#$10: $Mutation; // ReferenceType($Vector_type_value($IntegerType()))
    var tmp#$11: $Value; // $IntegerType()
    var tmp#$12: $Value; // $BooleanType()
    var tmp#$13: $Value; // $IntegerType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Mutation; // ReferenceType($DesignatedDealer_TierInfo_type_value($tv0))
    var $t21: $Value; // $Vector_type_value($IntegerType())
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $BooleanType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $BooleanType()
    var $t30: $Value; // $IntegerType()
    var $t31: $Value; // $IntegerType()
    var $t32: $Value; // $Vector_type_value($IntegerType())
    var $t33: $Value; // $IntegerType()
    var $t34: $Value; // $BooleanType()
    var $t35: $Value; // $IntegerType()
    var $t36: $Value; // $IntegerType()
    var $t37: $Value; // $Vector_type_value($IntegerType())
    var $DesignatedDealer_TierInfo_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 7660, 0, tc_account); }
    if (true) { assume $DebugTrackLocal(7, 7660, 1, dd_addr); }
    if (true) { assume $DebugTrackLocal(7, 7660, 2, tier_upperbound); }
    $DesignatedDealer_TierInfo_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := true];

    // bytecode translation starts here
    // $t14 := move(tc_account)
    call $t14 := $CopyOrMoveValue(tc_account);

    // $t15 := move(dd_addr)
    call $t15 := $CopyOrMoveValue(dd_addr);

    // $t16 := move(tier_upperbound)
    call $t16 := $CopyOrMoveValue(tier_upperbound);

    // Roles::assert_treasury_compliance($t14)
    call $Roles_assert_treasury_compliance($t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 7816, $abort_code);
      goto Abort;
    }

    // $t17 := exists<DesignatedDealer::TierInfo<#0>>($t15)
    $t17 := $ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t15);

    // $t18 := 0
    $t18 := $Integer(0);

    // $t19 := Errors::not_published($t18)
    call $t19 := $Errors_not_published($t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 7916, $abort_code);
      goto Abort;
    }

    // if ($t17) goto L0 else goto L1
    if (b#$Boolean($t17)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t19)
    if (true) { assume $DebugTrackAbort(7, 7864, i#$Integer($t19)); }
    $abort_code := i#$Integer($t19);
    goto Abort;

    // L0:
L0:

    // $t20 := borrow_global<DesignatedDealer::TierInfo<#0>>($t15)
    assert $DesignatedDealer_TierInfo_$SelfDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($t15)];
    call $t20 := $BorrowGlobal($DesignatedDealer_TierInfo_$memory, $t15, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 7966, $abort_code);
      goto Abort;
    }

    // unpack_ref($t20)
    call $DesignatedDealer_TierInfo_$unpack_ref($tv0, $Dereference($t20));

    // tiers := borrow_field<DesignatedDealer::TierInfo<#0>>.tiers($t20)
    call tiers := $BorrowField($t20, $DesignatedDealer_TierInfo_tiers);

    // unpack_ref(tiers)

    // $t21 := read_ref(tiers)
    call $t21 := $ReadRef(tiers);

    // number_of_tiers := Vector::length<u64>($t21)
    call number_of_tiers := $Vector_length($IntegerType(), $t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 8058, $abort_code);
      goto Abort;
    }

    // $t22 := 1
    $t22 := $Integer(1);

    // $t23 := +(number_of_tiers, $t22)
    call $t23 := $AddU64(number_of_tiers, $t22);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 8104, $abort_code);
      goto Abort;
    }

    // $t24 := 4
    $t24 := $Integer(4);

    // $t25 := <=($t23, $t24)
    call $t25 := $Le($t23, $t24);

    // $t26 := 1
    $t26 := $Integer(1);

    // $t27 := Errors::invalid_argument($t26)
    call $t27 := $Errors_invalid_argument($t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 8134, $abort_code);
      goto Abort;
    }

    // if ($t25) goto L2 else goto L3
    if (b#$Boolean($t25)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // destroy(tiers)

    // pack_ref(tiers)

    // pack_ref($t20)
    call $DesignatedDealer_TierInfo_$pack_ref($tv0, $Dereference($t20));

    // abort($t27)
    if (true) { assume $DebugTrackAbort(7, 8081, i#$Integer($t27)); }
    $abort_code := i#$Integer($t27);
    goto Abort;

    // L2:
L2:

    // $t28 := 0
    $t28 := $Integer(0);

    // $t29 := >(number_of_tiers, $t28)
    call $t29 := $Gt(number_of_tiers, $t28);

    // if ($t29) goto L4 else goto L5
    if (b#$Boolean($t29)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // goto L6
    goto L6;

    // L4:
L4:

    // $t30 := 1
    $t30 := $Integer(1);

    // $t31 := -(number_of_tiers, $t30)
    call $t31 := $Sub(number_of_tiers, $t30);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 8279, $abort_code);
      goto Abort;
    }

    // $t32 := read_ref(tiers)
    call $t32 := $ReadRef(tiers);

    // $t33 := Vector::borrow<u64>($t32, $t31)
    call $t33 := $Vector_borrow($IntegerType(), $t32, $t31);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 8249, $abort_code);
      goto Abort;
    }

    // last_tier := $t33
    call last_tier := $CopyOrMoveValue($t33);
    if (true) { assume $DebugTrackLocal(7, 8228, 3, last_tier); }

    // $t34 := <(last_tier, $t16)
    call $t34 := $Lt(last_tier, $t16);

    // $t35 := 2
    $t35 := $Integer(2);

    // $t36 := Errors::invalid_argument($t35)
    call $t36 := $Errors_invalid_argument($t35);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 8341, $abort_code);
      goto Abort;
    }

    // if ($t34) goto L6 else goto L7
    if (b#$Boolean($t34)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // destroy(tiers)

    // pack_ref(tiers)

    // pack_ref($t20)
    call $DesignatedDealer_TierInfo_$pack_ref($tv0, $Dereference($t20));

    // abort($t36)
    if (true) { assume $DebugTrackAbort(7, 8297, i#$Integer($t36)); }
    $abort_code := i#$Integer($t36);
    goto Abort;

    // L6:
L6:

    // $t37 := read_ref(tiers)
    call $t37 := $ReadRef(tiers);

    // $t37 := Vector::push_back<u64>($t37, $t16)
    call $t37 := $Vector_push_back($IntegerType(), $t37, $t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 8408, $abort_code);
      goto Abort;
    }

    // write_ref(tiers, $t37)
    call tiers := $WriteRef(tiers, $t37);
    if (true) { assume $DebugTrackLocal(7, 8408, 5, $Dereference(tiers)); }

    // pack_ref(tiers)

    // write_back[Reference($t20)](tiers)
    call $t20 := $WritebackToReference(tiers, $t20);

    // pack_ref($t20)
    call $DesignatedDealer_TierInfo_$pack_ref($tv0, $Dereference($t20));

    // write_back[DesignatedDealer::TierInfo]($t20)
    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, $t20);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $DesignatedDealer_add_tier_$direct_inter($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_upperbound: $Value, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $DesignatedDealer_TierInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean($IsEqual($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $Integer(4))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$12($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)) - i#$Integer($Integer(1))))) >= i#$Integer(tier_upperbound)))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)))))
    || b#$Boolean(old($Boolean($IsEqual($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $Integer(4)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$12($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)) - i#$Integer($Integer(1))))) >= i#$Integer(tier_upperbound)))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean($IsEqual($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $Integer(4))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$12($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)) - i#$Integer($Integer(1))))) >= i#$Integer(tier_upperbound)))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr), $Vector($ExtendValueArray($ExtendValueArray($ExtendValueArray($EmptyValueArray(), $SelectField(old($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)), $DesignatedDealer_TierInfo_window_start)), $SelectField(old($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)), $DesignatedDealer_TierInfo_window_inflow)), $append_vector($SelectField(old($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)), $DesignatedDealer_TierInfo_tiers), $single_vector(tier_upperbound))))))));
modifies $DesignatedDealer_TierInfo_$memory;
ensures contents#$Memory($DesignatedDealer_TierInfo_$memory) == old(contents#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)]];
ensures domain#$Memory($DesignatedDealer_TierInfo_$memory) == old(domain#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := domain#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)]];

procedure {:inline 1} $DesignatedDealer_add_tier_$direct_intra($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_upperbound: $Value, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $DesignatedDealer_TierInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean($IsEqual($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $Integer(4))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$12($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)) - i#$Integer($Integer(1))))) >= i#$Integer(tier_upperbound)))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)))))
    || b#$Boolean(old($Boolean($IsEqual($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $Integer(4)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$12($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)) - i#$Integer($Integer(1))))) >= i#$Integer(tier_upperbound)))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean($IsEqual($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $Integer(4))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$12($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)) - i#$Integer($Integer(1))))) >= i#$Integer(tier_upperbound)))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr), $Vector($ExtendValueArray($ExtendValueArray($ExtendValueArray($EmptyValueArray(), $SelectField(old($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)), $DesignatedDealer_TierInfo_window_start)), $SelectField(old($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)), $DesignatedDealer_TierInfo_window_inflow)), $append_vector($SelectField(old($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)), $DesignatedDealer_TierInfo_tiers), $single_vector(tier_upperbound))))))));
modifies $DesignatedDealer_TierInfo_$memory;
ensures contents#$Memory($DesignatedDealer_TierInfo_$memory) == old(contents#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)]];
ensures domain#$Memory($DesignatedDealer_TierInfo_$memory) == old(domain#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := domain#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)]];

procedure {:inline 1} $DesignatedDealer_add_tier($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_upperbound: $Value, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $DesignatedDealer_TierInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean($IsEqual($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $Integer(4))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$12($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)) - i#$Integer($Integer(1))))) >= i#$Integer(tier_upperbound)))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)))))
    || b#$Boolean(old($Boolean($IsEqual($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $Integer(4)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$12($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)) - i#$Integer($Integer(1))))) >= i#$Integer(tier_upperbound)))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean($IsEqual($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $Integer(4))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$12($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer($DesignatedDealer_number_of_tiers$13($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)) - i#$Integer($Integer(1))))) >= i#$Integer(tier_upperbound)))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr), $Vector($ExtendValueArray($ExtendValueArray($ExtendValueArray($EmptyValueArray(), $SelectField(old($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)), $DesignatedDealer_TierInfo_window_start)), $SelectField(old($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)), $DesignatedDealer_TierInfo_window_inflow)), $append_vector($SelectField(old($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)), $DesignatedDealer_TierInfo_tiers), $single_vector(tier_upperbound))))))));
modifies $DesignatedDealer_TierInfo_$memory;
ensures contents#$Memory($DesignatedDealer_TierInfo_$memory) == old(contents#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)]];
ensures domain#$Memory($DesignatedDealer_TierInfo_$memory) == old(domain#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := domain#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)]];

procedure {:inline 1} $DesignatedDealer_exists_at_$def(dd_addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 15490, 0, dd_addr); }

    // bytecode translation starts here
    // $t1 := move(dd_addr)
    call $t1 := $CopyOrMoveValue(dd_addr);

    // $t2 := exists<DesignatedDealer::Dealer>($t1)
    $t2 := $ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $t1);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(7, 15545, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $DesignatedDealer_exists_at_$direct_inter(dd_addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, dd_addr)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $DesignatedDealer_exists_at_$direct_intra(dd_addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, dd_addr)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $DesignatedDealer_exists_at(dd_addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, dd_addr)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $DesignatedDealer_publish_designated_dealer_credential_$def($tv0: $TypeValue, dd: $Value, tc_account: $Value, add_all_currencies: $Value, $DesignatedDealer_Dealer_$CallerDomain: [$TypeValueArray, int]bool, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $Event_EventHandle_type_value($DesignatedDealer_ReceivedMintEvent_type_value())
    var $t14: $Value; // $DesignatedDealer_Dealer_type_value()
    var $DesignatedDealer_Dealer_$SelfDomain: [$TypeValueArray, int]bool;
    var $DesignatedDealer_TierInfo_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 3332, 0, dd); }
    if (true) { assume $DebugTrackLocal(7, 3332, 1, tc_account); }
    if (true) { assume $DebugTrackLocal(7, 3332, 2, add_all_currencies); }
    $DesignatedDealer_Dealer_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := true];
    $DesignatedDealer_TierInfo_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := true][$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := true];

    // bytecode translation starts here
    // $t5 := move(dd)
    call $t5 := $CopyOrMoveValue(dd);

    // $t6 := move(tc_account)
    call $t6 := $CopyOrMoveValue(tc_account);

    // $t7 := move(add_all_currencies)
    call $t7 := $CopyOrMoveValue(add_all_currencies);

    // Roles::assert_treasury_compliance($t6)
    call $Roles_assert_treasury_compliance($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 3516, $abort_code);
      goto Abort;
    }

    // Roles::assert_designated_dealer($t5)
    call $Roles_assert_designated_dealer($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 3571, $abort_code);
      goto Abort;
    }

    // $t8 := Signer::address_of($t5)
    call $t8 := $Signer_address_of($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 3640, $abort_code);
      goto Abort;
    }

    // $t9 := exists<DesignatedDealer::Dealer>($t8)
    $t9 := $ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $t8);

    // $t10 := !($t9)
    call $t10 := $Not($t9);

    // $t11 := 0
    $t11 := $Integer(0);

    // $t12 := Errors::already_published($t11)
    call $t12 := $Errors_already_published($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 3665, $abort_code);
      goto Abort;
    }

    // if ($t10) goto L0 else goto L1
    if (b#$Boolean($t10)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t6)

    // destroy($t5)

    // abort($t12)
    if (true) { assume $DebugTrackAbort(7, 3609, i#$Integer($t12)); }
    $abort_code := i#$Integer($t12);
    goto Abort;

    // L0:
L0:

    // $t13 := Event::new_event_handle<DesignatedDealer::ReceivedMintEvent>($t5)
    call $t13 := $Event_new_event_handle($DesignatedDealer_ReceivedMintEvent_type_value(), $t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 3749, $abort_code);
      goto Abort;
    }

    // $t14 := pack DesignatedDealer::Dealer($t13)
    call $t14 := $DesignatedDealer_Dealer_pack(0, 0, 0, $t13);

    // move_to<DesignatedDealer::Dealer>($t14, $t5)
    assert $DesignatedDealer_Dealer_$SelfDomain[$EmptyTypeValueArray, a#$Address($Signer_spec_address_of($t5))];
    call $DesignatedDealer_Dealer_$memory := $MoveTo($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $t14, $t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 3702, $abort_code);
      goto Abort;
    }

    // if ($t7) goto L2 else goto L3
    if (b#$Boolean($t7)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // goto L4
    goto L4;

    // L2:
L2:

    // DesignatedDealer::add_currency<Coin1::Coin1>($t5, $t6)
    call $DesignatedDealer_add_currency($Coin1_Coin1_type_value(), $t5, $t6, $ConstMemoryDomain(true), $DesignatedDealer_TierInfo_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 5243, $abort_code);
      goto Abort;
    }

    // goto L5
    goto L5;

    // L4:
L4:

    // DesignatedDealer::add_currency<#0>($t5, $t6)
    call $DesignatedDealer_add_currency($tv0, $t5, $t6, $ConstMemoryDomain(true), $DesignatedDealer_TierInfo_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 5243, $abort_code);
      goto Abort;
    }

    // goto L5
    goto L5;

    // L5:
L5:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $DesignatedDealer_publish_designated_dealer_credential_$direct_inter($tv0: $TypeValue, dd: $Value, tc_account: $Value, add_all_currencies: $Value, $DesignatedDealer_Dealer_$CallerDomain: [$TypeValueArray, int]bool, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $DesignatedDealer_Dealer_$CallerDomain[$EmptyTypeValueArray, a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))];
requires $DesignatedDealer_TierInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))];
requires $DesignatedDealer_TierInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)), $Roles_RoleId_role_id), $Integer(2))))) ==> $abort_flag;
ensures b#$Boolean(old($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$10($tv0, dd)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value()))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value()))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)), $Roles_RoleId_role_id), $Integer(2)))))
    || b#$Boolean(old($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$10($tv0, dd))))
    || b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd))))))
    || b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value())))))
    || b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd))))))
    || b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value())))))))
    || b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)), $Roles_RoleId_role_id), $Integer(2))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$10($tv0, dd)))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value()))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value()))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$10($tv0, dd))));
ensures !$abort_flag ==> (b#$Boolean(if (b#$Boolean(add_all_currencies)) then ($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd))) else ($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))));
modifies $Libra_Preburn_$memory;
modifies $DesignatedDealer_Dealer_$memory;
ensures contents#$Memory($DesignatedDealer_Dealer_$memory) == old(contents#$Memory($DesignatedDealer_Dealer_$memory))[$EmptyTypeValueArray, a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := contents#$Memory($DesignatedDealer_Dealer_$memory)[$EmptyTypeValueArray, a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))]];
ensures domain#$Memory($DesignatedDealer_Dealer_$memory) == old(domain#$Memory($DesignatedDealer_Dealer_$memory))[$EmptyTypeValueArray, a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := domain#$Memory($DesignatedDealer_Dealer_$memory)[$EmptyTypeValueArray, a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))]];
modifies $DesignatedDealer_TierInfo_$memory;
ensures contents#$Memory($DesignatedDealer_TierInfo_$memory) == old(contents#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))]][$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))]];
ensures domain#$Memory($DesignatedDealer_TierInfo_$memory) == old(domain#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := domain#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))]][$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := domain#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))]];

procedure {:inline 1} $DesignatedDealer_publish_designated_dealer_credential_$direct_intra($tv0: $TypeValue, dd: $Value, tc_account: $Value, add_all_currencies: $Value, $DesignatedDealer_Dealer_$CallerDomain: [$TypeValueArray, int]bool, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $DesignatedDealer_Dealer_$CallerDomain[$EmptyTypeValueArray, a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))];
requires $DesignatedDealer_TierInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))];
requires $DesignatedDealer_TierInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)), $Roles_RoleId_role_id), $Integer(2))))) ==> $abort_flag;
ensures b#$Boolean(old($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$10($tv0, dd)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value()))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value()))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)), $Roles_RoleId_role_id), $Integer(2)))))
    || b#$Boolean(old($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$10($tv0, dd))))
    || b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd))))))
    || b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value())))))
    || b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd))))))
    || b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value())))))))
    || b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)), $Roles_RoleId_role_id), $Integer(2))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$10($tv0, dd)))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value()))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value()))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$10($tv0, dd))));
ensures !$abort_flag ==> (b#$Boolean(if (b#$Boolean(add_all_currencies)) then ($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd))) else ($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))));
modifies $Libra_Preburn_$memory;
modifies $DesignatedDealer_Dealer_$memory;
ensures contents#$Memory($DesignatedDealer_Dealer_$memory) == old(contents#$Memory($DesignatedDealer_Dealer_$memory))[$EmptyTypeValueArray, a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := contents#$Memory($DesignatedDealer_Dealer_$memory)[$EmptyTypeValueArray, a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))]];
ensures domain#$Memory($DesignatedDealer_Dealer_$memory) == old(domain#$Memory($DesignatedDealer_Dealer_$memory))[$EmptyTypeValueArray, a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := domain#$Memory($DesignatedDealer_Dealer_$memory)[$EmptyTypeValueArray, a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))]];
modifies $DesignatedDealer_TierInfo_$memory;
ensures contents#$Memory($DesignatedDealer_TierInfo_$memory) == old(contents#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))]][$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))]];
ensures domain#$Memory($DesignatedDealer_TierInfo_$memory) == old(domain#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := domain#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))]][$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := domain#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))]];

procedure {:inline 1} $DesignatedDealer_publish_designated_dealer_credential($tv0: $TypeValue, dd: $Value, tc_account: $Value, add_all_currencies: $Value, $DesignatedDealer_Dealer_$CallerDomain: [$TypeValueArray, int]bool, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $DesignatedDealer_Dealer_$CallerDomain[$EmptyTypeValueArray, a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))];
requires $DesignatedDealer_TierInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))];
requires $DesignatedDealer_TierInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)), $Roles_RoleId_role_id), $Integer(2))))) ==> $abort_flag;
ensures b#$Boolean(old($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$10($tv0, dd)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value()))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value()))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)), $Roles_RoleId_role_id), $Integer(2)))))
    || b#$Boolean(old($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$10($tv0, dd))))
    || b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd))))))
    || b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value())))))
    || b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd))))))
    || b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value())))))))
    || b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$39(dd)), $Roles_RoleId_role_id), $Integer(2))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$10($tv0, dd)))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value()))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value()))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, $DesignatedDealer_dd_addr$10($tv0, dd))));
ensures !$abort_flag ==> (b#$Boolean(if (b#$Boolean(add_all_currencies)) then ($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), $DesignatedDealer_dd_addr$10($tv0, dd))) else ($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $DesignatedDealer_dd_addr$10($tv0, dd)))));
modifies $Libra_Preburn_$memory;
modifies $DesignatedDealer_Dealer_$memory;
ensures contents#$Memory($DesignatedDealer_Dealer_$memory) == old(contents#$Memory($DesignatedDealer_Dealer_$memory))[$EmptyTypeValueArray, a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := contents#$Memory($DesignatedDealer_Dealer_$memory)[$EmptyTypeValueArray, a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))]];
ensures domain#$Memory($DesignatedDealer_Dealer_$memory) == old(domain#$Memory($DesignatedDealer_Dealer_$memory))[$EmptyTypeValueArray, a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := domain#$Memory($DesignatedDealer_Dealer_$memory)[$EmptyTypeValueArray, a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))]];
modifies $DesignatedDealer_TierInfo_$memory;
ensures contents#$Memory($DesignatedDealer_TierInfo_$memory) == old(contents#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))]][$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))]];
ensures domain#$Memory($DesignatedDealer_TierInfo_$memory) == old(domain#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := domain#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))]][$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd)) := domain#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), a#$Address($DesignatedDealer_dd_addr$10($tv0, dd))]];

procedure {:inline 1} $DesignatedDealer_tiered_mint_$def($tv0: $TypeValue, tc_account: $Value, amount: $Value, dd_addr: $Value, tier_index: $Value, $Libra_CurrencyInfo_$CallerDomain: [$TypeValueArray, int]bool, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var tmp#$6: $Value; // $BooleanType()
    var tmp#$7: $Value; // $IntegerType()
    var tmp#$8: $Value; // $BooleanType()
    var tmp#$9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $BooleanType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $BooleanType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $IntegerType()
    var $t24: $Mutation; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t25: $Mutation; // ReferenceType($Event_EventHandle_type_value($DesignatedDealer_ReceivedMintEvent_type_value()))
    var $t26: $Value; // $Vector_type_value($IntegerType())
    var $t27: $Value; // $DesignatedDealer_ReceivedMintEvent_type_value()
    var $t28: $Value; // $Event_EventHandle_type_value($DesignatedDealer_ReceivedMintEvent_type_value())
    var $t29: $Value; // $Libra_Libra_type_value($tv0)
    var $Libra_CurrencyInfo_$SelfDomain: [$TypeValueArray, int]bool;
    var $DesignatedDealer_TierInfo_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 12148, 0, tc_account); }
    if (true) { assume $DebugTrackLocal(7, 12148, 1, amount); }
    if (true) { assume $DebugTrackLocal(7, 12148, 2, dd_addr); }
    if (true) { assume $DebugTrackLocal(7, 12148, 3, tier_index); }
    $Libra_CurrencyInfo_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := true];
    $DesignatedDealer_TierInfo_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := true];

    // bytecode translation starts here
    // $t10 := move(tc_account)
    call $t10 := $CopyOrMoveValue(tc_account);

    // $t11 := move(amount)
    call $t11 := $CopyOrMoveValue(amount);

    // $t12 := move(dd_addr)
    call $t12 := $CopyOrMoveValue(dd_addr);

    // $t13 := move(tier_index)
    call $t13 := $CopyOrMoveValue(tier_index);

    // Roles::assert_treasury_compliance($t10)
    call $Roles_assert_treasury_compliance($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 12356, $abort_code);
      goto Abort;
    }

    // $t14 := 0
    $t14 := $Integer(0);

    // $t15 := >($t11, $t14)
    call $t15 := $Gt($t11, $t14);

    // $t16 := 4
    $t16 := $Integer(4);

    // $t17 := Errors::invalid_argument($t16)
    call $t17 := $Errors_invalid_argument($t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 12431, $abort_code);
      goto Abort;
    }

    // if ($t15) goto L0 else goto L1
    if (b#$Boolean($t15)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t10)

    // abort($t17)
    if (true) { assume $DebugTrackAbort(7, 12404, i#$Integer($t17)); }
    $abort_code := i#$Integer($t17);
    goto Abort;

    // L0:
L0:

    // $t18 := DesignatedDealer::exists_at($t12)
    call $t18 := $DesignatedDealer_exists_at($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 15501, $abort_code);
      goto Abort;
    }

    // $t19 := 0
    $t19 := $Integer(0);

    // $t20 := Errors::not_published($t19)
    call $t20 := $Errors_not_published($t19);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 12515, $abort_code);
      goto Abort;
    }

    // if ($t18) goto L2 else goto L3
    if (b#$Boolean($t18)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // destroy($t10)

    // abort($t20)
    if (true) { assume $DebugTrackAbort(7, 12480, i#$Integer($t20)); }
    $abort_code := i#$Integer($t20);
    goto Abort;

    // L2:
L2:

    // $t21 := exists<DesignatedDealer::TierInfo<#0>>($t12)
    $t21 := $ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t12);

    // $t22 := 0
    $t22 := $Integer(0);

    // $t23 := Errors::not_published($t22)
    call $t23 := $Errors_not_published($t22);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 12600, $abort_code);
      goto Abort;
    }

    // if ($t21) goto L4 else goto L5
    if (b#$Boolean($t21)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // destroy($t10)

    // abort($t23)
    if (true) { assume $DebugTrackAbort(7, 12548, i#$Integer($t23)); }
    $abort_code := i#$Integer($t23);
    goto Abort;

    // L4:
L4:

    // DesignatedDealer::validate_and_record_mint<#0>($t12, $t11, $t13)
    call $DesignatedDealer_validate_and_record_mint($tv0, $t12, $t11, $t13, $DesignatedDealer_TierInfo_$SelfDomain);
    if ($abort_flag) {
      goto Abort;
    }

    // $t24 := borrow_global<DesignatedDealer::Dealer>($t12)
    call $t24 := $BorrowGlobal($DesignatedDealer_Dealer_$memory, $t12, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 12796, $abort_code);
      goto Abort;
    }

    // unpack_ref($t24)

    // $t25 := borrow_field<DesignatedDealer::Dealer>.mint_event_handle($t24)
    call $t25 := $BorrowField($t24, $DesignatedDealer_Dealer_mint_event_handle);

    // unpack_ref($t25)

    // $t26 := Libra::currency_code<#0>()
    call $t26 := $Libra_currency_code($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 12920, $abort_code);
      goto Abort;
    }

    // $t27 := pack DesignatedDealer::ReceivedMintEvent($t26, $t12, $t11)
    call $t27 := $DesignatedDealer_ReceivedMintEvent_pack(0, 0, 0, $t26, $t12, $t11);

    // $t28 := read_ref($t25)
    call $t28 := $ReadRef($t25);
    assert $Event_EventHandle_$invariant_holds($t28);

    // $t28 := Event::emit_event<DesignatedDealer::ReceivedMintEvent>($t28, $t27)
    call $t28 := $Event_emit_event($DesignatedDealer_ReceivedMintEvent_type_value(), $t28, $t27);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 12748, $abort_code);
      goto Abort;
    }

    // write_ref($t25, $t28)
    call $t25 := $WriteRef($t25, $t28);

    // pack_ref($t25)

    // write_back[Reference($t24)]($t25)
    call $t24 := $WritebackToReference($t25, $t24);

    // pack_ref($t24)

    // write_back[DesignatedDealer::Dealer]($t24)
    call $DesignatedDealer_Dealer_$memory := $WritebackToGlobal($DesignatedDealer_Dealer_$memory, $t24);

    // $t29 := Libra::mint<#0>($t10, $t11)
    call $t29 := $Libra_mint($tv0, $t10, $t11, $Libra_CurrencyInfo_$SelfDomain);
    if ($abort_flag) {
      goto Abort;
    }

    // return $t29
    $ret0 := $t29;
    if (true) { assume $DebugTrackLocal(7, 13059, 30, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $DesignatedDealer_tiered_mint_$direct_inter($tv0: $TypeValue, tc_account: $Value, amount: $Value, dd_addr: $Value, tier_index: $Value, $Libra_CurrencyInfo_$CallerDomain: [$TypeValueArray, int]bool, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
requires $Libra_CurrencyInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())];
requires $DesignatedDealer_TierInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)];
ensures b#$Boolean(old($Boolean($IsEqual(amount, $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($DesignatedDealer_new_amount$9($LibraTimestamp_CurrentTimeMicroseconds_$memory, $DesignatedDealer_TierInfo_$memory, $tv0, amount, dd_addr)) > i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), tier_index))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, dd_addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U128))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean($IsEqual(amount, $Integer(0)))))
    || b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers))))))
    || b#$Boolean(old($Boolean(i#$Integer($DesignatedDealer_new_amount$9($LibraTimestamp_CurrentTimeMicroseconds_$memory, $DesignatedDealer_TierInfo_$memory, $tv0, amount, dd_addr)) > i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), tier_index)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, dd_addr)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint)))))
    || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U128)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean($IsEqual(amount, $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers)))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(i#$Integer($DesignatedDealer_new_amount$9($LibraTimestamp_CurrentTimeMicroseconds_$memory, $DesignatedDealer_TierInfo_$memory, $tv0, amount, dd_addr)) > i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), tier_index))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(4)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, dd_addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U128))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr), $DesignatedDealer_TierInfo_tiers), old($SelectField($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr), $DesignatedDealer_TierInfo_tiers))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(i#$Integer(old($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start))) <= i#$Integer($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start), $DesignatedDealer_current_time$16($LibraTimestamp_CurrentTimeMicroseconds_$memory, $tv0)))) && b#$Boolean($Boolean($IsEqual($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_inflow), amount))))) || b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual(old($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start)), $SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start)))) && b#$Boolean($Boolean($IsEqual($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_inflow), $Integer(i#$Integer(old($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_inflow))) + i#$Integer(amount))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(i#$Integer(tier_index) < i#$Integer($vlen_value($SelectField(old($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)), $DesignatedDealer_TierInfo_tiers))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(i#$Integer($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_inflow)) <= i#$Integer($select_vector_by_value($SelectField(old($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)), $DesignatedDealer_TierInfo_tiers), tier_index)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), amount))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($DesignatedDealer_currency_info$17($Libra_CurrencyInfo_$memory, $tv0), $UpdateField(old($DesignatedDealer_currency_info$17($Libra_CurrencyInfo_$memory, $tv0)), $Libra_CurrencyInfo_total_value, $Integer(i#$Integer(old($SelectField($DesignatedDealer_currency_info$17($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))) + i#$Integer(amount)))))));
ensures $Libra_Libra_$is_well_formed($ret0);
modifies $Libra_CurrencyInfo_$memory;
ensures contents#$Memory($Libra_CurrencyInfo_$memory) == old(contents#$Memory($Libra_CurrencyInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())]];
ensures domain#$Memory($Libra_CurrencyInfo_$memory) == old(domain#$Memory($Libra_CurrencyInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := domain#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())]];
modifies $DesignatedDealer_Dealer_$memory;
modifies $DesignatedDealer_TierInfo_$memory;
ensures contents#$Memory($DesignatedDealer_TierInfo_$memory) == old(contents#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)]];
ensures domain#$Memory($DesignatedDealer_TierInfo_$memory) == old(domain#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := domain#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)]];

procedure {:inline 1} $DesignatedDealer_tiered_mint_$direct_intra($tv0: $TypeValue, tc_account: $Value, amount: $Value, dd_addr: $Value, tier_index: $Value, $Libra_CurrencyInfo_$CallerDomain: [$TypeValueArray, int]bool, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
requires $Libra_CurrencyInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())];
requires $DesignatedDealer_TierInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)];
ensures b#$Boolean(old($Boolean($IsEqual(amount, $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($DesignatedDealer_new_amount$9($LibraTimestamp_CurrentTimeMicroseconds_$memory, $DesignatedDealer_TierInfo_$memory, $tv0, amount, dd_addr)) > i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), tier_index))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, dd_addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U128))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean($IsEqual(amount, $Integer(0)))))
    || b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers))))))
    || b#$Boolean(old($Boolean(i#$Integer($DesignatedDealer_new_amount$9($LibraTimestamp_CurrentTimeMicroseconds_$memory, $DesignatedDealer_TierInfo_$memory, $tv0, amount, dd_addr)) > i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), tier_index)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, dd_addr)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint)))))
    || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U128)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean($IsEqual(amount, $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers)))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(i#$Integer($DesignatedDealer_new_amount$9($LibraTimestamp_CurrentTimeMicroseconds_$memory, $DesignatedDealer_TierInfo_$memory, $tv0, amount, dd_addr)) > i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), tier_index))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(4)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, dd_addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U128))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr), $DesignatedDealer_TierInfo_tiers), old($SelectField($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr), $DesignatedDealer_TierInfo_tiers))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(i#$Integer(old($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start))) <= i#$Integer($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start), $DesignatedDealer_current_time$16($LibraTimestamp_CurrentTimeMicroseconds_$memory, $tv0)))) && b#$Boolean($Boolean($IsEqual($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_inflow), amount))))) || b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual(old($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start)), $SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start)))) && b#$Boolean($Boolean($IsEqual($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_inflow), $Integer(i#$Integer(old($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_inflow))) + i#$Integer(amount))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(i#$Integer(tier_index) < i#$Integer($vlen_value($SelectField(old($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)), $DesignatedDealer_TierInfo_tiers))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(i#$Integer($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_inflow)) <= i#$Integer($select_vector_by_value($SelectField(old($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)), $DesignatedDealer_TierInfo_tiers), tier_index)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), amount))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($DesignatedDealer_currency_info$17($Libra_CurrencyInfo_$memory, $tv0), $UpdateField(old($DesignatedDealer_currency_info$17($Libra_CurrencyInfo_$memory, $tv0)), $Libra_CurrencyInfo_total_value, $Integer(i#$Integer(old($SelectField($DesignatedDealer_currency_info$17($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))) + i#$Integer(amount)))))));
ensures $Libra_Libra_$is_well_formed($ret0);
modifies $Libra_CurrencyInfo_$memory;
ensures contents#$Memory($Libra_CurrencyInfo_$memory) == old(contents#$Memory($Libra_CurrencyInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())]];
ensures domain#$Memory($Libra_CurrencyInfo_$memory) == old(domain#$Memory($Libra_CurrencyInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := domain#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())]];
modifies $DesignatedDealer_Dealer_$memory;
modifies $DesignatedDealer_TierInfo_$memory;
ensures contents#$Memory($DesignatedDealer_TierInfo_$memory) == old(contents#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)]];
ensures domain#$Memory($DesignatedDealer_TierInfo_$memory) == old(domain#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := domain#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)]];

procedure {:inline 1} $DesignatedDealer_tiered_mint($tv0: $TypeValue, tc_account: $Value, amount: $Value, dd_addr: $Value, tier_index: $Value, $Libra_CurrencyInfo_$CallerDomain: [$TypeValueArray, int]bool, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
requires $Libra_CurrencyInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())];
requires $DesignatedDealer_TierInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)];
ensures b#$Boolean(old($Boolean($IsEqual(amount, $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($DesignatedDealer_new_amount$9($LibraTimestamp_CurrentTimeMicroseconds_$memory, $DesignatedDealer_TierInfo_$memory, $tv0, amount, dd_addr)) > i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), tier_index))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, dd_addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U128))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean($IsEqual(amount, $Integer(0)))))
    || b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers))))))
    || b#$Boolean(old($Boolean(i#$Integer($DesignatedDealer_new_amount$9($LibraTimestamp_CurrentTimeMicroseconds_$memory, $DesignatedDealer_TierInfo_$memory, $tv0, amount, dd_addr)) > i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), tier_index)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, dd_addr)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint)))))
    || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U128)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean($IsEqual(amount, $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers)))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(i#$Integer($DesignatedDealer_new_amount$9($LibraTimestamp_CurrentTimeMicroseconds_$memory, $DesignatedDealer_TierInfo_$memory, $tv0, amount, dd_addr)) > i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), tier_index))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(4)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, dd_addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U128))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr), $DesignatedDealer_TierInfo_tiers), old($SelectField($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr), $DesignatedDealer_TierInfo_tiers))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(i#$Integer(old($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start))) <= i#$Integer($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start), $DesignatedDealer_current_time$16($LibraTimestamp_CurrentTimeMicroseconds_$memory, $tv0)))) && b#$Boolean($Boolean($IsEqual($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_inflow), amount))))) || b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual(old($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start)), $SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_start)))) && b#$Boolean($Boolean($IsEqual($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_inflow), $Integer(i#$Integer(old($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_inflow))) + i#$Integer(amount))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(i#$Integer(tier_index) < i#$Integer($vlen_value($SelectField(old($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)), $DesignatedDealer_TierInfo_tiers))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(i#$Integer($SelectField($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_window_inflow)) <= i#$Integer($select_vector_by_value($SelectField(old($DesignatedDealer_dealer$15($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr)), $DesignatedDealer_TierInfo_tiers), tier_index)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), amount))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($DesignatedDealer_currency_info$17($Libra_CurrencyInfo_$memory, $tv0), $UpdateField(old($DesignatedDealer_currency_info$17($Libra_CurrencyInfo_$memory, $tv0)), $Libra_CurrencyInfo_total_value, $Integer(i#$Integer(old($SelectField($DesignatedDealer_currency_info$17($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))) + i#$Integer(amount)))))));
ensures $Libra_Libra_$is_well_formed($ret0);
modifies $Libra_CurrencyInfo_$memory;
ensures contents#$Memory($Libra_CurrencyInfo_$memory) == old(contents#$Memory($Libra_CurrencyInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())]];
ensures domain#$Memory($Libra_CurrencyInfo_$memory) == old(domain#$Memory($Libra_CurrencyInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := domain#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())]];
modifies $DesignatedDealer_Dealer_$memory;
modifies $DesignatedDealer_TierInfo_$memory;
ensures contents#$Memory($DesignatedDealer_TierInfo_$memory) == old(contents#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)]];
ensures domain#$Memory($DesignatedDealer_TierInfo_$memory) == old(domain#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := domain#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)]];

procedure {:inline 1} $DesignatedDealer_update_tier_$def($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_index: $Value, new_upperbound: $Value, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var next_tier_index: $Value; // $IntegerType()
    var number_of_tiers: $Value; // $IntegerType()
    var prev_tier_index: $Value; // $IntegerType()
    var tier: $Value; // $IntegerType()
    var tiers: $Mutation; // ReferenceType($Vector_type_value($IntegerType()))
    var tmp#$9: $Value; // $BooleanType()
    var tmp#$10: $Value; // $IntegerType()
    var tmp#$11: $Value; // $BooleanType()
    var tmp#$12: $Value; // $IntegerType()
    var tmp#$13: $Mutation; // ReferenceType($Vector_type_value($IntegerType()))
    var tmp#$14: $Value; // $IntegerType()
    var tmp#$15: $Value; // $BooleanType()
    var tmp#$16: $Value; // $IntegerType()
    var tmp#$17: $Mutation; // ReferenceType($Vector_type_value($IntegerType()))
    var tmp#$18: $Value; // $IntegerType()
    var tmp#$19: $Value; // $BooleanType()
    var tmp#$20: $Value; // $BooleanType()
    var tmp#$21: $Value; // $IntegerType()
    var tmp#$22: $Mutation; // ReferenceType($Vector_type_value($IntegerType()))
    var tmp#$23: $Value; // $IntegerType()
    var $t24: $Value; // $AddressType()
    var $t25: $Value; // $AddressType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $BooleanType()
    var $t29: $Value; // $IntegerType()
    var $t30: $Value; // $IntegerType()
    var $t31: $Mutation; // ReferenceType($DesignatedDealer_TierInfo_type_value($tv0))
    var $t32: $Value; // $Vector_type_value($IntegerType())
    var $t33: $Value; // $BooleanType()
    var $t34: $Value; // $IntegerType()
    var $t35: $Value; // $IntegerType()
    var $t36: $Value; // $Vector_type_value($IntegerType())
    var $t37: $Value; // $BooleanType()
    var $t38: $Value; // $BooleanType()
    var $t39: $Value; // $IntegerType()
    var $t40: $Value; // $BooleanType()
    var $t41: $Value; // $Vector_type_value($IntegerType())
    var $t42: $Value; // $IntegerType()
    var $t43: $Value; // $BooleanType()
    var $t44: $Value; // $IntegerType()
    var $t45: $Value; // $IntegerType()
    var $t46: $Value; // $BooleanType()
    var $t47: $Value; // $IntegerType()
    var $t48: $Value; // $BooleanType()
    var $t49: $Value; // $IntegerType()
    var $t50: $Value; // $Vector_type_value($IntegerType())
    var $t51: $Value; // $IntegerType()
    var $t52: $Value; // $BooleanType()
    var $t53: $Value; // $IntegerType()
    var $t54: $Value; // $IntegerType()
    var $t55: $Mutation; // ReferenceType($Vector_type_value($IntegerType()))
    var $t56: $Value; // $Vector_type_value($IntegerType())
    var $t57: $Mutation; // ReferenceType($IntegerType())
    var $DesignatedDealer_TierInfo_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 9619, 0, tc_account); }
    if (true) { assume $DebugTrackLocal(7, 9619, 1, dd_addr); }
    if (true) { assume $DebugTrackLocal(7, 9619, 2, tier_index); }
    if (true) { assume $DebugTrackLocal(7, 9619, 3, new_upperbound); }
    $DesignatedDealer_TierInfo_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := true];

    // bytecode translation starts here
    // $t24 := move(tc_account)
    call $t24 := $CopyOrMoveValue(tc_account);

    // $t25 := move(dd_addr)
    call $t25 := $CopyOrMoveValue(dd_addr);

    // $t26 := move(tier_index)
    call $t26 := $CopyOrMoveValue(tier_index);

    // $t27 := move(new_upperbound)
    call $t27 := $CopyOrMoveValue(new_upperbound);

    // Roles::assert_treasury_compliance($t24)
    call $Roles_assert_treasury_compliance($t24);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 9802, $abort_code);
      goto Abort;
    }

    // $t28 := exists<DesignatedDealer::TierInfo<#0>>($t25)
    $t28 := $ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t25);

    // $t29 := 0
    $t29 := $Integer(0);

    // $t30 := Errors::not_published($t29)
    call $t30 := $Errors_not_published($t29);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 9902, $abort_code);
      goto Abort;
    }

    // if ($t28) goto L0 else goto L1
    if (b#$Boolean($t28)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t30)
    if (true) { assume $DebugTrackAbort(7, 9850, i#$Integer($t30)); }
    $abort_code := i#$Integer($t30);
    goto Abort;

    // L0:
L0:

    // $t31 := borrow_global<DesignatedDealer::TierInfo<#0>>($t25)
    assert $DesignatedDealer_TierInfo_$SelfDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($t25)];
    call $t31 := $BorrowGlobal($DesignatedDealer_TierInfo_$memory, $t25, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 9952, $abort_code);
      goto Abort;
    }

    // unpack_ref($t31)
    call $DesignatedDealer_TierInfo_$unpack_ref($tv0, $Dereference($t31));

    // tiers := borrow_field<DesignatedDealer::TierInfo<#0>>.tiers($t31)
    call tiers := $BorrowField($t31, $DesignatedDealer_TierInfo_tiers);

    // unpack_ref(tiers)

    // $t32 := read_ref(tiers)
    call $t32 := $ReadRef(tiers);

    // number_of_tiers := Vector::length<u64>($t32)
    call number_of_tiers := $Vector_length($IntegerType(), $t32);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 10044, $abort_code);
      goto Abort;
    }

    // $t33 := <($t26, number_of_tiers)
    call $t33 := $Lt($t26, number_of_tiers);

    // $t34 := 3
    $t34 := $Integer(3);

    // $t35 := Errors::invalid_argument($t34)
    call $t35 := $Errors_invalid_argument($t34);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 10112, $abort_code);
      goto Abort;
    }

    // if ($t33) goto L2 else goto L3
    if (b#$Boolean($t33)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // destroy(tiers)

    // pack_ref(tiers)

    // pack_ref($t31)
    call $DesignatedDealer_TierInfo_$pack_ref($tv0, $Dereference($t31));

    // abort($t35)
    if (true) { assume $DebugTrackAbort(7, 10067, i#$Integer($t35)); }
    $abort_code := i#$Integer($t35);
    goto Abort;

    // L2:
L2:

    // $t36 := read_ref(tiers)
    call $t36 := $ReadRef(tiers);

    // tier := Vector::borrow<u64>($t36, $t26)
    call tier := $Vector_borrow($IntegerType(), $t36, $t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 10281, $abort_code);
      goto Abort;
    }

    // $t37 := ==(tier, $t27)
    $t37 := $Boolean($IsEqual(tier, $t27));

    // if ($t37) goto L4 else goto L5
    if (b#$Boolean($t37)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // goto L6
    goto L6;

    // L4:
L4:

    // destroy(tiers)

    // pack_ref(tiers)

    // pack_ref($t31)
    call $DesignatedDealer_TierInfo_$pack_ref($tv0, $Dereference($t31));

    // destroy(tier)

    // return ()
    return;

    // L6:
L6:

    // $t38 := <(tier, $t27)
    call $t38 := $Lt(tier, $t27);

    // if ($t38) goto L7 else goto L8
    if (b#$Boolean($t38)) { goto L7; } else { goto L8; }

    // L8:
L8:

    // goto L9
    goto L9;

    // L7:
L7:

    // $t39 := 1
    $t39 := $Integer(1);

    // next_tier_index := +($t26, $t39)
    call next_tier_index := $AddU64($t26, $t39);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 10436, $abort_code);
      goto Abort;
    }
    if (true) { assume $DebugTrackLocal(7, 10436, 4, next_tier_index); }

    // $t40 := <(next_tier_index, number_of_tiers)
    call $t40 := $Lt(next_tier_index, number_of_tiers);

    // if ($t40) goto L10 else goto L11
    if (b#$Boolean($t40)) { goto L10; } else { goto L11; }

    // L11:
L11:

    // goto L9
    goto L9;

    // L10:
L10:

    // $t41 := read_ref(tiers)
    call $t41 := $ReadRef(tiers);

    // $t42 := Vector::borrow<u64>($t41, next_tier_index)
    call $t42 := $Vector_borrow($IntegerType(), $t41, next_tier_index);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 10564, $abort_code);
      goto Abort;
    }

    // $t43 := <($t27, $t42)
    call $t43 := $Lt($t27, $t42);

    // $t44 := 2
    $t44 := $Integer(2);

    // $t45 := Errors::invalid_argument($t44)
    call $t45 := $Errors_invalid_argument($t44);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 10624, $abort_code);
      goto Abort;
    }

    // if ($t43) goto L9 else goto L12
    if (b#$Boolean($t43)) { goto L9; } else { goto L12; }

    // L12:
L12:

    // destroy(tiers)

    // pack_ref(tiers)

    // pack_ref($t31)
    call $DesignatedDealer_TierInfo_$pack_ref($tv0, $Dereference($t31));

    // destroy(tier)

    // abort($t45)
    if (true) { assume $DebugTrackAbort(7, 10510, i#$Integer($t45)); }
    $abort_code := i#$Integer($t45);
    goto Abort;

    // L9:
L9:

    // $t46 := >(tier, $t27)
    call $t46 := $Gt(tier, $t27);

    // if ($t46) goto L13 else goto L14
    if (b#$Boolean($t46)) { goto L13; } else { goto L14; }

    // L14:
L14:

    // goto L15
    goto L15;

    // L13:
L13:

    // $t47 := 0
    $t47 := $Integer(0);

    // tmp#$19 := >($t26, $t47)
    call tmp#$19 := $Gt($t26, $t47);
    if (true) { assume $DebugTrackLocal(7, 10756, 19, tmp#$19); }

    // goto L16
    goto L16;

    // L15:
L15:

    // $t48 := false
    $t48 := $Boolean(false);

    // tmp#$19 := $t48
    call tmp#$19 := $CopyOrMoveValue($t48);
    if (true) { assume $DebugTrackLocal(7, 10719, 19, tmp#$19); }

    // goto L16
    goto L16;

    // L16:
L16:

    // if (tmp#$19) goto L17 else goto L18
    if (b#$Boolean(tmp#$19)) { goto L17; } else { goto L18; }

    // L18:
L18:

    // goto L19
    goto L19;

    // L17:
L17:

    // $t49 := 1
    $t49 := $Integer(1);

    // prev_tier_index := -($t26, $t49)
    call prev_tier_index := $Sub($t26, $t49);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 10808, $abort_code);
      goto Abort;
    }
    if (true) { assume $DebugTrackLocal(7, 10808, 6, prev_tier_index); }

    // $t50 := read_ref(tiers)
    call $t50 := $ReadRef(tiers);

    // $t51 := Vector::borrow<u64>($t50, prev_tier_index)
    call $t51 := $Vector_borrow($IntegerType(), $t50, prev_tier_index);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 10875, $abort_code);
      goto Abort;
    }

    // $t52 := >($t27, $t51)
    call $t52 := $Gt($t27, $t51);

    // $t53 := 2
    $t53 := $Integer(2);

    // $t54 := Errors::invalid_argument($t53)
    call $t54 := $Errors_invalid_argument($t53);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 10931, $abort_code);
      goto Abort;
    }

    // if ($t52) goto L19 else goto L20
    if (b#$Boolean($t52)) { goto L19; } else { goto L20; }

    // L20:
L20:

    // destroy(tiers)

    // pack_ref(tiers)

    // pack_ref($t31)
    call $DesignatedDealer_TierInfo_$pack_ref($tv0, $Dereference($t31));

    // abort($t54)
    if (true) { assume $DebugTrackAbort(7, 10825, i#$Integer($t54)); }
    $abort_code := i#$Integer($t54);
    goto Abort;

    // L19:
L19:

    // $t55 := move(tiers)
    call $t55 := $CopyOrMoveRef(tiers);

    // pack_ref(tiers)

    // $t56 := read_ref(tiers)
    call $t56 := $ReadRef(tiers);

    // ($t57, $t56) := Vector::borrow_mut<u64>($t56, $t26)
    call $t57, $t56 := $Vector_borrow_mut($IntegerType(), $t56, $t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 11012, $abort_code);
      goto Abort;
    }

    // write_ref(tiers, $t56)
    call tiers := $WriteRef(tiers, $t56);
    if (true) { assume $DebugTrackLocal(7, 11012, 8, $Dereference(tiers)); }

    // splice[0 -> $t55]($t57)
    call $t57 := $Splice1(0, $t55, $t57);

    // write_ref($t57, $t27)
    call $t57 := $WriteRef($t57, $t27);
    if (true) { assume $DebugTrackLocal(7, 11003, 8, $Dereference(tiers)); }

    // write_back[Reference($t55)]($t57)
    call $t55 := $WritebackToReference($t57, $t55);

    // pack_ref_deep($t55)

    // write_back[Reference($t31)]($t55)
    call $t31 := $WritebackToReference($t55, $t31);

    // pack_ref($t31)
    call $DesignatedDealer_TierInfo_$pack_ref($tv0, $Dereference($t31));

    // write_back[DesignatedDealer::TierInfo]($t31)
    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, $t31);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $DesignatedDealer_update_tier_$direct_inter($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_index: $Value, new_upperbound: $Value, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $DesignatedDealer_TierInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer(tier_index) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer(tier_index) - i#$Integer($Integer(1))))) >= i#$Integer(new_upperbound)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer(tier_index) + i#$Integer($Integer(1)))) < i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers))))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer(tier_index) + i#$Integer($Integer(1))))) <= i#$Integer(new_upperbound)))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)))))
    || b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer(tier_index) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer(tier_index) - i#$Integer($Integer(1))))) >= i#$Integer(new_upperbound))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer(tier_index) + i#$Integer($Integer(1)))) < i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers))))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer(tier_index) + i#$Integer($Integer(1))))) <= i#$Integer(new_upperbound)))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers)))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer(tier_index) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer(tier_index) - i#$Integer($Integer(1))))) >= i#$Integer(new_upperbound)))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer(tier_index) + i#$Integer($Integer(1)))) < i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers))))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer(tier_index) + i#$Integer($Integer(1))))) <= i#$Integer(new_upperbound)))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr), $Vector($ExtendValueArray($ExtendValueArray($ExtendValueArray($EmptyValueArray(), $SelectField(old($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)), $DesignatedDealer_TierInfo_window_start)), $SelectField(old($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)), $DesignatedDealer_TierInfo_window_inflow)), $update_vector_by_value($SelectField(old($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)), $DesignatedDealer_TierInfo_tiers), tier_index, new_upperbound)))))));
modifies $DesignatedDealer_TierInfo_$memory;
ensures contents#$Memory($DesignatedDealer_TierInfo_$memory) == old(contents#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)]];
ensures domain#$Memory($DesignatedDealer_TierInfo_$memory) == old(domain#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := domain#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)]];

procedure {:inline 1} $DesignatedDealer_update_tier_$direct_intra($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_index: $Value, new_upperbound: $Value, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $DesignatedDealer_TierInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer(tier_index) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer(tier_index) - i#$Integer($Integer(1))))) >= i#$Integer(new_upperbound)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer(tier_index) + i#$Integer($Integer(1)))) < i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers))))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer(tier_index) + i#$Integer($Integer(1))))) <= i#$Integer(new_upperbound)))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)))))
    || b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer(tier_index) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer(tier_index) - i#$Integer($Integer(1))))) >= i#$Integer(new_upperbound))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer(tier_index) + i#$Integer($Integer(1)))) < i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers))))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer(tier_index) + i#$Integer($Integer(1))))) <= i#$Integer(new_upperbound)))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers)))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer(tier_index) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer(tier_index) - i#$Integer($Integer(1))))) >= i#$Integer(new_upperbound)))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer(tier_index) + i#$Integer($Integer(1)))) < i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers))))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer(tier_index) + i#$Integer($Integer(1))))) <= i#$Integer(new_upperbound)))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr), $Vector($ExtendValueArray($ExtendValueArray($ExtendValueArray($EmptyValueArray(), $SelectField(old($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)), $DesignatedDealer_TierInfo_window_start)), $SelectField(old($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)), $DesignatedDealer_TierInfo_window_inflow)), $update_vector_by_value($SelectField(old($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)), $DesignatedDealer_TierInfo_tiers), tier_index, new_upperbound)))))));
modifies $DesignatedDealer_TierInfo_$memory;
ensures contents#$Memory($DesignatedDealer_TierInfo_$memory) == old(contents#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)]];
ensures domain#$Memory($DesignatedDealer_TierInfo_$memory) == old(domain#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := domain#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)]];

procedure {:inline 1} $DesignatedDealer_update_tier($tv0: $TypeValue, tc_account: $Value, dd_addr: $Value, tier_index: $Value, new_upperbound: $Value, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $DesignatedDealer_TierInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer(tier_index) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer(tier_index) - i#$Integer($Integer(1))))) >= i#$Integer(new_upperbound)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer(tier_index) + i#$Integer($Integer(1)))) < i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers))))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer(tier_index) + i#$Integer($Integer(1))))) <= i#$Integer(new_upperbound)))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)))))
    || b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer(tier_index) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer(tier_index) - i#$Integer($Integer(1))))) >= i#$Integer(new_upperbound))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer(tier_index) + i#$Integer($Integer(1)))) < i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers))))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer(tier_index) + i#$Integer($Integer(1))))) <= i#$Integer(new_upperbound)))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers)))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer(tier_index) > i#$Integer($Integer(0)))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer(tier_index) - i#$Integer($Integer(1))))) >= i#$Integer(new_upperbound)))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer(tier_index) + i#$Integer($Integer(1)))) < i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers))))) && b#$Boolean($Boolean(i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$14($DesignatedDealer_TierInfo_$memory, $tv0, dd_addr), $DesignatedDealer_TierInfo_tiers), $Integer(i#$Integer(tier_index) + i#$Integer($Integer(1))))) <= i#$Integer(new_upperbound)))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr), $Vector($ExtendValueArray($ExtendValueArray($ExtendValueArray($EmptyValueArray(), $SelectField(old($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)), $DesignatedDealer_TierInfo_window_start)), $SelectField(old($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)), $DesignatedDealer_TierInfo_window_inflow)), $update_vector_by_value($SelectField(old($ResourceValue($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)), $DesignatedDealer_TierInfo_tiers), tier_index, new_upperbound)))))));
modifies $DesignatedDealer_TierInfo_$memory;
ensures contents#$Memory($DesignatedDealer_TierInfo_$memory) == old(contents#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)]];
ensures domain#$Memory($DesignatedDealer_TierInfo_$memory) == old(domain#$Memory($DesignatedDealer_TierInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := domain#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)]];

procedure {:inline 1} $DesignatedDealer_validate_and_record_mint_$def($tv0: $TypeValue, dd_addr: $Value, amount: $Value, tier_index: $Value, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var cur_inflow: $Value; // $IntegerType()
    var number_of_tiers: $Value; // $IntegerType()
    var tier_info: $Mutation; // ReferenceType($DesignatedDealer_TierInfo_type_value($tv0))
    var tier_upperbound: $Value; // $IntegerType()
    var tiers: $Value; // $Vector_type_value($IntegerType())
    var tmp#$8: $Value; // $BooleanType()
    var tmp#$9: $Value; // $IntegerType()
    var tmp#$10: $Value; // $BooleanType()
    var tmp#$11: $Value; // $IntegerType()
    var tmp#$12: $Value; // $BooleanType()
    var tmp#$13: $Value; // $IntegerType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $DesignatedDealer_TierInfo_type_value($tv0)
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $BooleanType()
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $IntegerType()
    var $t30: $Value; // $IntegerType()
    var $t31: $Mutation; // ReferenceType($IntegerType())
    var $DesignatedDealer_TierInfo_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 16039, 0, dd_addr); }
    if (true) { assume $DebugTrackLocal(7, 16039, 1, amount); }
    if (true) { assume $DebugTrackLocal(7, 16039, 2, tier_index); }
    $DesignatedDealer_TierInfo_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr) := true];

    // bytecode translation starts here
    // $t14 := move(dd_addr)
    call $t14 := $CopyOrMoveValue(dd_addr);

    // $t15 := move(amount)
    call $t15 := $CopyOrMoveValue(amount);

    // $t16 := move(tier_index)
    call $t16 := $CopyOrMoveValue(tier_index);

    // tier_info := borrow_global<DesignatedDealer::TierInfo<#0>>($t14)
    assert $DesignatedDealer_TierInfo_$SelfDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($t14)];
    call tier_info := $BorrowGlobal($DesignatedDealer_TierInfo_$memory, $t14, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 16174, $abort_code);
      goto Abort;
    }

    // unpack_ref(tier_info)
    call $DesignatedDealer_TierInfo_$unpack_ref($tv0, $Dereference(tier_info));

    // $t17 := read_ref(tier_info)
    call $t17 := $ReadRef(tier_info);
    assert $DesignatedDealer_TierInfo_$invariant_holds($t17);

    // $t17 := DesignatedDealer::reset_window<#0>($t17)
    call $t17 := $DesignatedDealer_reset_window($tv0, $t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 17093, $abort_code);
      goto Abort;
    }

    // write_ref(tier_info, $t17)
    call tier_info := $WriteRef(tier_info, $t17);
    if (true) { assume $DebugTrackLocal(7, 17093, 5, $Dereference(tier_info)); }

    // $t18 := get_field<DesignatedDealer::TierInfo<#0>>.window_inflow(tier_info)
    call $t18 := $GetFieldFromReference(tier_info, $DesignatedDealer_TierInfo_window_inflow);

    // cur_inflow := $t18
    call cur_inflow := $CopyOrMoveValue($t18);
    if (true) { assume $DebugTrackLocal(7, 16267, 3, cur_inflow); }

    // tiers := get_field<DesignatedDealer::TierInfo<#0>>.tiers(tier_info)
    call tiers := $GetFieldFromReference(tier_info, $DesignatedDealer_TierInfo_tiers);
    if (true) { assume $DebugTrackLocal(7, 16325, 7, tiers); }

    // number_of_tiers := Vector::length<u64>(tiers)
    call number_of_tiers := $Vector_length($IntegerType(), tiers);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 16381, $abort_code);
      goto Abort;
    }

    // $t19 := <($t16, number_of_tiers)
    call $t19 := $Lt($t16, number_of_tiers);

    // $t20 := 3
    $t20 := $Integer(3);

    // $t21 := Errors::invalid_argument($t20)
    call $t21 := $Errors_invalid_argument($t20);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 16449, $abort_code);
      goto Abort;
    }

    // if ($t19) goto L0 else goto L1
    if (b#$Boolean($t19)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy(tiers)

    // destroy(tier_info)

    // pack_ref(tier_info)
    call $DesignatedDealer_TierInfo_$pack_ref($tv0, $Dereference(tier_info));

    // write_back[DesignatedDealer::TierInfo](tier_info)
    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, tier_info);

    // abort($t21)
    if (true) { assume $DebugTrackAbort(7, 16404, i#$Integer($t21)); }
    $abort_code := i#$Integer($t21);
    goto Abort;

    // L0:
L0:

    // $t22 := Vector::borrow<u64>(tiers, $t16)
    call $t22 := $Vector_borrow($IntegerType(), tiers, $t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 16533, $abort_code);
      goto Abort;
    }

    // tier_upperbound := $t22
    call tier_upperbound := $CopyOrMoveValue($t22);
    if (true) { assume $DebugTrackLocal(7, 16501, 6, tier_upperbound); }

    // $t23 := <=($t15, tier_upperbound)
    call $t23 := $Le($t15, tier_upperbound);

    // $t24 := 5
    $t24 := $Integer(5);

    // $t25 := Errors::invalid_argument($t24)
    call $t25 := $Errors_invalid_argument($t24);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 16610, $abort_code);
      goto Abort;
    }

    // if ($t23) goto L2 else goto L3
    if (b#$Boolean($t23)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // destroy(tier_info)

    // pack_ref(tier_info)
    call $DesignatedDealer_TierInfo_$pack_ref($tv0, $Dereference(tier_info));

    // write_back[DesignatedDealer::TierInfo](tier_info)
    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, tier_info);

    // abort($t25)
    if (true) { assume $DebugTrackAbort(7, 16568, i#$Integer($t25)); }
    $abort_code := i#$Integer($t25);
    goto Abort;

    // L2:
L2:

    // $t26 := -(tier_upperbound, $t15)
    call $t26 := $Sub(tier_upperbound, $t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 16700, $abort_code);
      goto Abort;
    }

    // $t27 := <=(cur_inflow, $t26)
    call $t27 := $Le(cur_inflow, $t26);

    // $t28 := 5
    $t28 := $Integer(5);

    // $t29 := Errors::invalid_argument($t28)
    call $t29 := $Errors_invalid_argument($t28);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 16718, $abort_code);
      goto Abort;
    }

    // if ($t27) goto L4 else goto L5
    if (b#$Boolean($t27)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // destroy(tier_info)

    // pack_ref(tier_info)
    call $DesignatedDealer_TierInfo_$pack_ref($tv0, $Dereference(tier_info));

    // write_back[DesignatedDealer::TierInfo](tier_info)
    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, tier_info);

    // abort($t29)
    if (true) { assume $DebugTrackAbort(7, 16663, i#$Integer($t29)); }
    $abort_code := i#$Integer($t29);
    goto Abort;

    // L4:
L4:

    // $t30 := +(cur_inflow, $t15)
    call $t30 := $AddU64(cur_inflow, $t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 16808, $abort_code);
      goto Abort;
    }

    // $t31 := borrow_field<DesignatedDealer::TierInfo<#0>>.window_inflow(tier_info)
    call $t31 := $BorrowField(tier_info, $DesignatedDealer_TierInfo_window_inflow);

    // unpack_ref($t31)

    // write_ref($t31, $t30)
    call $t31 := $WriteRef($t31, $t30);
    if (true) { assume $DebugTrackLocal(7, 16771, 5, $Dereference(tier_info)); }

    // pack_ref($t31)

    // write_back[Reference(tier_info)]($t31)
    call tier_info := $WritebackToReference($t31, tier_info);

    // pack_ref(tier_info)
    call $DesignatedDealer_TierInfo_$pack_ref($tv0, $Dereference(tier_info));

    // write_back[DesignatedDealer::TierInfo](tier_info)
    call $DesignatedDealer_TierInfo_$memory := $WritebackToGlobal($DesignatedDealer_TierInfo_$memory, tier_info);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $DesignatedDealer_validate_and_record_mint_$direct_intra($tv0: $TypeValue, dd_addr: $Value, amount: $Value, tier_index: $Value, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $DesignatedDealer_TierInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)];
{
    assume is#$Address(dd_addr);

    assume $IsValidU64(amount);

    assume $IsValidU64(tier_index);

    call $DesignatedDealer_validate_and_record_mint_$def($tv0, dd_addr, amount, tier_index, $DesignatedDealer_TierInfo_$CallerDomain);
}


procedure {:inline 1} $DesignatedDealer_validate_and_record_mint($tv0: $TypeValue, dd_addr: $Value, amount: $Value, tier_index: $Value, $DesignatedDealer_TierInfo_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $DesignatedDealer_TierInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(dd_addr)];
{
    assume is#$Address(dd_addr);

    assume $IsValidU64(amount);

    assume $IsValidU64(tier_index);

    call $DesignatedDealer_validate_and_record_mint_$def($tv0, dd_addr, amount, tier_index, $DesignatedDealer_TierInfo_$CallerDomain);
}




// ** spec vars of module VASP



// ** spec funs of module VASP

function {:inline} $VASP_$is_child($VASP_ChildVASP_$memory: $Memory, addr: $Value): $Value {
    $ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, addr)
}

function {:inline} $VASP_$is_parent($VASP_ParentVASP_$memory: $Memory, addr: $Value): $Value {
    $ResourceExists($VASP_ParentVASP_$memory, $EmptyTypeValueArray, addr)
}

function {:inline} $VASP_$is_vasp($VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, addr: $Value): $Value {
    $Boolean(b#$Boolean($VASP_$is_parent($VASP_ParentVASP_$memory, addr)) || b#$Boolean($VASP_$is_child($VASP_ChildVASP_$memory, addr)))
}

function {:inline} $VASP_spec_parent_address($VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, addr: $Value): $Value {
    if (b#$Boolean($VASP_$is_parent($VASP_ParentVASP_$memory, addr))) then (addr) else ($SelectField($ResourceValue($VASP_ChildVASP_$memory, $EmptyTypeValueArray, addr), $VASP_ChildVASP_parent_vasp_addr))
}

function {:inline} $VASP_spec_has_account_limits($AccountLimits_Window_$memory: $Memory, $VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, $tv0: $TypeValue, addr: $Value): $Value {
    $AccountLimits_$has_window_published($AccountLimits_Window_$memory, $tv0, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr))
}

function {:inline} $VASP_spec_is_same_vasp($VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, addr1: $Value, addr2: $Value): $Value {
    $Boolean(b#$Boolean($Boolean(b#$Boolean($VASP_$is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr1)) && b#$Boolean($VASP_$is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr2)))) && b#$Boolean($Boolean($IsEqual($VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr2)))))
}

function {:inline} $VASP_spec_num_children($VASP_ParentVASP_$memory: $Memory, parent: $Value): $Value {
    $SelectField($ResourceValue($VASP_ParentVASP_$memory, $EmptyTypeValueArray, parent), $VASP_ParentVASP_num_children)
}

function {:inline} $VASP_parent_addr$13(parent: $Value): $Value {
    $Signer_spec_address_of(parent)
}

function {:inline} $VASP_vasp_addr$14(vasp: $Value): $Value {
    $Signer_spec_address_of(vasp)
}

function {:inline} $VASP_child_addr$15(child: $Value): $Value {
    $Signer_spec_address_of(child)
}



// ** structs of module VASP

const unique $VASP_ChildVASP: $TypeName;
const $VASP_ChildVASP_parent_vasp_addr: $FieldName;
axiom $VASP_ChildVASP_parent_vasp_addr == 0;
function $VASP_ChildVASP_type_value(): $TypeValue {
    $StructType($VASP_ChildVASP, $EmptyTypeValueArray)
}
var $VASP_ChildVASP_$memory: $Memory;
var $VASP_ChildVASP_$memory_$old: $Memory;
function {:inline} $VASP_ChildVASP_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && is#$Address($SelectField($this, $VASP_ChildVASP_parent_vasp_addr))
}
function {:inline} $VASP_ChildVASP_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $VASP_ChildVASP_$is_well_formed($this: $Value): bool {
    $VASP_ChildVASP_$is_well_typed($this) && $VASP_ChildVASP_$invariant_holds($this)}

procedure {:inline 1} $VASP_ChildVASP_pack($file_id: int, $byte_index: int, $var_idx: int, parent_vasp_addr: $Value) returns ($struct: $Value)
{
    assume is#$Address(parent_vasp_addr);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := parent_vasp_addr], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $VASP_ChildVASP_unpack($struct: $Value) returns (parent_vasp_addr: $Value)
{
    assume is#$Vector($struct);
    parent_vasp_addr := $SelectField($struct, $VASP_ChildVASP_parent_vasp_addr);
    assume is#$Address(parent_vasp_addr);
}

const unique $VASP_ParentVASP: $TypeName;
const $VASP_ParentVASP_num_children: $FieldName;
axiom $VASP_ParentVASP_num_children == 0;
function $VASP_ParentVASP_type_value(): $TypeValue {
    $StructType($VASP_ParentVASP, $EmptyTypeValueArray)
}
var $VASP_ParentVASP_$memory: $Memory;
var $VASP_ParentVASP_$memory_$old: $Memory;
function {:inline} $VASP_ParentVASP_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $VASP_ParentVASP_num_children))
}
function {:inline} $VASP_ParentVASP_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $VASP_ParentVASP_$is_well_formed($this: $Value): bool {
    $VASP_ParentVASP_$is_well_typed($this) && $VASP_ParentVASP_$invariant_holds($this)}

procedure {:inline 1} $VASP_ParentVASP_pack($file_id: int, $byte_index: int, $var_idx: int, num_children: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(num_children);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := num_children], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $VASP_ParentVASP_unpack($struct: $Value) returns (num_children: $Value)
{
    assume is#$Vector($struct);
    num_children := $SelectField($struct, $VASP_ParentVASP_num_children);
    assume $IsValidU64(num_children);
}



// ** functions of module VASP

procedure {:inline 1} $VASP_has_account_limits_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(27, 4879, 0, addr); }

    // bytecode translation starts here
    // $t1 := move(addr)
    call $t1 := $CopyOrMoveValue(addr);

    // $t2 := VASP::parent_address($t1)
    call $t2 := $VASP_parent_address($t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 5372, $abort_code);
      goto Abort;
    }

    // $t3 := AccountLimits::has_window_published<#0>($t2)
    call $t3 := $AccountLimits_has_window_published($tv0, $t2);
    if ($abort_flag) {
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(27, 4969, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $VASP_has_account_limits_$direct_inter($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $VASP_has_account_limits_$def($tv0, addr);
}


procedure {:inline 1} $VASP_has_account_limits_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $VASP_has_account_limits_$def($tv0, addr);
}


procedure {:inline 1} $VASP_has_account_limits($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $VASP_has_account_limits_$def($tv0, addr);
}


procedure {:inline 1} $VASP_is_child_$def(addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(27, 6668, 0, addr); }

    // bytecode translation starts here
    // $t1 := move(addr)
    call $t1 := $CopyOrMoveValue(addr);

    // $t2 := exists<VASP::ChildVASP>($t1)
    $t2 := $ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, $t1);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(27, 6719, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $VASP_is_child_$direct_inter(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $VASP_$is_child($VASP_ChildVASP_$memory, addr)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $VASP_is_child_$direct_intra(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $VASP_$is_child($VASP_ChildVASP_$memory, addr)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($Boolean($IsEqual($ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, a), old($ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, a)))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall parent: $Value :: is#$Address(parent) ==> b#$Boolean($Boolean(b#$Boolean(old($VASP_$is_parent($VASP_ParentVASP_$memory, parent))) ==> b#$Boolean($Boolean($IsEqual($VASP_spec_num_children($VASP_ParentVASP_$memory, parent), old($VASP_spec_num_children($VASP_ParentVASP_$memory, parent)))))))))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $VASP_is_child(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $VASP_$is_child($VASP_ChildVASP_$memory, addr)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $VASP_is_parent_$def(addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(27, 6403, 0, addr); }

    // bytecode translation starts here
    // $t1 := move(addr)
    call $t1 := $CopyOrMoveValue(addr);

    // $t2 := exists<VASP::ParentVASP>($t1)
    $t2 := $ResourceExists($VASP_ParentVASP_$memory, $EmptyTypeValueArray, $t1);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(27, 6455, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $VASP_is_parent_$direct_inter(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $VASP_$is_parent($VASP_ParentVASP_$memory, addr)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $VASP_is_parent_$direct_intra(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $VASP_$is_parent($VASP_ParentVASP_$memory, addr)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($Boolean($IsEqual($ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, a), old($ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, a)))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall parent: $Value :: is#$Address(parent) ==> b#$Boolean($Boolean(b#$Boolean(old($VASP_$is_parent($VASP_ParentVASP_$memory, parent))) ==> b#$Boolean($Boolean($IsEqual($VASP_spec_num_children($VASP_ParentVASP_$memory, parent), old($VASP_spec_num_children($VASP_ParentVASP_$memory, parent)))))))))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $VASP_is_parent(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $VASP_$is_parent($VASP_ParentVASP_$memory, addr)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $VASP_is_same_vasp_$def(addr1: $Value, addr2: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $BooleanType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(27, 7328, 0, addr1); }
    if (true) { assume $DebugTrackLocal(27, 7328, 1, addr2); }

    // bytecode translation starts here
    // $t4 := move(addr1)
    call $t4 := $CopyOrMoveValue(addr1);

    // $t5 := move(addr2)
    call $t5 := $CopyOrMoveValue(addr2);

    // $t6 := VASP::is_vasp($t4)
    call $t6 := $VASP_is_vasp($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 6934, $abort_code);
      goto Abort;
    }

    // if ($t6) goto L0 else goto L1
    if (b#$Boolean($t6)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // tmp#$2 := VASP::is_vasp($t5)
    call tmp#$2 := $VASP_is_vasp($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 6934, $abort_code);
      goto Abort;
    }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t7 := false
    $t7 := $Boolean(false);

    // tmp#$2 := $t7
    call tmp#$2 := $CopyOrMoveValue($t7);
    if (true) { assume $DebugTrackLocal(27, 7419, 2, tmp#$2); }

    // goto L3
    goto L3;

    // L3:
L3:

    // if (tmp#$2) goto L4 else goto L5
    if (b#$Boolean(tmp#$2)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // goto L6
    goto L6;

    // L4:
L4:

    // $t8 := VASP::parent_address($t4)
    call $t8 := $VASP_parent_address($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 5372, $abort_code);
      goto Abort;
    }

    // $t9 := VASP::parent_address($t5)
    call $t9 := $VASP_parent_address($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 5372, $abort_code);
      goto Abort;
    }

    // tmp#$3 := ==($t8, $t9)
    tmp#$3 := $Boolean($IsEqual($t8, $t9));
    if (true) { assume $DebugTrackLocal(27, 7477, 3, tmp#$3); }

    // goto L7
    goto L7;

    // L6:
L6:

    // $t10 := false
    $t10 := $Boolean(false);

    // tmp#$3 := $t10
    call tmp#$3 := $CopyOrMoveValue($t10);
    if (true) { assume $DebugTrackLocal(27, 7419, 3, tmp#$3); }

    // goto L7
    goto L7;

    // L7:
L7:

    // return tmp#$3
    $ret0 := tmp#$3;
    if (true) { assume $DebugTrackLocal(27, 7419, 11, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $VASP_is_same_vasp_$direct_inter(addr1: $Value, addr2: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_is_same_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr1, addr2)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $VASP_is_same_vasp_$direct_intra(addr1: $Value, addr2: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_is_same_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr1, addr2)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($Boolean($IsEqual($ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, a), old($ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, a)))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall parent: $Value :: is#$Address(parent) ==> b#$Boolean($Boolean(b#$Boolean(old($VASP_$is_parent($VASP_ParentVASP_$memory, parent))) ==> b#$Boolean($Boolean($IsEqual($VASP_spec_num_children($VASP_ParentVASP_$memory, parent), old($VASP_spec_num_children($VASP_ParentVASP_$memory, parent)))))))))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $VASP_is_same_vasp(addr1: $Value, addr2: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_is_same_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr1, addr2)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $VASP_is_vasp_$def(addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(27, 6923, 0, addr); }

    // bytecode translation starts here
    // $t2 := move(addr)
    call $t2 := $CopyOrMoveValue(addr);

    // $t3 := VASP::is_parent($t2)
    call $t3 := $VASP_is_parent($t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 6414, $abort_code);
      goto Abort;
    }

    // if ($t3) goto L0 else goto L1
    if (b#$Boolean($t3)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t4 := true
    $t4 := $Boolean(true);

    // tmp#$1 := $t4
    call tmp#$1 := $CopyOrMoveValue($t4);
    if (true) { assume $DebugTrackLocal(27, 6973, 1, tmp#$1); }

    // goto L3
    goto L3;

    // L2:
L2:

    // tmp#$1 := VASP::is_child($t2)
    call tmp#$1 := $VASP_is_child($t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 6679, $abort_code);
      goto Abort;
    }

    // goto L3
    goto L3;

    // L3:
L3:

    // return tmp#$1
    $ret0 := tmp#$1;
    if (true) { assume $DebugTrackLocal(27, 6973, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $VASP_is_vasp_$direct_inter(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $VASP_$is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $VASP_is_vasp_$direct_intra(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $VASP_$is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($Boolean($IsEqual($ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, a), old($ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, a)))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall parent: $Value :: is#$Address(parent) ==> b#$Boolean($Boolean(b#$Boolean(old($VASP_$is_parent($VASP_ParentVASP_$memory, parent))) ==> b#$Boolean($Boolean($IsEqual($VASP_spec_num_children($VASP_ParentVASP_$memory, parent), old($VASP_spec_num_children($VASP_ParentVASP_$memory, parent)))))))))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $VASP_is_vasp(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $VASP_$is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $VASP_num_children_$def(addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $VASP_ParentVASP_type_value()
    var $t4: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(27, 8087, 0, addr); }

    // bytecode translation starts here
    // $t1 := move(addr)
    call $t1 := $CopyOrMoveValue(addr);

    // $t2 := VASP::parent_address($t1)
    call $t2 := $VASP_parent_address($t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 5372, $abort_code);
      goto Abort;
    }

    // $t3 := get_global<VASP::ParentVASP>($t2)
    call $t3 := $GetGlobal($VASP_ParentVASP_$memory, $t2, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 8246, $abort_code);
      goto Abort;
    }

    // $t4 := get_field<VASP::ParentVASP>.num_children($t3)
    call $t4 := $GetFieldFromValue($t3, $VASP_ParentVASP_num_children);

    // return $t4
    $ret0 := $t4;
    if (true) { assume $DebugTrackLocal(27, 8244, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $VASP_num_children_$direct_inter(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $VASP_num_children_$def(addr);
}


procedure {:inline 1} $VASP_num_children_$direct_intra(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $VASP_num_children_$def(addr);
}


procedure {:inline 1} $VASP_num_children(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $VASP_num_children_$def(addr);
}


procedure {:inline 1} $VASP_parent_address_$def(addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $AddressType()
    var tmp#$2: $Value; // $AddressType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $VASP_ChildVASP_type_value()
    var $t9: $Value; // $AddressType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(27, 5361, 0, addr); }

    // bytecode translation starts here
    // $t3 := move(addr)
    call $t3 := $CopyOrMoveValue(addr);

    // $t4 := VASP::is_parent($t3)
    call $t4 := $VASP_is_parent($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 6414, $abort_code);
      goto Abort;
    }

    // if ($t4) goto L0 else goto L1
    if (b#$Boolean($t4)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // tmp#$2 := $t3
    call tmp#$2 := $CopyOrMoveValue($t3);
    if (true) { assume $DebugTrackLocal(27, 5440, 2, tmp#$2); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t5 := VASP::is_child($t3)
    call $t5 := $VASP_is_child($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 6679, $abort_code);
      goto Abort;
    }

    // if ($t5) goto L4 else goto L5
    if (b#$Boolean($t5)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // $t6 := 2
    $t6 := $Integer(2);

    // $t7 := Errors::invalid_argument($t6)
    call $t7 := $Errors_invalid_argument($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 5649, $abort_code);
      goto Abort;
    }

    // abort($t7)
    if (true) { assume $DebugTrackAbort(27, 5635, i#$Integer($t7)); }
    $abort_code := i#$Integer($t7);
    goto Abort;

    // L4:
L4:

    // $t8 := get_global<VASP::ChildVASP>($t3)
    call $t8 := $GetGlobal($VASP_ChildVASP_$memory, $t3, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 5529, $abort_code);
      goto Abort;
    }

    // $t9 := get_field<VASP::ChildVASP>.parent_vasp_addr($t8)
    call $t9 := $GetFieldFromValue($t8, $VASP_ChildVASP_parent_vasp_addr);

    // tmp#$2 := $t9
    call tmp#$2 := $CopyOrMoveValue($t9);
    if (true) { assume $DebugTrackLocal(27, 5440, 2, tmp#$2); }

    // goto L3
    goto L3;

    // L3:
L3:

    // return tmp#$2
    $ret0 := tmp#$2;
    if (true) { assume $DebugTrackLocal(27, 5440, 10, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $VASP_parent_address_$direct_inter(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($VASP_$is_parent($VASP_ParentVASP_$memory, addr)))) && b#$Boolean($Boolean(!b#$Boolean($VASP_$is_child($VASP_ChildVASP_$memory, addr))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($VASP_$is_parent($VASP_ParentVASP_$memory, addr)))) && b#$Boolean($Boolean(!b#$Boolean($VASP_$is_child($VASP_ChildVASP_$memory, addr))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($VASP_$is_parent($VASP_ParentVASP_$memory, addr)))) && b#$Boolean($Boolean(!b#$Boolean($VASP_$is_child($VASP_ChildVASP_$memory, addr))))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr)))));
ensures is#$Address($ret0);

procedure {:inline 1} $VASP_parent_address_$direct_intra(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($VASP_$is_parent($VASP_ParentVASP_$memory, addr)))) && b#$Boolean($Boolean(!b#$Boolean($VASP_$is_child($VASP_ChildVASP_$memory, addr))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($VASP_$is_parent($VASP_ParentVASP_$memory, addr)))) && b#$Boolean($Boolean(!b#$Boolean($VASP_$is_child($VASP_ChildVASP_$memory, addr))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($VASP_$is_parent($VASP_ParentVASP_$memory, addr)))) && b#$Boolean($Boolean(!b#$Boolean($VASP_$is_child($VASP_ChildVASP_$memory, addr))))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($Boolean($IsEqual($ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, a), old($ResourceExists($VASP_ChildVASP_$memory, $EmptyTypeValueArray, a)))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall parent: $Value :: is#$Address(parent) ==> b#$Boolean($Boolean(b#$Boolean(old($VASP_$is_parent($VASP_ParentVASP_$memory, parent))) ==> b#$Boolean($Boolean($IsEqual($VASP_spec_num_children($VASP_ParentVASP_$memory, parent), old($VASP_spec_num_children($VASP_ParentVASP_$memory, parent)))))))))));
ensures is#$Address($ret0);

procedure {:inline 1} $VASP_parent_address(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($VASP_$is_parent($VASP_ParentVASP_$memory, addr)))) && b#$Boolean($Boolean(!b#$Boolean($VASP_$is_child($VASP_ChildVASP_$memory, addr))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($VASP_$is_parent($VASP_ParentVASP_$memory, addr)))) && b#$Boolean($Boolean(!b#$Boolean($VASP_$is_child($VASP_ChildVASP_$memory, addr))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($VASP_$is_parent($VASP_ParentVASP_$memory, addr)))) && b#$Boolean($Boolean(!b#$Boolean($VASP_$is_child($VASP_ChildVASP_$memory, addr))))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr)))));
ensures is#$Address($ret0);

procedure {:inline 1} $VASP_publish_child_vasp_credential_$def(parent: $Value, child: $Value) returns ()
{
    // declare local variables
    var child_vasp_addr: $Value; // $AddressType()
    var num_children: $Mutation; // ReferenceType($IntegerType())
    var parent_vasp_addr: $Value; // $AddressType()
    var tmp#$5: $Value; // $BooleanType()
    var tmp#$6: $Value; // $IntegerType()
    var tmp#$7: $Value; // $BooleanType()
    var tmp#$8: $Value; // $IntegerType()
    var tmp#$9: $Value; // $BooleanType()
    var tmp#$10: $Value; // $IntegerType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Mutation; // ReferenceType($VASP_ParentVASP_type_value())
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $VASP_ChildVASP_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(27, 2787, 0, parent); }
    if (true) { assume $DebugTrackLocal(27, 2787, 1, child); }

    // bytecode translation starts here
    // $t11 := move(parent)
    call $t11 := $CopyOrMoveValue(parent);

    // $t12 := move(child)
    call $t12 := $CopyOrMoveValue(child);

    // Roles::assert_parent_vasp_role($t11)
    call $Roles_assert_parent_vasp_role($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 2921, $abort_code);
      goto Abort;
    }

    // child_vasp_addr := Signer::address_of($t12)
    call child_vasp_addr := $Signer_address_of($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 2992, $abort_code);
      goto Abort;
    }

    // $t13 := VASP::is_vasp(child_vasp_addr)
    call $t13 := $VASP_is_vasp(child_vasp_addr);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 6934, $abort_code);
      goto Abort;
    }

    // $t14 := !($t13)
    call $t14 := $Not($t13);

    // $t15 := 0
    $t15 := $Integer(0);

    // $t16 := Errors::already_published($t15)
    call $t16 := $Errors_already_published($t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 3061, $abort_code);
      goto Abort;
    }

    // if ($t14) goto L0 else goto L1
    if (b#$Boolean($t14)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t11)

    // destroy($t12)

    // abort($t16)
    if (true) { assume $DebugTrackAbort(27, 3019, i#$Integer($t16)); }
    $abort_code := i#$Integer($t16);
    goto Abort;

    // L0:
L0:

    // parent_vasp_addr := Signer::address_of($t11)
    call parent_vasp_addr := $Signer_address_of($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 3143, $abort_code);
      goto Abort;
    }

    // $t17 := VASP::is_parent(parent_vasp_addr)
    call $t17 := $VASP_is_parent(parent_vasp_addr);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 6414, $abort_code);
      goto Abort;
    }

    // $t18 := 3
    $t18 := $Integer(3);

    // $t19 := Errors::invalid_argument($t18)
    call $t19 := $Errors_invalid_argument($t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 3215, $abort_code);
      goto Abort;
    }

    // if ($t17) goto L2 else goto L3
    if (b#$Boolean($t17)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // destroy($t12)

    // abort($t19)
    if (true) { assume $DebugTrackAbort(27, 3171, i#$Integer($t19)); }
    $abort_code := i#$Integer($t19);
    goto Abort;

    // L2:
L2:

    // $t20 := borrow_global<VASP::ParentVASP>(parent_vasp_addr)
    call $t20 := $BorrowGlobal($VASP_ParentVASP_$memory, parent_vasp_addr, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 3286, $abort_code);
      goto Abort;
    }

    // unpack_ref($t20)

    // num_children := borrow_field<VASP::ParentVASP>.num_children($t20)
    call num_children := $BorrowField($t20, $VASP_ParentVASP_num_children);

    // unpack_ref(num_children)

    // $t21 := read_ref(num_children)
    call $t21 := $ReadRef(num_children);

    // $t22 := 256
    $t22 := $Integer(256);

    // $t23 := <($t21, $t22)
    call $t23 := $Lt($t21, $t22);

    // $t24 := 1
    $t24 := $Integer(1);

    // $t25 := Errors::limit_exceeded($t24)
    call $t25 := $Errors_limit_exceeded($t24);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 3496, $abort_code);
      goto Abort;
    }

    // if ($t23) goto L4 else goto L5
    if (b#$Boolean($t23)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // destroy(num_children)

    // pack_ref(num_children)

    // pack_ref($t20)

    // destroy($t12)

    // abort($t25)
    if (true) { assume $DebugTrackAbort(27, 3445, i#$Integer($t25)); }
    $abort_code := i#$Integer($t25);
    goto Abort;

    // L4:
L4:

    // $t26 := read_ref(num_children)
    call $t26 := $ReadRef(num_children);

    // $t27 := 1
    $t27 := $Integer(1);

    // $t28 := +($t26, $t27)
    call $t28 := $AddU64($t26, $t27);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 3571, $abort_code);
      goto Abort;
    }

    // write_ref(num_children, $t28)
    call num_children := $WriteRef(num_children, $t28);
    if (true) { assume $DebugTrackLocal(27, 3541, 3, $Dereference(num_children)); }

    // pack_ref(num_children)

    // write_back[Reference($t20)](num_children)
    call $t20 := $WritebackToReference(num_children, $t20);

    // pack_ref($t20)

    // write_back[VASP::ParentVASP]($t20)
    call $VASP_ParentVASP_$memory := $WritebackToGlobal($VASP_ParentVASP_$memory, $t20);

    // $t29 := pack VASP::ChildVASP(parent_vasp_addr)
    call $t29 := $VASP_ChildVASP_pack(0, 0, 0, parent_vasp_addr);

    // move_to<VASP::ChildVASP>($t29, $t12)
    call $VASP_ChildVASP_$memory := $MoveTo($VASP_ChildVASP_$memory, $EmptyTypeValueArray, $t29, $t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 3584, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $VASP_publish_child_vasp_credential_$direct_inter(parent: $Value, child: $Value) returns ()
{
    assume is#$Address(parent);

    assume is#$Address(child);

    call $VASP_publish_child_vasp_credential_$def(parent, child);
}


procedure {:inline 1} $VASP_publish_child_vasp_credential_$direct_intra(parent: $Value, child: $Value) returns ()
{
    assume is#$Address(parent);

    assume is#$Address(child);

    call $VASP_publish_child_vasp_credential_$def(parent, child);
}


procedure {:inline 1} $VASP_publish_child_vasp_credential(parent: $Value, child: $Value) returns ()
{
    assume is#$Address(parent);

    assume is#$Address(child);

    call $VASP_publish_child_vasp_credential_$def(parent, child);
}


procedure {:inline 1} $VASP_publish_parent_vasp_credential_$def(vasp: $Value, tc_account: $Value) returns ()
{
    // declare local variables
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var vasp_addr: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $VASP_ParentVASP_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(27, 1660, 0, vasp); }
    if (true) { assume $DebugTrackLocal(27, 1660, 1, tc_account); }

    // bytecode translation starts here
    // $t5 := move(vasp)
    call $t5 := $CopyOrMoveValue(vasp);

    // $t6 := move(tc_account)
    call $t6 := $CopyOrMoveValue(tc_account);

    // LibraTimestamp::assert_operating()
    call $LibraTimestamp_assert_operating();
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 1764, $abort_code);
      goto Abort;
    }

    // Roles::assert_treasury_compliance($t6)
    call $Roles_assert_treasury_compliance($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 1799, $abort_code);
      goto Abort;
    }

    // Roles::assert_parent_vasp_role($t5)
    call $Roles_assert_parent_vasp_role($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 1854, $abort_code);
      goto Abort;
    }

    // vasp_addr := Signer::address_of($t5)
    call vasp_addr := $Signer_address_of($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 1917, $abort_code);
      goto Abort;
    }

    // $t7 := VASP::is_vasp(vasp_addr)
    call $t7 := $VASP_is_vasp(vasp_addr);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 6934, $abort_code);
      goto Abort;
    }

    // $t8 := !($t7)
    call $t8 := $Not($t7);

    // $t9 := 0
    $t9 := $Integer(0);

    // $t10 := Errors::already_published($t9)
    call $t10 := $Errors_already_published($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 1979, $abort_code);
      goto Abort;
    }

    // if ($t8) goto L0 else goto L1
    if (b#$Boolean($t8)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t5)

    // abort($t10)
    if (true) { assume $DebugTrackAbort(27, 1943, i#$Integer($t10)); }
    $abort_code := i#$Integer($t10);
    goto Abort;

    // L0:
L0:

    // $t11 := 0
    $t11 := $Integer(0);

    // $t12 := pack VASP::ParentVASP($t11)
    call $t12 := $VASP_ParentVASP_pack(0, 0, 0, $t11);

    // move_to<VASP::ParentVASP>($t12, $t5)
    call $VASP_ParentVASP_$memory := $MoveTo($VASP_ParentVASP_$memory, $EmptyTypeValueArray, $t12, $t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 2030, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $VASP_publish_parent_vasp_credential_$direct_inter(vasp: $Value, tc_account: $Value) returns ()
{
    assume is#$Address(vasp);

    assume is#$Address(tc_account);

    call $VASP_publish_parent_vasp_credential_$def(vasp, tc_account);
}


procedure {:inline 1} $VASP_publish_parent_vasp_credential_$direct_intra(vasp: $Value, tc_account: $Value) returns ()
{
    assume is#$Address(vasp);

    assume is#$Address(tc_account);

    call $VASP_publish_parent_vasp_credential_$def(vasp, tc_account);
}


procedure {:inline 1} $VASP_publish_parent_vasp_credential(vasp: $Value, tc_account: $Value) returns ()
{
    assume is#$Address(vasp);

    assume is#$Address(tc_account);

    call $VASP_publish_parent_vasp_credential_$def(vasp, tc_account);
}




// ** spec vars of module Signature



// ** spec funs of module Signature



// ** structs of module Signature



// ** functions of module Signature



// ** spec vars of module LBR



// ** spec funs of module LBR

function {:inline} $LBR_reserve_exists($LBR_Reserve_$memory: $Memory): $Value {
    $ResourceExists($LBR_Reserve_$memory, $EmptyTypeValueArray, $CoreAddresses_$CURRENCY_INFO_ADDRESS())
}

function {:inline} $LBR_spec_is_lbr($tv0: $TypeValue): $Value {
    $Boolean($IsEqual($Type($tv0), $Type($LBR_LBR_type_value())))
}



// ** structs of module LBR

const unique $LBR_LBR: $TypeName;
const $LBR_LBR_dummy_field: $FieldName;
axiom $LBR_LBR_dummy_field == 0;
function $LBR_LBR_type_value(): $TypeValue {
    $StructType($LBR_LBR, $EmptyTypeValueArray)
}
var $LBR_LBR_$memory: $Memory;
var $LBR_LBR_$memory_$old: $Memory;
function {:inline} $LBR_LBR_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $LBR_LBR_dummy_field))
}
function {:inline} $LBR_LBR_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $LBR_LBR_$is_well_formed($this: $Value): bool {
    $LBR_LBR_$is_well_typed($this) && $LBR_LBR_$invariant_holds($this)}

procedure {:inline 1} $LBR_LBR_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LBR_LBR_unpack($struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $LBR_LBR_dummy_field);
    assume is#$Boolean(dummy_field);
}

const unique $LBR_Reserve: $TypeName;
const $LBR_Reserve_mint_cap: $FieldName;
axiom $LBR_Reserve_mint_cap == 0;
const $LBR_Reserve_burn_cap: $FieldName;
axiom $LBR_Reserve_burn_cap == 1;
const $LBR_Reserve_preburn_cap: $FieldName;
axiom $LBR_Reserve_preburn_cap == 2;
function $LBR_Reserve_type_value(): $TypeValue {
    $StructType($LBR_Reserve, $EmptyTypeValueArray)
}
var $LBR_Reserve_$memory: $Memory;
var $LBR_Reserve_$memory_$old: $Memory;
function {:inline} $LBR_Reserve_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 3
      && $Libra_MintCapability_$is_well_typed($SelectField($this, $LBR_Reserve_mint_cap))
      && $Libra_BurnCapability_$is_well_typed($SelectField($this, $LBR_Reserve_burn_cap))
      && $Libra_Preburn_$is_well_typed($SelectField($this, $LBR_Reserve_preburn_cap))
}
function {:inline} $LBR_Reserve_$invariant_holds($this: $Value): bool {
    $Libra_MintCapability_$invariant_holds($SelectField($this, $LBR_Reserve_mint_cap))
      && $Libra_BurnCapability_$invariant_holds($SelectField($this, $LBR_Reserve_burn_cap))
      && $Libra_Preburn_$invariant_holds($SelectField($this, $LBR_Reserve_preburn_cap))
}

function {:inline} $LBR_Reserve_$is_well_formed($this: $Value): bool {
    $LBR_Reserve_$is_well_typed($this) && $LBR_Reserve_$invariant_holds($this)}

procedure {:inline 1} $LBR_Reserve_pack($file_id: int, $byte_index: int, $var_idx: int, mint_cap: $Value, burn_cap: $Value, preburn_cap: $Value) returns ($struct: $Value)
{
    assume $Libra_MintCapability_$is_well_formed(mint_cap);
    assume $Libra_BurnCapability_$is_well_formed(burn_cap);
    assume $Libra_Preburn_$is_well_formed(preburn_cap);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := mint_cap][1 := burn_cap][2 := preburn_cap], 3));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LBR_Reserve_unpack($struct: $Value) returns (mint_cap: $Value, burn_cap: $Value, preburn_cap: $Value)
{
    assume is#$Vector($struct);
    mint_cap := $SelectField($struct, $LBR_Reserve_mint_cap);
    assume $Libra_MintCapability_$is_well_formed(mint_cap);
    burn_cap := $SelectField($struct, $LBR_Reserve_burn_cap);
    assume $Libra_BurnCapability_$is_well_formed(burn_cap);
    preburn_cap := $SelectField($struct, $LBR_Reserve_preburn_cap);
    assume $Libra_Preburn_$is_well_formed(preburn_cap);
}



// ** functions of module LBR

procedure {:inline 1} $LBR_initialize_$def(lr_account: $Value, tc_account: $Value) returns ()
{
    // declare local variables
    var burn_cap: $Value; // $Libra_BurnCapability_type_value($LBR_LBR_type_value())
    var mint_cap: $Value; // $Libra_MintCapability_type_value($LBR_LBR_type_value())
    var preburn_cap: $Value; // $Libra_Preburn_type_value($LBR_LBR_type_value())
    var tmp#$5: $Value; // $BooleanType()
    var tmp#$6: $Value; // $IntegerType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $BooleanType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $Vector_type_value($IntegerType())
    var $t21: $Value; // $Libra_MintCapability_type_value($LBR_LBR_type_value())
    var $t22: $Value; // $Libra_BurnCapability_type_value($LBR_LBR_type_value())
    var $t23: $Value; // $BooleanType()
    var $t24: $Value; // $LBR_Reserve_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(13, 2641, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(13, 2641, 1, tc_account); }

    // bytecode translation starts here
    // $t7 := move(lr_account)
    call $t7 := $CopyOrMoveValue(lr_account);

    // $t8 := move(tc_account)
    call $t8 := $CopyOrMoveValue(tc_account);

    // LibraTimestamp::assert_genesis()
    call $LibraTimestamp_assert_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(13, 2754, $abort_code);
      goto Abort;
    }

    // CoreAddresses::assert_currency_info($t7)
    call $CoreAddresses_assert_currency_info($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(13, 2829, $abort_code);
      goto Abort;
    }

    // $t9 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t9 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t10 := exists<LBR::Reserve>($t9)
    $t10 := $ResourceExists($LBR_Reserve_$memory, $EmptyTypeValueArray, $t9);

    // $t11 := !($t10)
    call $t11 := $Not($t10);

    // $t12 := 0
    $t12 := $Integer(0);

    // $t13 := Errors::already_published($t12)
    call $t13 := $Errors_already_published($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(13, 2976, $abort_code);
      goto Abort;
    }

    // if ($t11) goto L0 else goto L1
    if (b#$Boolean($t11)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t8)

    // destroy($t7)

    // abort($t13)
    if (true) { assume $DebugTrackAbort(13, 2906, i#$Integer($t13)); }
    $abort_code := i#$Integer($t13);
    goto Abort;

    // L0:
L0:

    // $t14 := 1
    $t14 := $Integer(1);

    // $t15 := 1
    $t15 := $Integer(1);

    // $t16 := FixedPoint32::create_from_rational($t14, $t15)
    call $t16 := $FixedPoint32_create_from_rational($t14, $t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(13, 3122, $abort_code);
      goto Abort;
    }

    // $t17 := true
    $t17 := $Boolean(true);

    // $t18 := 1000000
    $t18 := $Integer(1000000);

    // $t19 := 1000
    $t19 := $Integer(1000);

    // $t20 := [76, 66, 82]
    $t20 := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := $Integer(76)][1 := $Integer(66)][2 := $Integer(82)], 3));

    // ($t21, $t22) := Libra::register_currency<LBR::LBR>($t7, $t16, $t17, $t18, $t19, $t20)
    call $t21, $t22 := $Libra_register_currency($LBR_LBR_type_value(), $t7, $t16, $t17, $t18, $t19, $t20);
    if ($abort_flag) {
      goto Abort;
    }

    // burn_cap := $t22
    call burn_cap := $CopyOrMoveValue($t22);
    if (true) { assume $DebugTrackLocal(13, 3029, 2, burn_cap); }

    // mint_cap := $t21
    call mint_cap := $CopyOrMoveValue($t21);
    if (true) { assume $DebugTrackLocal(13, 3019, 3, mint_cap); }

    // $t23 := false
    $t23 := $Boolean(false);

    // Libra::update_minting_ability<LBR::LBR>($t8, $t23)
    call $Libra_update_minting_ability($LBR_LBR_type_value(), $t8, $t23);
    if ($abort_flag) {
      goto Abort;
    }

    // AccountLimits::publish_unrestricted_limits<LBR::LBR>($t7)
    call $AccountLimits_publish_unrestricted_limits($LBR_LBR_type_value(), $t7);
    if ($abort_flag) {
      goto Abort;
    }

    // preburn_cap := Libra::create_preburn<LBR::LBR>($t8)
    call preburn_cap := $Libra_create_preburn($LBR_LBR_type_value(), $t8);
    if ($abort_flag) {
      goto Abort;
    }

    // $t24 := pack LBR::Reserve(mint_cap, burn_cap, preburn_cap)
    call $t24 := $LBR_Reserve_pack(0, 0, 0, mint_cap, burn_cap, preburn_cap);

    // move_to<LBR::Reserve>($t24, $t7)
    call $LBR_Reserve_$memory := $MoveTo($LBR_Reserve_$memory, $EmptyTypeValueArray, $t24, $t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(13, 3573, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LBR_initialize_$direct_inter(lr_account: $Value, tc_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume is#$Address(tc_account);

    call $LBR_initialize_$def(lr_account, tc_account);
}


procedure {:inline 1} $LBR_initialize_$direct_intra(lr_account: $Value, tc_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume is#$Address(tc_account);

    call $LBR_initialize_$def(lr_account, tc_account);
}


procedure {:inline 1} $LBR_initialize(lr_account: $Value, tc_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume is#$Address(tc_account);

    call $LBR_initialize_$def(lr_account, tc_account);
}


procedure {:inline 1} $LBR_is_lbr_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$0: $Value; // $BooleanType()
    var $t1: $Value; // $BooleanType()
    var $t2: $Value; // $Vector_type_value($IntegerType())
    var $t3: $Value; // $Vector_type_value($IntegerType())
    var $t4: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t1 := Libra::is_currency<#0>()
    call $t1 := $Libra_is_currency($tv0);
    if ($abort_flag) {
      goto Abort;
    }

    // if ($t1) goto L0 else goto L1
    if (b#$Boolean($t1)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t2 := Libra::currency_code<#0>()
    call $t2 := $Libra_currency_code($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(13, 3798, $abort_code);
      goto Abort;
    }

    // $t3 := Libra::currency_code<LBR::LBR>()
    call $t3 := $Libra_currency_code($LBR_LBR_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(13, 3834, $abort_code);
      goto Abort;
    }

    // tmp#$0 := ==($t2, $t3)
    tmp#$0 := $Boolean($IsEqual($t2, $t3));
    if (true) { assume $DebugTrackLocal(13, 3824, 0, tmp#$0); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t4 := false
    $t4 := $Boolean(false);

    // tmp#$0 := $t4
    call tmp#$0 := $CopyOrMoveValue($t4);
    if (true) { assume $DebugTrackLocal(13, 3745, 0, tmp#$0); }

    // goto L3
    goto L3;

    // L3:
L3:

    // return tmp#$0
    $ret0 := tmp#$0;
    if (true) { assume $DebugTrackLocal(13, 3745, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LBR_is_lbr_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $LBR_LBR_type_value()))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $LBR_LBR_type_value()))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $LBR_LBR_type_value()))))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual($ret0, $Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))) && b#$Boolean($LBR_spec_is_lbr($tv0)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $LBR_is_lbr_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $LBR_LBR_type_value()))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $LBR_LBR_type_value()))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $LBR_LBR_type_value()))))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual($ret0, $Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))) && b#$Boolean($LBR_spec_is_lbr($tv0)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $LBR_is_lbr($tv0: $TypeValue) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $LBR_LBR_type_value()))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $LBR_LBR_type_value()))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $LBR_LBR_type_value()))))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual($ret0, $Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))) && b#$Boolean($LBR_spec_is_lbr($tv0)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $LBR_reserve_address_$def() returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $AddressType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // return $t0
    $ret0 := $t0;
    if (true) { assume $DebugTrackLocal(13, 4540, 1, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LBR_reserve_address_$direct_inter() returns ($ret0: $Value)
{
    call $ret0 := $LBR_reserve_address_$def();
}


procedure {:inline 1} $LBR_reserve_address_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $LBR_reserve_address_$def();
}


procedure {:inline 1} $LBR_reserve_address() returns ($ret0: $Value)
{
    call $ret0 := $LBR_reserve_address_$def();
}




// ** spec vars of module DualAttestation



// ** spec funs of module DualAttestation

function {:inline} $DualAttestation_spec_has_credential($DualAttestation_Credential_$memory: $Memory, addr: $Value): $Value {
    $ResourceExists($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr)
}

function {:inline} $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory: $Memory, addr: $Value): $Value {
    $SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr), $DualAttestation_Credential_compliance_public_key)
}

function {:inline} $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, addr: $Value): $Value {
    if (b#$Boolean($VASP_$is_child($VASP_ChildVASP_$memory, addr))) then ($VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr)) else (addr)
}

function {:inline} $DualAttestation_spec_is_inter_vasp($VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, payer: $Value, payee: $Value): $Value {
    $Boolean(b#$Boolean($Boolean(b#$Boolean($VASP_$is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)) && b#$Boolean($VASP_$is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))) && b#$Boolean($Boolean(!$IsEqual($VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))
}

function {:inline} $DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory: $Memory, $VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, $DualAttestation_Limit_$memory: $Memory, $tv0: $TypeValue, payer: $Value, payee: $Value, deposit_value: $Value): $Value {
    $Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(i#$Integer($Libra_spec_approx_lbr_for_value($Libra_CurrencyInfo_$memory, $tv0, deposit_value)) >= i#$Integer($DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory)))) && b#$Boolean($Boolean(!$IsEqual(payer, payee))))) && b#$Boolean($DualAttestation_spec_is_inter_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee)))
}

function {:inline} $DualAttestation_spec_dual_attestation_message(payer: $Value, metadata: $Value, deposit_value: $Value): $Value;
axiom (forall payer: $Value, metadata: $Value, deposit_value: $Value :: $Vector_$is_well_formed($DualAttestation_spec_dual_attestation_message(payer, metadata, deposit_value)) && (forall $$0: int :: {$select_vector($DualAttestation_spec_dual_attestation_message(payer, metadata, deposit_value),$$0)} $$0 >= 0 && $$0 < $vlen($DualAttestation_spec_dual_attestation_message(payer, metadata, deposit_value)) ==> $IsValidU8($select_vector($DualAttestation_spec_dual_attestation_message(payer, metadata, deposit_value),$$0))));
function {:inline} $DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, $DualAttestation_Credential_$memory: $Memory, payer: $Value, payee: $Value, metadata_signature: $Value, metadata: $Value, deposit_value: $Value): $Value {
    (var payee_compliance_key := $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)); $Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(64)))) && b#$Boolean($Boolean(!b#$Boolean($Vector_$is_empty($IntegerType(), payee_compliance_key)))))) && b#$Boolean($Signature_$ed25519_verify(metadata_signature, payee_compliance_key, $DualAttestation_spec_dual_attestation_message(payer, metadata, deposit_value)))))
}

function {:inline} $DualAttestation_spec_is_published($DualAttestation_Limit_$memory: $Memory): $Value {
    $ResourceExists($DualAttestation_Limit_$memory, $EmptyTypeValueArray, $CoreAddresses_$LIBRA_ROOT_ADDRESS())
}

function {:inline} $DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory: $Memory): $Value {
    $SelectField($ResourceValue($DualAttestation_Limit_$memory, $EmptyTypeValueArray, $CoreAddresses_$LIBRA_ROOT_ADDRESS()), $DualAttestation_Limit_micro_lbr_limit)
}

function {:inline} $DualAttestation_sender$24(account: $Value): $Value {
    $Signer_spec_address_of(account)
}

function {:inline} $DualAttestation_sender$25(account: $Value): $Value {
    $Signer_spec_address_of(account)
}

function {:inline} $DualAttestation_sender$26(account: $Value): $Value {
    $Signer_spec_address_of(account)
}

function {:inline} $DualAttestation_sender$27(account: $Value): $Value {
    $Signer_spec_address_of(account)
}

function {:inline} $DualAttestation_initial_limit$28($Libra_CurrencyInfo_$memory: $Memory): $Value {
    $Integer(i#$Integer($Integer(1000)) * i#$Integer($Libra_spec_scaling_factor($Libra_CurrencyInfo_$memory, $LBR_LBR_type_value())))
}



// ** structs of module DualAttestation

const unique $DualAttestation_BaseUrlRotationEvent: $TypeName;
const $DualAttestation_BaseUrlRotationEvent_new_base_url: $FieldName;
axiom $DualAttestation_BaseUrlRotationEvent_new_base_url == 0;
const $DualAttestation_BaseUrlRotationEvent_time_rotated_seconds: $FieldName;
axiom $DualAttestation_BaseUrlRotationEvent_time_rotated_seconds == 1;
function $DualAttestation_BaseUrlRotationEvent_type_value(): $TypeValue {
    $StructType($DualAttestation_BaseUrlRotationEvent, $EmptyTypeValueArray)
}
var $DualAttestation_BaseUrlRotationEvent_$memory: $Memory;
var $DualAttestation_BaseUrlRotationEvent_$memory_$old: $Memory;
function {:inline} $DualAttestation_BaseUrlRotationEvent_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 2
      && $Vector_$is_well_formed($SelectField($this, $DualAttestation_BaseUrlRotationEvent_new_base_url)) && (forall $$0: int :: {$select_vector($SelectField($this, $DualAttestation_BaseUrlRotationEvent_new_base_url),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $DualAttestation_BaseUrlRotationEvent_new_base_url)) ==> $IsValidU8($select_vector($SelectField($this, $DualAttestation_BaseUrlRotationEvent_new_base_url),$$0)))
      && $IsValidU64($SelectField($this, $DualAttestation_BaseUrlRotationEvent_time_rotated_seconds))
}
function {:inline} $DualAttestation_BaseUrlRotationEvent_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $DualAttestation_BaseUrlRotationEvent_$is_well_formed($this: $Value): bool {
    $DualAttestation_BaseUrlRotationEvent_$is_well_typed($this) && $DualAttestation_BaseUrlRotationEvent_$invariant_holds($this)}

procedure {:inline 1} $DualAttestation_BaseUrlRotationEvent_pack($file_id: int, $byte_index: int, $var_idx: int, new_base_url: $Value, time_rotated_seconds: $Value) returns ($struct: $Value)
{
    assume $Vector_$is_well_formed(new_base_url) && (forall $$0: int :: {$select_vector(new_base_url,$$0)} $$0 >= 0 && $$0 < $vlen(new_base_url) ==> $IsValidU8($select_vector(new_base_url,$$0)));
    assume $IsValidU64(time_rotated_seconds);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := new_base_url][1 := time_rotated_seconds], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $DualAttestation_BaseUrlRotationEvent_unpack($struct: $Value) returns (new_base_url: $Value, time_rotated_seconds: $Value)
{
    assume is#$Vector($struct);
    new_base_url := $SelectField($struct, $DualAttestation_BaseUrlRotationEvent_new_base_url);
    assume $Vector_$is_well_formed(new_base_url) && (forall $$0: int :: {$select_vector(new_base_url,$$0)} $$0 >= 0 && $$0 < $vlen(new_base_url) ==> $IsValidU8($select_vector(new_base_url,$$0)));
    time_rotated_seconds := $SelectField($struct, $DualAttestation_BaseUrlRotationEvent_time_rotated_seconds);
    assume $IsValidU64(time_rotated_seconds);
}

const unique $DualAttestation_ComplianceKeyRotationEvent: $TypeName;
const $DualAttestation_ComplianceKeyRotationEvent_new_compliance_public_key: $FieldName;
axiom $DualAttestation_ComplianceKeyRotationEvent_new_compliance_public_key == 0;
const $DualAttestation_ComplianceKeyRotationEvent_time_rotated_seconds: $FieldName;
axiom $DualAttestation_ComplianceKeyRotationEvent_time_rotated_seconds == 1;
function $DualAttestation_ComplianceKeyRotationEvent_type_value(): $TypeValue {
    $StructType($DualAttestation_ComplianceKeyRotationEvent, $EmptyTypeValueArray)
}
var $DualAttestation_ComplianceKeyRotationEvent_$memory: $Memory;
var $DualAttestation_ComplianceKeyRotationEvent_$memory_$old: $Memory;
function {:inline} $DualAttestation_ComplianceKeyRotationEvent_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 2
      && $Vector_$is_well_formed($SelectField($this, $DualAttestation_ComplianceKeyRotationEvent_new_compliance_public_key)) && (forall $$0: int :: {$select_vector($SelectField($this, $DualAttestation_ComplianceKeyRotationEvent_new_compliance_public_key),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $DualAttestation_ComplianceKeyRotationEvent_new_compliance_public_key)) ==> $IsValidU8($select_vector($SelectField($this, $DualAttestation_ComplianceKeyRotationEvent_new_compliance_public_key),$$0)))
      && $IsValidU64($SelectField($this, $DualAttestation_ComplianceKeyRotationEvent_time_rotated_seconds))
}
function {:inline} $DualAttestation_ComplianceKeyRotationEvent_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $DualAttestation_ComplianceKeyRotationEvent_$is_well_formed($this: $Value): bool {
    $DualAttestation_ComplianceKeyRotationEvent_$is_well_typed($this) && $DualAttestation_ComplianceKeyRotationEvent_$invariant_holds($this)}

procedure {:inline 1} $DualAttestation_ComplianceKeyRotationEvent_pack($file_id: int, $byte_index: int, $var_idx: int, new_compliance_public_key: $Value, time_rotated_seconds: $Value) returns ($struct: $Value)
{
    assume $Vector_$is_well_formed(new_compliance_public_key) && (forall $$0: int :: {$select_vector(new_compliance_public_key,$$0)} $$0 >= 0 && $$0 < $vlen(new_compliance_public_key) ==> $IsValidU8($select_vector(new_compliance_public_key,$$0)));
    assume $IsValidU64(time_rotated_seconds);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := new_compliance_public_key][1 := time_rotated_seconds], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $DualAttestation_ComplianceKeyRotationEvent_unpack($struct: $Value) returns (new_compliance_public_key: $Value, time_rotated_seconds: $Value)
{
    assume is#$Vector($struct);
    new_compliance_public_key := $SelectField($struct, $DualAttestation_ComplianceKeyRotationEvent_new_compliance_public_key);
    assume $Vector_$is_well_formed(new_compliance_public_key) && (forall $$0: int :: {$select_vector(new_compliance_public_key,$$0)} $$0 >= 0 && $$0 < $vlen(new_compliance_public_key) ==> $IsValidU8($select_vector(new_compliance_public_key,$$0)));
    time_rotated_seconds := $SelectField($struct, $DualAttestation_ComplianceKeyRotationEvent_time_rotated_seconds);
    assume $IsValidU64(time_rotated_seconds);
}

const unique $DualAttestation_Credential: $TypeName;
const $DualAttestation_Credential_human_name: $FieldName;
axiom $DualAttestation_Credential_human_name == 0;
const $DualAttestation_Credential_base_url: $FieldName;
axiom $DualAttestation_Credential_base_url == 1;
const $DualAttestation_Credential_compliance_public_key: $FieldName;
axiom $DualAttestation_Credential_compliance_public_key == 2;
const $DualAttestation_Credential_expiration_date: $FieldName;
axiom $DualAttestation_Credential_expiration_date == 3;
const $DualAttestation_Credential_compliance_key_rotation_events: $FieldName;
axiom $DualAttestation_Credential_compliance_key_rotation_events == 4;
const $DualAttestation_Credential_base_url_rotation_events: $FieldName;
axiom $DualAttestation_Credential_base_url_rotation_events == 5;
function $DualAttestation_Credential_type_value(): $TypeValue {
    $StructType($DualAttestation_Credential, $EmptyTypeValueArray)
}
var $DualAttestation_Credential_$memory: $Memory;
var $DualAttestation_Credential_$memory_$old: $Memory;
function {:inline} $DualAttestation_Credential_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 6
      && $Vector_$is_well_formed($SelectField($this, $DualAttestation_Credential_human_name)) && (forall $$0: int :: {$select_vector($SelectField($this, $DualAttestation_Credential_human_name),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $DualAttestation_Credential_human_name)) ==> $IsValidU8($select_vector($SelectField($this, $DualAttestation_Credential_human_name),$$0)))
      && $Vector_$is_well_formed($SelectField($this, $DualAttestation_Credential_base_url)) && (forall $$0: int :: {$select_vector($SelectField($this, $DualAttestation_Credential_base_url),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $DualAttestation_Credential_base_url)) ==> $IsValidU8($select_vector($SelectField($this, $DualAttestation_Credential_base_url),$$0)))
      && $Vector_$is_well_formed($SelectField($this, $DualAttestation_Credential_compliance_public_key)) && (forall $$0: int :: {$select_vector($SelectField($this, $DualAttestation_Credential_compliance_public_key),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $DualAttestation_Credential_compliance_public_key)) ==> $IsValidU8($select_vector($SelectField($this, $DualAttestation_Credential_compliance_public_key),$$0)))
      && $IsValidU64($SelectField($this, $DualAttestation_Credential_expiration_date))
      && $Event_EventHandle_$is_well_typed($SelectField($this, $DualAttestation_Credential_compliance_key_rotation_events))
      && $Event_EventHandle_$is_well_typed($SelectField($this, $DualAttestation_Credential_base_url_rotation_events))
}
function {:inline} $DualAttestation_Credential_$invariant_holds($this: $Value): bool {
    $Event_EventHandle_$invariant_holds($SelectField($this, $DualAttestation_Credential_compliance_key_rotation_events))
      && $Event_EventHandle_$invariant_holds($SelectField($this, $DualAttestation_Credential_base_url_rotation_events))
}

function {:inline} $DualAttestation_Credential_$is_well_formed($this: $Value): bool {
    $DualAttestation_Credential_$is_well_typed($this) && $DualAttestation_Credential_$invariant_holds($this)}

procedure {:inline 1} $DualAttestation_Credential_pack($file_id: int, $byte_index: int, $var_idx: int, human_name: $Value, base_url: $Value, compliance_public_key: $Value, expiration_date: $Value, compliance_key_rotation_events: $Value, base_url_rotation_events: $Value) returns ($struct: $Value)
{
    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));
    assume $Vector_$is_well_formed(base_url) && (forall $$0: int :: {$select_vector(base_url,$$0)} $$0 >= 0 && $$0 < $vlen(base_url) ==> $IsValidU8($select_vector(base_url,$$0)));
    assume $Vector_$is_well_formed(compliance_public_key) && (forall $$0: int :: {$select_vector(compliance_public_key,$$0)} $$0 >= 0 && $$0 < $vlen(compliance_public_key) ==> $IsValidU8($select_vector(compliance_public_key,$$0)));
    assume $IsValidU64(expiration_date);
    assume $Event_EventHandle_$is_well_formed(compliance_key_rotation_events);
    assume $Event_EventHandle_$is_well_formed(base_url_rotation_events);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := human_name][1 := base_url][2 := compliance_public_key][3 := expiration_date][4 := compliance_key_rotation_events][5 := base_url_rotation_events], 6));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $DualAttestation_Credential_unpack($struct: $Value) returns (human_name: $Value, base_url: $Value, compliance_public_key: $Value, expiration_date: $Value, compliance_key_rotation_events: $Value, base_url_rotation_events: $Value)
{
    assume is#$Vector($struct);
    human_name := $SelectField($struct, $DualAttestation_Credential_human_name);
    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));
    base_url := $SelectField($struct, $DualAttestation_Credential_base_url);
    assume $Vector_$is_well_formed(base_url) && (forall $$0: int :: {$select_vector(base_url,$$0)} $$0 >= 0 && $$0 < $vlen(base_url) ==> $IsValidU8($select_vector(base_url,$$0)));
    compliance_public_key := $SelectField($struct, $DualAttestation_Credential_compliance_public_key);
    assume $Vector_$is_well_formed(compliance_public_key) && (forall $$0: int :: {$select_vector(compliance_public_key,$$0)} $$0 >= 0 && $$0 < $vlen(compliance_public_key) ==> $IsValidU8($select_vector(compliance_public_key,$$0)));
    expiration_date := $SelectField($struct, $DualAttestation_Credential_expiration_date);
    assume $IsValidU64(expiration_date);
    compliance_key_rotation_events := $SelectField($struct, $DualAttestation_Credential_compliance_key_rotation_events);
    assume $Event_EventHandle_$is_well_formed(compliance_key_rotation_events);
    base_url_rotation_events := $SelectField($struct, $DualAttestation_Credential_base_url_rotation_events);
    assume $Event_EventHandle_$is_well_formed(base_url_rotation_events);
}

const unique $DualAttestation_Limit: $TypeName;
const $DualAttestation_Limit_micro_lbr_limit: $FieldName;
axiom $DualAttestation_Limit_micro_lbr_limit == 0;
function $DualAttestation_Limit_type_value(): $TypeValue {
    $StructType($DualAttestation_Limit, $EmptyTypeValueArray)
}
var $DualAttestation_Limit_$memory: $Memory;
var $DualAttestation_Limit_$memory_$old: $Memory;
function {:inline} $DualAttestation_Limit_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $DualAttestation_Limit_micro_lbr_limit))
}
function {:inline} $DualAttestation_Limit_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $DualAttestation_Limit_$is_well_formed($this: $Value): bool {
    $DualAttestation_Limit_$is_well_typed($this) && $DualAttestation_Limit_$invariant_holds($this)}

procedure {:inline 1} $DualAttestation_Limit_pack($file_id: int, $byte_index: int, $var_idx: int, micro_lbr_limit: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(micro_lbr_limit);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := micro_lbr_limit], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $DualAttestation_Limit_unpack($struct: $Value) returns (micro_lbr_limit: $Value)
{
    assume is#$Vector($struct);
    micro_lbr_limit := $SelectField($struct, $DualAttestation_Limit_micro_lbr_limit);
    assume $IsValidU64(micro_lbr_limit);
}



// ** functions of module DualAttestation

procedure {:inline 1} $DualAttestation_initialize_$def(lr_account: $Value) returns ()
{
    // declare local variables
    var initial_limit: $Value; // $IntegerType()
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $DualAttestation_Limit_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(8, 19844, 0, lr_account); }

    // bytecode translation starts here
    // $t6 := move(lr_account)
    call $t6 := $CopyOrMoveValue(lr_account);

    // LibraTimestamp::assert_genesis()
    call $LibraTimestamp_assert_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 19913, $abort_code);
      goto Abort;
    }

    // CoreAddresses::assert_libra_root($t6)
    call $CoreAddresses_assert_libra_root($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 19954, $abort_code);
      goto Abort;
    }

    // $t7 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t7 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t8 := exists<DualAttestation::Limit>($t7)
    $t8 := $ResourceExists($DualAttestation_Limit_$memory, $EmptyTypeValueArray, $t7);

    // $t9 := !($t8)
    call $t9 := $Not($t8);

    // $t10 := 1
    $t10 := $Integer(1);

    // $t11 := Errors::already_published($t10)
    call $t11 := $Errors_already_published($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 20088, $abort_code);
      goto Abort;
    }

    // if ($t9) goto L0 else goto L1
    if (b#$Boolean($t9)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t6)

    // abort($t11)
    if (true) { assume $DebugTrackAbort(8, 20020, i#$Integer($t11)); }
    $abort_code := i#$Integer($t11);
    goto Abort;

    // L0:
L0:

    // $t12 := 1000
    $t12 := $Integer(1000);

    // $t13 := (u128)($t12)
    call $t13 := $CastU128($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 20144, $abort_code);
      goto Abort;
    }

    // $t14 := Libra::scaling_factor<LBR::LBR>()
    call $t14 := $Libra_scaling_factor($LBR_LBR_type_value());
    if ($abort_flag) {
      goto Abort;
    }

    // $t15 := (u128)($t14)
    call $t15 := $CastU128($t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 20187, $abort_code);
      goto Abort;
    }

    // initial_limit := *($t13, $t15)
    call initial_limit := $MulU128($t13, $t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 20185, $abort_code);
      goto Abort;
    }
    if (true) { assume $DebugTrackLocal(8, 20185, 1, initial_limit); }

    // $t16 := 18446744073709551615
    $t16 := $Integer(18446744073709551615);

    // $t17 := <=(initial_limit, $t16)
    call $t17 := $Le(initial_limit, $t16);

    // $t18 := 1
    $t18 := $Integer(1);

    // $t19 := Errors::limit_exceeded($t18)
    call $t19 := $Errors_limit_exceeded($t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 20276, $abort_code);
      goto Abort;
    }

    // if ($t17) goto L2 else goto L3
    if (b#$Boolean($t17)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // destroy($t6)

    // abort($t19)
    if (true) { assume $DebugTrackAbort(8, 20235, i#$Integer($t19)); }
    $abort_code := i#$Integer($t19);
    goto Abort;

    // L2:
L2:

    // $t20 := (u64)(initial_limit)
    call $t20 := $CastU64(initial_limit);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 20395, $abort_code);
      goto Abort;
    }

    // $t21 := pack DualAttestation::Limit($t20)
    call $t21 := $DualAttestation_Limit_pack(0, 0, 0, $t20);

    // move_to<DualAttestation::Limit>($t21, $t6)
    call $DualAttestation_Limit_$memory := $MoveTo($DualAttestation_Limit_$memory, $EmptyTypeValueArray, $t21, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 20309, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $DualAttestation_initialize_$direct_inter(lr_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    call $DualAttestation_initialize_$def(lr_account);
}


procedure {:inline 1} $DualAttestation_initialize_$direct_intra(lr_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    call $DualAttestation_initialize_$def(lr_account);
}


procedure {:inline 1} $DualAttestation_initialize(lr_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    call $DualAttestation_initialize_$def(lr_account);
}


procedure {:inline 1} $DualAttestation_assert_payment_ok_$def($tv0: $TypeValue, payer: $Value, payee: $Value, value: $Value, metadata: $Value, metadata_signature: $Value) returns ()
{
    // declare local variables
    var tmp#$5: $Value; // $BooleanType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $Vector_type_value($IntegerType())
    var $t10: $Value; // $Vector_type_value($IntegerType())
    var $t11: $Value; // $BooleanType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(8, 18495, 0, payer); }
    if (true) { assume $DebugTrackLocal(8, 18495, 1, payee); }
    if (true) { assume $DebugTrackLocal(8, 18495, 2, value); }
    if (true) { assume $DebugTrackLocal(8, 18495, 3, metadata); }
    if (true) { assume $DebugTrackLocal(8, 18495, 4, metadata_signature); }

    // bytecode translation starts here
    // $t6 := move(payer)
    call $t6 := $CopyOrMoveValue(payer);

    // $t7 := move(payee)
    call $t7 := $CopyOrMoveValue(payee);

    // $t8 := move(value)
    call $t8 := $CopyOrMoveValue(value);

    // $t9 := move(metadata)
    call $t9 := $CopyOrMoveValue(metadata);

    // $t10 := move(metadata_signature)
    call $t10 := $CopyOrMoveValue(metadata_signature);

    // $t11 := Vector::is_empty<u8>($t10)
    call $t11 := $Vector_is_empty($IntegerType(), $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 18728, $abort_code);
      goto Abort;
    }

    // $t12 := !($t11)
    call $t12 := $Not($t11);

    // if ($t12) goto L0 else goto L1
    if (b#$Boolean($t12)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t13 := true
    $t13 := $Boolean(true);

    // tmp#$5 := $t13
    call tmp#$5 := $CopyOrMoveValue($t13);
    if (true) { assume $DebugTrackLocal(8, 18719, 5, tmp#$5); }

    // goto L3
    goto L3;

    // L2:
L2:

    // tmp#$5 := DualAttestation::dual_attestation_required<#0>($t6, $t7, $t8)
    call tmp#$5 := $DualAttestation_dual_attestation_required($tv0, $t6, $t7, $t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 12142, $abort_code);
      goto Abort;
    }

    // goto L3
    goto L3;

    // L3:
L3:

    // if (tmp#$5) goto L4 else goto L5
    if (b#$Boolean(tmp#$5)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // goto L6
    goto L6;

    // L4:
L4:

    // DualAttestation::assert_signature_is_valid($t6, $t7, $t10, $t9, $t8)
    call $DualAttestation_assert_signature_is_valid($t6, $t7, $t10, $t9, $t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 15527, $abort_code);
      goto Abort;
    }

    // goto L6
    goto L6;

    // L6:
L6:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $DualAttestation_assert_payment_ok_$direct_inter($tv0: $TypeValue, payer: $Value, payee: $Value, value: $Value, metadata: $Value, metadata_signature: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, value))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, value)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, value))))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) &&
       $abort_code == i#$Integer($Integer(5))));

procedure {:inline 1} $DualAttestation_assert_payment_ok_$direct_intra($tv0: $TypeValue, payer: $Value, payee: $Value, value: $Value, metadata: $Value, metadata_signature: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, value))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, value)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, value))))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) &&
       $abort_code == i#$Integer($Integer(5))));

procedure {:inline 1} $DualAttestation_assert_payment_ok($tv0: $TypeValue, payer: $Value, payee: $Value, value: $Value, metadata: $Value, metadata_signature: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, value))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, value)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, value))))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, value)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) &&
       $abort_code == i#$Integer($Integer(5))));

procedure {:inline 1} $DualAttestation_assert_signature_is_valid_$def(payer: $Value, payee: $Value, metadata_signature: $Value, metadata: $Value, deposit_value: $Value) returns ()
{
    // declare local variables
    var message: $Value; // $Vector_type_value($IntegerType())
    var payee_compliance_key: $Value; // $Vector_type_value($IntegerType())
    var tmp#$7: $Value; // $BooleanType()
    var tmp#$8: $Value; // $IntegerType()
    var tmp#$9: $Value; // $BooleanType()
    var tmp#$10: $Value; // $IntegerType()
    var tmp#$11: $Value; // $BooleanType()
    var tmp#$12: $Value; // $IntegerType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $Vector_type_value($IntegerType())
    var $t16: $Value; // $Vector_type_value($IntegerType())
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $BooleanType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $AddressType()
    var $t24: $Value; // $BooleanType()
    var $t25: $Value; // $BooleanType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $BooleanType()
    var $t29: $Value; // $IntegerType()
    var $t30: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(8, 15523, 0, payer); }
    if (true) { assume $DebugTrackLocal(8, 15523, 1, payee); }
    if (true) { assume $DebugTrackLocal(8, 15523, 2, metadata_signature); }
    if (true) { assume $DebugTrackLocal(8, 15523, 3, metadata); }
    if (true) { assume $DebugTrackLocal(8, 15523, 4, deposit_value); }

    // bytecode translation starts here
    // $t13 := move(payer)
    call $t13 := $CopyOrMoveValue(payer);

    // $t14 := move(payee)
    call $t14 := $CopyOrMoveValue(payee);

    // $t15 := move(metadata_signature)
    call $t15 := $CopyOrMoveValue(metadata_signature);

    // $t16 := move(metadata)
    call $t16 := $CopyOrMoveValue(metadata);

    // $t17 := move(deposit_value)
    call $t17 := $CopyOrMoveValue(deposit_value);

    // $t18 := Vector::length<u8>($t15)
    call $t18 := $Vector_length($IntegerType(), $t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 15809, $abort_code);
      goto Abort;
    }

    // $t19 := 64
    $t19 := $Integer(64);

    // $t20 := ==($t18, $t19)
    $t20 := $Boolean($IsEqual($t18, $t19));

    // $t21 := 3
    $t21 := $Integer(3);

    // $t22 := Errors::invalid_argument($t21)
    call $t22 := $Errors_invalid_argument($t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 15864, $abort_code);
      goto Abort;
    }

    // if ($t20) goto L0 else goto L1
    if (b#$Boolean($t20)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t22)
    if (true) { assume $DebugTrackAbort(8, 15781, i#$Integer($t22)); }
    $abort_code := i#$Integer($t22);
    goto Abort;

    // L0:
L0:

    // $t23 := DualAttestation::credential_address($t14)
    call $t23 := $DualAttestation_credential_address($t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 11591, $abort_code);
      goto Abort;
    }

    // payee_compliance_key := DualAttestation::compliance_public_key($t23)
    call payee_compliance_key := $DualAttestation_compliance_public_key($t23);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 10241, $abort_code);
      goto Abort;
    }

    // $t24 := Vector::is_empty<u8>(payee_compliance_key)
    call $t24 := $Vector_is_empty($IntegerType(), payee_compliance_key);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 16102, $abort_code);
      goto Abort;
    }

    // $t25 := !($t24)
    call $t25 := $Not($t24);

    // $t26 := 5
    $t26 := $Integer(5);

    // $t27 := Errors::invalid_state($t26)
    call $t27 := $Errors_invalid_state($t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 16155, $abort_code);
      goto Abort;
    }

    // if ($t25) goto L2 else goto L3
    if (b#$Boolean($t25)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t27)
    if (true) { assume $DebugTrackAbort(8, 16073, i#$Integer($t27)); }
    $abort_code := i#$Integer($t27);
    goto Abort;

    // L2:
L2:

    // message := DualAttestation::dual_attestation_message($t13, $t16, $t17)
    call message := $DualAttestation_dual_attestation_message($t13, $t16, $t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 14229, $abort_code);
      goto Abort;
    }

    // $t28 := Signature::ed25519_verify($t15, payee_compliance_key, message)
    call $t28 := $Signature_ed25519_verify($t15, payee_compliance_key, message);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 16383, $abort_code);
      goto Abort;
    }

    // $t29 := 4
    $t29 := $Integer(4);

    // $t30 := Errors::invalid_argument($t29)
    call $t30 := $Errors_invalid_argument($t29);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 16470, $abort_code);
      goto Abort;
    }

    // if ($t28) goto L4 else goto L5
    if (b#$Boolean($t28)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // abort($t30)
    if (true) { assume $DebugTrackAbort(8, 16352, i#$Integer($t30)); }
    $abort_code := i#$Integer($t30);
    goto Abort;

    // L4:
L4:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $DualAttestation_assert_signature_is_valid_$direct_intra(payer: $Value, payee: $Value, metadata_signature: $Value, metadata: $Value, deposit_value: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, deposit_value))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, deposit_value)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))));
ensures $abort_flag ==> ((b#$Boolean(old($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, deposit_value))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))) ==> b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))) ==> b#$Boolean($Boolean($IsEqual($DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory), old($DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_compliance_public_key), old($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_compliance_public_key)))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_base_url), old($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_base_url)))))))))));

procedure {:inline 1} $DualAttestation_assert_signature_is_valid(payer: $Value, payee: $Value, metadata_signature: $Value, metadata: $Value, deposit_value: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, deposit_value))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, deposit_value)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))));
ensures $abort_flag ==> ((b#$Boolean(old($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, deposit_value))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) &&
       $abort_code == i#$Integer($Integer(5))));

procedure {:inline 1} $DualAttestation_base_url_$def(addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $DualAttestation_Credential_type_value()
    var $t8: $Value; // $Vector_type_value($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(8, 9752, 0, addr); }

    // bytecode translation starts here
    // $t3 := move(addr)
    call $t3 := $CopyOrMoveValue(addr);

    // $t4 := exists<DualAttestation::Credential>($t3)
    $t4 := $ResourceExists($DualAttestation_Credential_$memory, $EmptyTypeValueArray, $t3);

    // $t5 := 0
    $t5 := $Integer(0);

    // $t6 := Errors::not_published($t5)
    call $t6 := $Errors_not_published($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 9870, $abort_code);
      goto Abort;
    }

    // if ($t4) goto L0 else goto L1
    if (b#$Boolean($t4)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t6)
    if (true) { assume $DebugTrackAbort(8, 9829, i#$Integer($t6)); }
    $abort_code := i#$Integer($t6);
    goto Abort;

    // L0:
L0:

    // $t7 := get_global<DualAttestation::Credential>($t3)
    call $t7 := $GetGlobal($DualAttestation_Credential_$memory, $t3, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 9909, $abort_code);
      goto Abort;
    }

    // $t8 := get_field<DualAttestation::Credential>.base_url($t7)
    call $t8 := $GetFieldFromValue($t7, $DualAttestation_Credential_base_url);

    // return $t8
    $ret0 := $t8;
    if (true) { assume $DebugTrackLocal(8, 9907, 9, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $DualAttestation_base_url_$direct_inter(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr), $DualAttestation_Credential_base_url)))));
ensures $Vector_$is_well_formed($ret0) && (forall $$0: int :: {$select_vector($ret0,$$0)} $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0,$$0)));

procedure {:inline 1} $DualAttestation_base_url_$direct_intra(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr), $DualAttestation_Credential_base_url)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))) ==> b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))) ==> b#$Boolean($Boolean($IsEqual($DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory), old($DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_compliance_public_key), old($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_compliance_public_key)))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_base_url), old($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_base_url)))))))))));
ensures $Vector_$is_well_formed($ret0) && (forall $$0: int :: {$select_vector($ret0,$$0)} $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0,$$0)));

procedure {:inline 1} $DualAttestation_base_url(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr), $DualAttestation_Credential_base_url)))));
ensures $Vector_$is_well_formed($ret0) && (forall $$0: int :: {$select_vector($ret0,$$0)} $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0,$$0)));

procedure {:inline 1} $DualAttestation_compliance_public_key_$def(addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $DualAttestation_Credential_type_value()
    var $t8: $Value; // $Vector_type_value($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(8, 10230, 0, addr); }

    // bytecode translation starts here
    // $t3 := move(addr)
    call $t3 := $CopyOrMoveValue(addr);

    // $t4 := exists<DualAttestation::Credential>($t3)
    $t4 := $ResourceExists($DualAttestation_Credential_$memory, $EmptyTypeValueArray, $t3);

    // $t5 := 0
    $t5 := $Integer(0);

    // $t6 := Errors::not_published($t5)
    call $t6 := $Errors_not_published($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 10361, $abort_code);
      goto Abort;
    }

    // if ($t4) goto L0 else goto L1
    if (b#$Boolean($t4)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t6)
    if (true) { assume $DebugTrackAbort(8, 10320, i#$Integer($t6)); }
    $abort_code := i#$Integer($t6);
    goto Abort;

    // L0:
L0:

    // $t7 := get_global<DualAttestation::Credential>($t3)
    call $t7 := $GetGlobal($DualAttestation_Credential_$memory, $t3, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 10400, $abort_code);
      goto Abort;
    }

    // $t8 := get_field<DualAttestation::Credential>.compliance_public_key($t7)
    call $t8 := $GetFieldFromValue($t7, $DualAttestation_Credential_compliance_public_key);

    // return $t8
    $ret0 := $t8;
    if (true) { assume $DebugTrackLocal(8, 10398, 9, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $DualAttestation_compliance_public_key_$direct_inter(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, addr)))));
ensures $Vector_$is_well_formed($ret0) && (forall $$0: int :: {$select_vector($ret0,$$0)} $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0,$$0)));

procedure {:inline 1} $DualAttestation_compliance_public_key_$direct_intra(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, addr)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))) ==> b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))) ==> b#$Boolean($Boolean($IsEqual($DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory), old($DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_compliance_public_key), old($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_compliance_public_key)))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_base_url), old($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_base_url)))))))))));
ensures $Vector_$is_well_formed($ret0) && (forall $$0: int :: {$select_vector($ret0,$$0)} $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0,$$0)));

procedure {:inline 1} $DualAttestation_compliance_public_key(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, addr)))));
ensures $Vector_$is_well_formed($ret0) && (forall $$0: int :: {$select_vector($ret0,$$0)} $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0,$$0)));

procedure {:inline 1} $DualAttestation_credential_address_$def(addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $AddressType()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(8, 11587, 0, addr); }

    // bytecode translation starts here
    // $t2 := move(addr)
    call $t2 := $CopyOrMoveValue(addr);

    // $t3 := VASP::is_child($t2)
    call $t3 := $VASP_is_child($t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 11654, $abort_code);
      goto Abort;
    }

    // if ($t3) goto L0 else goto L1
    if (b#$Boolean($t3)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // tmp#$1 := VASP::parent_address($t2)
    call tmp#$1 := $VASP_parent_address($t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 11676, $abort_code);
      goto Abort;
    }

    // goto L3
    goto L3;

    // L2:
L2:

    // tmp#$1 := $t2
    call tmp#$1 := $CopyOrMoveValue($t2);
    if (true) { assume $DebugTrackLocal(8, 11644, 1, tmp#$1); }

    // goto L3
    goto L3;

    // L3:
L3:

    // return tmp#$1
    $ret0 := tmp#$1;
    if (true) { assume $DebugTrackLocal(8, 11644, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $DualAttestation_credential_address_$direct_intra(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))) ==> b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))) ==> b#$Boolean($Boolean($IsEqual($DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory), old($DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_compliance_public_key), old($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_compliance_public_key)))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_base_url), old($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_base_url)))))))))));
ensures is#$Address($ret0);

procedure {:inline 1} $DualAttestation_credential_address(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr)))));
ensures is#$Address($ret0);

procedure {:inline 1} $DualAttestation_dual_attestation_message_$def(payer: $Value, metadata: $Value, deposit_value: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var message: $Value; // $Vector_type_value($IntegerType())
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $Vector_type_value($IntegerType())
    var $t6: $Value; // $IntegerType()
    var $t7: $Mutation; // ReferenceType($Vector_type_value($IntegerType()))
    var $t8: $Value; // $Vector_type_value($IntegerType())
    var $t9: $Value; // $Vector_type_value($IntegerType())
    var $t10: $Mutation; // ReferenceType($Vector_type_value($IntegerType()))
    var $t11: $Value; // $Vector_type_value($IntegerType())
    var $t12: $Mutation; // ReferenceType($Vector_type_value($IntegerType()))
    var $t13: $Value; // $Vector_type_value($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(8, 14225, 0, payer); }
    if (true) { assume $DebugTrackLocal(8, 14225, 1, metadata); }
    if (true) { assume $DebugTrackLocal(8, 14225, 2, deposit_value); }

    // bytecode translation starts here
    // $t4 := move(payer)
    call $t4 := $CopyOrMoveValue(payer);

    // $t5 := move(metadata)
    call $t5 := $CopyOrMoveValue(metadata);

    // $t6 := move(deposit_value)
    call $t6 := $CopyOrMoveValue(deposit_value);

    // message := $t5
    call message := $CopyOrMoveValue($t5);
    if (true) { assume $DebugTrackLocal(8, 14352, 3, message); }

    // $t7 := borrow_local(message)
    call $t7 := $BorrowLoc(3, message);

    // unpack_ref($t7)

    // $t8 := LCS::to_bytes<address>($t4)
    call $t8 := $LCS_to_bytes($AddressType(), $t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 14414, $abort_code);
      goto Abort;
    }

    // $t9 := read_ref($t7)
    call $t9 := $ReadRef($t7);

    // $t9 := Vector::append<u8>($t9, $t8)
    call $t9 := $Vector_append($IntegerType(), $t9, $t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 14388, $abort_code);
      goto Abort;
    }

    // write_ref($t7, $t9)
    call $t7 := $WriteRef($t7, $t9);

    // pack_ref($t7)

    // write_back[LocalRoot(message)]($t7)
    call message := $WritebackToValue($t7, 3, message);

    // $t10 := borrow_local(message)
    call $t10 := $BorrowLoc(3, message);

    // unpack_ref($t10)

    // $t11 := LCS::to_bytes<u64>($t6)
    call $t11 := $LCS_to_bytes($IntegerType(), $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 14475, $abort_code);
      goto Abort;
    }

    // $t9 := read_ref($t10)
    call $t9 := $ReadRef($t10);

    // $t9 := Vector::append<u8>($t9, $t11)
    call $t9 := $Vector_append($IntegerType(), $t9, $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 14449, $abort_code);
      goto Abort;
    }

    // write_ref($t10, $t9)
    call $t10 := $WriteRef($t10, $t9);

    // pack_ref($t10)

    // write_back[LocalRoot(message)]($t10)
    call message := $WritebackToValue($t10, 3, message);

    // $t12 := borrow_local(message)
    call $t12 := $BorrowLoc(3, message);

    // unpack_ref($t12)

    // $t13 := [64, 64, 36, 36, 76, 73, 66, 82, 65, 95, 65, 84, 84, 69, 83, 84, 36, 36, 64, 64]
    $t13 := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := $Integer(64)][1 := $Integer(64)][2 := $Integer(36)][3 := $Integer(36)][4 := $Integer(76)][5 := $Integer(73)][6 := $Integer(66)][7 := $Integer(82)][8 := $Integer(65)][9 := $Integer(95)][10 := $Integer(65)][11 := $Integer(84)][12 := $Integer(84)][13 := $Integer(69)][14 := $Integer(83)][15 := $Integer(84)][16 := $Integer(36)][17 := $Integer(36)][18 := $Integer(64)][19 := $Integer(64)], 20));

    // $t9 := read_ref($t12)
    call $t9 := $ReadRef($t12);

    // $t9 := Vector::append<u8>($t9, $t13)
    call $t9 := $Vector_append($IntegerType(), $t9, $t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 14518, $abort_code);
      goto Abort;
    }

    // write_ref($t12, $t9)
    call $t12 := $WriteRef($t12, $t9);

    // pack_ref($t12)

    // write_back[LocalRoot(message)]($t12)
    call message := $WritebackToValue($t12, 3, message);

    // return message
    $ret0 := message;
    if (true) { assume $DebugTrackLocal(8, 14566, 14, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $DualAttestation_dual_attestation_message_$direct_intra(payer: $Value, metadata: $Value, deposit_value: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $DualAttestation_spec_dual_attestation_message(payer, metadata, deposit_value)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))) ==> b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))) ==> b#$Boolean($Boolean($IsEqual($DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory), old($DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_compliance_public_key), old($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_compliance_public_key)))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_base_url), old($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_base_url)))))))))));
ensures $Vector_$is_well_formed($ret0) && (forall $$0: int :: {$select_vector($ret0,$$0)} $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0,$$0)));

procedure {:inline 1} $DualAttestation_dual_attestation_message(payer: $Value, metadata: $Value, deposit_value: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $DualAttestation_spec_dual_attestation_message(payer, metadata, deposit_value)))));
ensures $Vector_$is_well_formed($ret0) && (forall $$0: int :: {$select_vector($ret0,$$0)} $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0,$$0)));

procedure {:inline 1} $DualAttestation_dual_attestation_required_$def($tv0: $TypeValue, payer: $Value, payee: $Value, deposit_value: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var above_limit: $Value; // $BooleanType()
    var approx_lbr_microlibra_value: $Value; // $IntegerType()
    var tmp#$5: $Value; // $BooleanType()
    var tmp#$6: $Value; // $BooleanType()
    var travel_rule_limit_microlibra: $Value; // $IntegerType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $BooleanType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(8, 12138, 0, payer); }
    if (true) { assume $DebugTrackLocal(8, 12138, 1, payee); }
    if (true) { assume $DebugTrackLocal(8, 12138, 2, deposit_value); }

    // bytecode translation starts here
    // $t8 := move(payer)
    call $t8 := $CopyOrMoveValue(payer);

    // $t9 := move(payee)
    call $t9 := $CopyOrMoveValue(payee);

    // $t10 := move(deposit_value)
    call $t10 := $CopyOrMoveValue(deposit_value);

    // travel_rule_limit_microlibra := DualAttestation::get_cur_microlibra_limit()
    call travel_rule_limit_microlibra := $DualAttestation_get_cur_microlibra_limit();
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 21025, $abort_code);
      goto Abort;
    }

    // approx_lbr_microlibra_value := Libra::approx_lbr_for_value<#0>($t10)
    call approx_lbr_microlibra_value := $Libra_approx_lbr_for_value($tv0, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 12441, $abort_code);
      goto Abort;
    }

    // above_limit := >=(approx_lbr_microlibra_value, travel_rule_limit_microlibra)
    call above_limit := $Ge(approx_lbr_microlibra_value, travel_rule_limit_microlibra);
    if (true) { assume $DebugTrackLocal(8, 12539, 3, above_limit); }

    // $t11 := !(above_limit)
    call $t11 := $Not(above_limit);

    // if ($t11) goto L0 else goto L1
    if (b#$Boolean($t11)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t12 := false
    $t12 := $Boolean(false);

    // return $t12
    $ret0 := $t12;
    if (true) { assume $DebugTrackLocal(8, 12612, 20, $ret0); }
    return;

    // L2:
L2:

    // $t13 := ==($t8, $t9)
    $t13 := $Boolean($IsEqual($t8, $t9));

    // if ($t13) goto L3 else goto L4
    if (b#$Boolean($t13)) { goto L3; } else { goto L4; }

    // L4:
L4:

    // goto L5
    goto L5;

    // L3:
L3:

    // $t14 := false
    $t14 := $Boolean(false);

    // return $t14
    $ret0 := $t14;
    if (true) { assume $DebugTrackLocal(8, 12734, 20, $ret0); }
    return;

    // L5:
L5:

    // $t15 := VASP::is_vasp($t8)
    call $t15 := $VASP_is_vasp($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 12883, $abort_code);
      goto Abort;
    }

    // if ($t15) goto L6 else goto L7
    if (b#$Boolean($t15)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // goto L8
    goto L8;

    // L6:
L6:

    // tmp#$5 := VASP::is_vasp($t9)
    call tmp#$5 := $VASP_is_vasp($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 12907, $abort_code);
      goto Abort;
    }

    // goto L9
    goto L9;

    // L8:
L8:

    // $t16 := false
    $t16 := $Boolean(false);

    // tmp#$5 := $t16
    call tmp#$5 := $CopyOrMoveValue($t16);
    if (true) { assume $DebugTrackLocal(8, 12877, 5, tmp#$5); }

    // goto L9
    goto L9;

    // L9:
L9:

    // if (tmp#$5) goto L10 else goto L11
    if (b#$Boolean(tmp#$5)) { goto L10; } else { goto L11; }

    // L11:
L11:

    // goto L12
    goto L12;

    // L10:
L10:

    // $t17 := VASP::parent_address($t8)
    call $t17 := $VASP_parent_address($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 12943, $abort_code);
      goto Abort;
    }

    // $t18 := VASP::parent_address($t9)
    call $t18 := $VASP_parent_address($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 12974, $abort_code);
      goto Abort;
    }

    // tmp#$6 := !=($t17, $t18)
    tmp#$6 := $Boolean(!$IsEqual($t17, $t18));
    if (true) { assume $DebugTrackLocal(8, 12965, 6, tmp#$6); }

    // goto L13
    goto L13;

    // L12:
L12:

    // $t19 := false
    $t19 := $Boolean(false);

    // tmp#$6 := $t19
    call tmp#$6 := $CopyOrMoveValue($t19);
    if (true) { assume $DebugTrackLocal(8, 12877, 6, tmp#$6); }

    // goto L13
    goto L13;

    // L13:
L13:

    // return tmp#$6
    $ret0 := tmp#$6;
    if (true) { assume $DebugTrackLocal(8, 12877, 20, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $DualAttestation_dual_attestation_required_$direct_intra($tv0: $TypeValue, payer: $Value, payee: $Value, deposit_value: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(deposit_value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(deposit_value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(deposit_value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, deposit_value)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $DualAttestation_dual_attestation_required($tv0: $TypeValue, payer: $Value, payee: $Value, deposit_value: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(deposit_value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(deposit_value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(deposit_value, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, deposit_value)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $DualAttestation_expiration_date_$def(addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $DualAttestation_Credential_type_value()
    var $t8: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(8, 10922, 0, addr); }

    // bytecode translation starts here
    // $t3 := move(addr)
    call $t3 := $CopyOrMoveValue(addr);

    // $t4 := exists<DualAttestation::Credential>($t3)
    $t4 := $ResourceExists($DualAttestation_Credential_$memory, $EmptyTypeValueArray, $t3);

    // $t5 := 0
    $t5 := $Integer(0);

    // $t6 := Errors::not_published($t5)
    call $t6 := $Errors_not_published($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 11041, $abort_code);
      goto Abort;
    }

    // if ($t4) goto L0 else goto L1
    if (b#$Boolean($t4)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t6)
    if (true) { assume $DebugTrackAbort(8, 11000, i#$Integer($t6)); }
    $abort_code := i#$Integer($t6);
    goto Abort;

    // L0:
L0:

    // $t7 := get_global<DualAttestation::Credential>($t3)
    call $t7 := $GetGlobal($DualAttestation_Credential_$memory, $t3, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 11080, $abort_code);
      goto Abort;
    }

    // $t8 := get_field<DualAttestation::Credential>.expiration_date($t7)
    call $t8 := $GetFieldFromValue($t7, $DualAttestation_Credential_expiration_date);

    // return $t8
    $ret0 := $t8;
    if (true) { assume $DebugTrackLocal(8, 11078, 9, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $DualAttestation_expiration_date_$direct_inter(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr), $DualAttestation_Credential_expiration_date)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $DualAttestation_expiration_date_$direct_intra(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr), $DualAttestation_Credential_expiration_date)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))) ==> b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))) ==> b#$Boolean($Boolean($IsEqual($DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory), old($DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_compliance_public_key), old($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_compliance_public_key)))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_base_url), old($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_base_url)))))))))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $DualAttestation_expiration_date(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr), $DualAttestation_Credential_expiration_date)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $DualAttestation_get_cur_microlibra_limit_$def() returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$0: $Value; // $BooleanType()
    var tmp#$1: $Value; // $IntegerType()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $DualAttestation_Limit_type_value()
    var $t8: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t2 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t2 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t3 := exists<DualAttestation::Limit>($t2)
    $t3 := $ResourceExists($DualAttestation_Limit_$memory, $EmptyTypeValueArray, $t2);

    // $t4 := 1
    $t4 := $Integer(1);

    // $t5 := Errors::not_published($t4)
    call $t5 := $Errors_not_published($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 21149, $abort_code);
      goto Abort;
    }

    // if ($t3) goto L0 else goto L1
    if (b#$Boolean($t3)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t5)
    if (true) { assume $DebugTrackAbort(8, 21082, i#$Integer($t5)); }
    $abort_code := i#$Integer($t5);
    goto Abort;

    // L0:
L0:

    // $t6 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t6 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t7 := get_global<DualAttestation::Limit>($t6)
    call $t7 := $GetGlobal($DualAttestation_Limit_$memory, $t6, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 21181, $abort_code);
      goto Abort;
    }

    // $t8 := get_field<DualAttestation::Limit>.micro_lbr_limit($t7)
    call $t8 := $GetFieldFromValue($t7, $DualAttestation_Limit_micro_lbr_limit);

    // return $t8
    $ret0 := $t8;
    if (true) { assume $DebugTrackLocal(8, 21181, 9, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $DualAttestation_get_cur_microlibra_limit_$direct_inter() returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $DualAttestation_get_cur_microlibra_limit_$direct_intra() returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))) ==> b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))) ==> b#$Boolean($Boolean($IsEqual($DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory), old($DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_compliance_public_key), old($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_compliance_public_key)))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_base_url), old($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_base_url)))))))))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $DualAttestation_get_cur_microlibra_limit() returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory)))));
ensures $IsValidU64($ret0);

procedure {:inline 1} $DualAttestation_human_name_$def(addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $DualAttestation_Credential_type_value()
    var $t8: $Value; // $Vector_type_value($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(8, 9279, 0, addr); }

    // bytecode translation starts here
    // $t3 := move(addr)
    call $t3 := $CopyOrMoveValue(addr);

    // $t4 := exists<DualAttestation::Credential>($t3)
    $t4 := $ResourceExists($DualAttestation_Credential_$memory, $EmptyTypeValueArray, $t3);

    // $t5 := 0
    $t5 := $Integer(0);

    // $t6 := Errors::not_published($t5)
    call $t6 := $Errors_not_published($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 9399, $abort_code);
      goto Abort;
    }

    // if ($t4) goto L0 else goto L1
    if (b#$Boolean($t4)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t6)
    if (true) { assume $DebugTrackAbort(8, 9358, i#$Integer($t6)); }
    $abort_code := i#$Integer($t6);
    goto Abort;

    // L0:
L0:

    // $t7 := get_global<DualAttestation::Credential>($t3)
    call $t7 := $GetGlobal($DualAttestation_Credential_$memory, $t3, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 9438, $abort_code);
      goto Abort;
    }

    // $t8 := get_field<DualAttestation::Credential>.human_name($t7)
    call $t8 := $GetFieldFromValue($t7, $DualAttestation_Credential_human_name);

    // return $t8
    $ret0 := $t8;
    if (true) { assume $DebugTrackLocal(8, 9436, 9, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $DualAttestation_human_name_$direct_inter(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr), $DualAttestation_Credential_human_name)))));
ensures $Vector_$is_well_formed($ret0) && (forall $$0: int :: {$select_vector($ret0,$$0)} $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0,$$0)));

procedure {:inline 1} $DualAttestation_human_name_$direct_intra(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr), $DualAttestation_Credential_human_name)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))) ==> b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))) ==> b#$Boolean($Boolean($IsEqual($DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory), old($DualAttestation_spec_get_cur_microlibra_limit($DualAttestation_Limit_$memory))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_compliance_public_key), old($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_compliance_public_key)))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_base_url), old($SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr1), $DualAttestation_Credential_base_url)))))))))));
ensures $Vector_$is_well_formed($ret0) && (forall $$0: int :: {$select_vector($ret0,$$0)} $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0,$$0)));

procedure {:inline 1} $DualAttestation_human_name(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $SelectField($ResourceValue($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr), $DualAttestation_Credential_human_name)))));
ensures $Vector_$is_well_formed($ret0) && (forall $$0: int :: {$select_vector($ret0,$$0)} $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0,$$0)));

procedure {:inline 1} $DualAttestation_publish_credential_$def(created: $Value, creator: $Value, human_name: $Value) returns ()
{
    // declare local variables
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $Vector_type_value($IntegerType())
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $Vector_type_value($IntegerType())
    var $t14: $Value; // $Vector_type_value($IntegerType())
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $Event_EventHandle_type_value($DualAttestation_ComplianceKeyRotationEvent_type_value())
    var $t17: $Value; // $Event_EventHandle_type_value($DualAttestation_BaseUrlRotationEvent_type_value())
    var $t18: $Value; // $DualAttestation_Credential_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(8, 4223, 0, created); }
    if (true) { assume $DebugTrackLocal(8, 4223, 1, creator); }
    if (true) { assume $DebugTrackLocal(8, 4223, 2, human_name); }

    // bytecode translation starts here
    // $t5 := move(created)
    call $t5 := $CopyOrMoveValue(created);

    // $t6 := move(creator)
    call $t6 := $CopyOrMoveValue(creator);

    // $t7 := move(human_name)
    call $t7 := $CopyOrMoveValue(human_name);

    // Roles::assert_parent_vasp_or_designated_dealer($t5)
    call $Roles_assert_parent_vasp_or_designated_dealer($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 4361, $abort_code);
      goto Abort;
    }

    // Roles::assert_treasury_compliance($t6)
    call $Roles_assert_treasury_compliance($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 4426, $abort_code);
      goto Abort;
    }

    // $t8 := Signer::address_of($t5)
    call $t8 := $Signer_address_of($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 4519, $abort_code);
      goto Abort;
    }

    // $t9 := exists<DualAttestation::Credential>($t8)
    $t9 := $ResourceExists($DualAttestation_Credential_$memory, $EmptyTypeValueArray, $t8);

    // $t10 := !($t9)
    call $t10 := $Not($t9);

    // $t11 := 0
    $t11 := $Integer(0);

    // $t12 := Errors::already_published($t11)
    call $t12 := $Errors_already_published($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 4561, $abort_code);
      goto Abort;
    }

    // if ($t10) goto L0 else goto L1
    if (b#$Boolean($t10)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t5)

    // abort($t12)
    if (true) { assume $DebugTrackAbort(8, 4471, i#$Integer($t12)); }
    $abort_code := i#$Integer($t12);
    goto Abort;

    // L0:
L0:

    // $t13 := Vector::empty<u8>()
    call $t13 := $Vector_empty($IntegerType());
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 4695, $abort_code);
      goto Abort;
    }

    // $t14 := Vector::empty<u8>()
    call $t14 := $Vector_empty($IntegerType());
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 4747, $abort_code);
      goto Abort;
    }

    // $t15 := 18446744073709551615
    $t15 := $Integer(18446744073709551615);

    // $t16 := Event::new_event_handle<DualAttestation::ComplianceKeyRotationEvent>($t5)
    call $t16 := $Event_new_event_handle($DualAttestation_ComplianceKeyRotationEvent_type_value(), $t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 4926, $abort_code);
      goto Abort;
    }

    // $t17 := Event::new_event_handle<DualAttestation::BaseUrlRotationEvent>($t5)
    call $t17 := $Event_new_event_handle($DualAttestation_BaseUrlRotationEvent_type_value(), $t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 5026, $abort_code);
      goto Abort;
    }

    // $t18 := pack DualAttestation::Credential($t7, $t13, $t14, $t15, $t16, $t17)
    call $t18 := $DualAttestation_Credential_pack(0, 0, 0, $t7, $t13, $t14, $t15, $t16, $t17);

    // move_to<DualAttestation::Credential>($t18, $t5)
    call $DualAttestation_Credential_$memory := $MoveTo($DualAttestation_Credential_$memory, $EmptyTypeValueArray, $t18, $t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 4611, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $DualAttestation_publish_credential_$direct_inter(created: $Value, creator: $Value, human_name: $Value) returns ()
{
    assume is#$Address(created);

    assume is#$Address(creator);

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    call $DualAttestation_publish_credential_$def(created, creator, human_name);
}


procedure {:inline 1} $DualAttestation_publish_credential_$direct_intra(created: $Value, creator: $Value, human_name: $Value) returns ()
{
    assume is#$Address(created);

    assume is#$Address(creator);

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    call $DualAttestation_publish_credential_$def(created, creator, human_name);
}


procedure {:inline 1} $DualAttestation_publish_credential(created: $Value, creator: $Value, human_name: $Value) returns ()
{
    assume is#$Address(created);

    assume is#$Address(creator);

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    call $DualAttestation_publish_credential_$def(created, creator, human_name);
}


procedure {:inline 1} $DualAttestation_rotate_base_url_$def(account: $Value, new_url: $Value) returns ()
{
    // declare local variables
    var addr: $Value; // $AddressType()
    var credential: $Mutation; // ReferenceType($DualAttestation_Credential_type_value())
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $Vector_type_value($IntegerType())
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Mutation; // ReferenceType($Vector_type_value($IntegerType()))
    var $t12: $Mutation; // ReferenceType($Event_EventHandle_type_value($DualAttestation_BaseUrlRotationEvent_type_value()))
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $DualAttestation_BaseUrlRotationEvent_type_value()
    var $t15: $Value; // $Event_EventHandle_type_value($DualAttestation_BaseUrlRotationEvent_type_value())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(8, 5670, 0, account); }
    if (true) { assume $DebugTrackLocal(8, 5670, 1, new_url); }

    // bytecode translation starts here
    // $t6 := move(account)
    call $t6 := $CopyOrMoveValue(account);

    // $t7 := move(new_url)
    call $t7 := $CopyOrMoveValue(new_url);

    // addr := Signer::address_of($t6)
    call addr := $Signer_address_of($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 5785, $abort_code);
      goto Abort;
    }

    // $t8 := exists<DualAttestation::Credential>(addr)
    $t8 := $ResourceExists($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr);

    // $t9 := 0
    $t9 := $Integer(0);

    // $t10 := Errors::not_published($t9)
    call $t10 := $Errors_not_published($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 5855, $abort_code);
      goto Abort;
    }

    // if ($t8) goto L0 else goto L1
    if (b#$Boolean($t8)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t10)
    if (true) { assume $DebugTrackAbort(8, 5814, i#$Integer($t10)); }
    $abort_code := i#$Integer($t10);
    goto Abort;

    // L0:
L0:

    // credential := borrow_global<DualAttestation::Credential>(addr)
    call credential := $BorrowGlobal($DualAttestation_Credential_$memory, addr, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 5909, $abort_code);
      goto Abort;
    }

    // unpack_ref(credential)

    // $t11 := borrow_field<DualAttestation::Credential>.base_url(credential)
    call $t11 := $BorrowField(credential, $DualAttestation_Credential_base_url);

    // unpack_ref($t11)

    // write_ref($t11, $t7)
    call $t11 := $WriteRef($t11, $t7);
    if (true) { assume $DebugTrackLocal(8, 5954, 3, $Dereference(credential)); }

    // pack_ref($t11)

    // write_back[Reference(credential)]($t11)
    call credential := $WritebackToReference($t11, credential);

    // $t12 := borrow_field<DualAttestation::Credential>.base_url_rotation_events(credential)
    call $t12 := $BorrowField(credential, $DualAttestation_Credential_base_url_rotation_events);

    // unpack_ref($t12)

    // $t13 := LibraTimestamp::now_seconds()
    call $t13 := $LibraTimestamp_now_seconds();
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 6166, $abort_code);
      goto Abort;
    }

    // $t14 := pack DualAttestation::BaseUrlRotationEvent($t7, $t13)
    call $t14 := $DualAttestation_BaseUrlRotationEvent_pack(0, 0, 0, $t7, $t13);

    // $t15 := read_ref($t12)
    call $t15 := $ReadRef($t12);
    assert $Event_EventHandle_$invariant_holds($t15);

    // $t15 := Event::emit_event<DualAttestation::BaseUrlRotationEvent>($t15, $t14)
    call $t15 := $Event_emit_event($DualAttestation_BaseUrlRotationEvent_type_value(), $t15, $t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 6005, $abort_code);
      goto Abort;
    }

    // write_ref($t12, $t15)
    call $t12 := $WriteRef($t12, $t15);
    if (true) { assume $DebugTrackLocal(8, 6005, 3, $Dereference(credential)); }

    // pack_ref($t12)

    // write_back[Reference(credential)]($t12)
    call credential := $WritebackToReference($t12, credential);

    // pack_ref(credential)

    // write_back[DualAttestation::Credential](credential)
    call $DualAttestation_Credential_$memory := $WritebackToGlobal($DualAttestation_Credential_$memory, credential);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $DualAttestation_rotate_base_url_$direct_inter(account: $Value, new_url: $Value) returns ()
{
    assume is#$Address(account);

    assume $Vector_$is_well_formed(new_url) && (forall $$0: int :: {$select_vector(new_url,$$0)} $$0 >= 0 && $$0 < $vlen(new_url) ==> $IsValidU8($select_vector(new_url,$$0)));

    call $DualAttestation_rotate_base_url_$def(account, new_url);
}


procedure {:inline 1} $DualAttestation_rotate_base_url_$direct_intra(account: $Value, new_url: $Value) returns ()
{
    assume is#$Address(account);

    assume $Vector_$is_well_formed(new_url) && (forall $$0: int :: {$select_vector(new_url,$$0)} $$0 >= 0 && $$0 < $vlen(new_url) ==> $IsValidU8($select_vector(new_url,$$0)));

    call $DualAttestation_rotate_base_url_$def(account, new_url);
}


procedure {:inline 1} $DualAttestation_rotate_base_url(account: $Value, new_url: $Value) returns ()
{
    assume is#$Address(account);

    assume $Vector_$is_well_formed(new_url) && (forall $$0: int :: {$select_vector(new_url,$$0)} $$0 >= 0 && $$0 < $vlen(new_url) ==> $IsValidU8($select_vector(new_url,$$0)));

    call $DualAttestation_rotate_base_url_$def(account, new_url);
}


procedure {:inline 1} $DualAttestation_rotate_compliance_public_key_$def(account: $Value, new_key: $Value) returns ()
{
    // declare local variables
    var addr: $Value; // $AddressType()
    var credential: $Mutation; // ReferenceType($DualAttestation_Credential_type_value())
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var tmp#$6: $Value; // $BooleanType()
    var tmp#$7: $Value; // $IntegerType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $Vector_type_value($IntegerType())
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Mutation; // ReferenceType($Vector_type_value($IntegerType()))
    var $t17: $Mutation; // ReferenceType($Event_EventHandle_type_value($DualAttestation_ComplianceKeyRotationEvent_type_value()))
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $DualAttestation_ComplianceKeyRotationEvent_type_value()
    var $t20: $Value; // $Event_EventHandle_type_value($DualAttestation_ComplianceKeyRotationEvent_type_value())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(8, 7306, 0, account); }
    if (true) { assume $DebugTrackLocal(8, 7306, 1, new_key); }

    // bytecode translation starts here
    // $t8 := move(account)
    call $t8 := $CopyOrMoveValue(account);

    // $t9 := move(new_key)
    call $t9 := $CopyOrMoveValue(new_key);

    // addr := Signer::address_of($t8)
    call addr := $Signer_address_of($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 7457, $abort_code);
      goto Abort;
    }

    // $t10 := exists<DualAttestation::Credential>(addr)
    $t10 := $ResourceExists($DualAttestation_Credential_$memory, $EmptyTypeValueArray, addr);

    // $t11 := 0
    $t11 := $Integer(0);

    // $t12 := Errors::not_published($t11)
    call $t12 := $Errors_not_published($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 7527, $abort_code);
      goto Abort;
    }

    // if ($t10) goto L0 else goto L1
    if (b#$Boolean($t10)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t12)
    if (true) { assume $DebugTrackAbort(8, 7486, i#$Integer($t12)); }
    $abort_code := i#$Integer($t12);
    goto Abort;

    // L0:
L0:

    // $t13 := Signature::ed25519_validate_pubkey($t9)
    call $t13 := $Signature_ed25519_validate_pubkey($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 7582, $abort_code);
      goto Abort;
    }

    // $t14 := 2
    $t14 := $Integer(2);

    // $t15 := Errors::invalid_argument($t14)
    call $t15 := $Errors_invalid_argument($t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 7629, $abort_code);
      goto Abort;
    }

    // if ($t13) goto L2 else goto L3
    if (b#$Boolean($t13)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t15)
    if (true) { assume $DebugTrackAbort(8, 7564, i#$Integer($t15)); }
    $abort_code := i#$Integer($t15);
    goto Abort;

    // L2:
L2:

    // credential := borrow_global<DualAttestation::Credential>(addr)
    call credential := $BorrowGlobal($DualAttestation_Credential_$memory, addr, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 7694, $abort_code);
      goto Abort;
    }

    // unpack_ref(credential)

    // $t16 := borrow_field<DualAttestation::Credential>.compliance_public_key(credential)
    call $t16 := $BorrowField(credential, $DualAttestation_Credential_compliance_public_key);

    // unpack_ref($t16)

    // write_ref($t16, $t9)
    call $t16 := $WriteRef($t16, $t9);
    if (true) { assume $DebugTrackLocal(8, 7739, 3, $Dereference(credential)); }

    // pack_ref($t16)

    // write_back[Reference(credential)]($t16)
    call credential := $WritebackToReference($t16, credential);

    // $t17 := borrow_field<DualAttestation::Credential>.compliance_key_rotation_events(credential)
    call $t17 := $BorrowField(credential, $DualAttestation_Credential_compliance_key_rotation_events);

    // unpack_ref($t17)

    // $t18 := LibraTimestamp::now_seconds()
    call $t18 := $LibraTimestamp_now_seconds();
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 7989, $abort_code);
      goto Abort;
    }

    // $t19 := pack DualAttestation::ComplianceKeyRotationEvent($t9, $t18)
    call $t19 := $DualAttestation_ComplianceKeyRotationEvent_pack(0, 0, 0, $t9, $t18);

    // $t20 := read_ref($t17)
    call $t20 := $ReadRef($t17);
    assert $Event_EventHandle_$invariant_holds($t20);

    // $t20 := Event::emit_event<DualAttestation::ComplianceKeyRotationEvent>($t20, $t19)
    call $t20 := $Event_emit_event($DualAttestation_ComplianceKeyRotationEvent_type_value(), $t20, $t19);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 7803, $abort_code);
      goto Abort;
    }

    // write_ref($t17, $t20)
    call $t17 := $WriteRef($t17, $t20);
    if (true) { assume $DebugTrackLocal(8, 7803, 3, $Dereference(credential)); }

    // pack_ref($t17)

    // write_back[Reference(credential)]($t17)
    call credential := $WritebackToReference($t17, credential);

    // pack_ref(credential)

    // write_back[DualAttestation::Credential](credential)
    call $DualAttestation_Credential_$memory := $WritebackToGlobal($DualAttestation_Credential_$memory, credential);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $DualAttestation_rotate_compliance_public_key_$direct_inter(account: $Value, new_key: $Value) returns ()
{
    assume is#$Address(account);

    assume $Vector_$is_well_formed(new_key) && (forall $$0: int :: {$select_vector(new_key,$$0)} $$0 >= 0 && $$0 < $vlen(new_key) ==> $IsValidU8($select_vector(new_key,$$0)));

    call $DualAttestation_rotate_compliance_public_key_$def(account, new_key);
}


procedure {:inline 1} $DualAttestation_rotate_compliance_public_key_$direct_intra(account: $Value, new_key: $Value) returns ()
{
    assume is#$Address(account);

    assume $Vector_$is_well_formed(new_key) && (forall $$0: int :: {$select_vector(new_key,$$0)} $$0 >= 0 && $$0 < $vlen(new_key) ==> $IsValidU8($select_vector(new_key,$$0)));

    call $DualAttestation_rotate_compliance_public_key_$def(account, new_key);
}


procedure {:inline 1} $DualAttestation_rotate_compliance_public_key(account: $Value, new_key: $Value) returns ()
{
    assume is#$Address(account);

    assume $Vector_$is_well_formed(new_key) && (forall $$0: int :: {$select_vector(new_key,$$0)} $$0 >= 0 && $$0 < $vlen(new_key) ==> $IsValidU8($select_vector(new_key,$$0)));

    call $DualAttestation_rotate_compliance_public_key_$def(account, new_key);
}


procedure {:inline 1} $DualAttestation_set_microlibra_limit_$def(tc_account: $Value, micro_lbr_limit: $Value) returns ()
{
    // declare local variables
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Mutation; // ReferenceType($DualAttestation_Limit_type_value())
    var $t12: $Mutation; // ReferenceType($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(8, 21597, 0, tc_account); }
    if (true) { assume $DebugTrackLocal(8, 21597, 1, micro_lbr_limit); }

    // bytecode translation starts here
    // $t4 := move(tc_account)
    call $t4 := $CopyOrMoveValue(tc_account);

    // $t5 := move(micro_lbr_limit)
    call $t5 := $CopyOrMoveValue(micro_lbr_limit);

    // Roles::assert_treasury_compliance($t4)
    call $Roles_assert_treasury_compliance($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 21704, $abort_code);
      goto Abort;
    }

    // $t6 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t6 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t7 := exists<DualAttestation::Limit>($t6)
    $t7 := $ResourceExists($DualAttestation_Limit_$memory, $EmptyTypeValueArray, $t6);

    // $t8 := 1
    $t8 := $Integer(1);

    // $t9 := Errors::not_published($t8)
    call $t9 := $Errors_not_published($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 21819, $abort_code);
      goto Abort;
    }

    // if ($t7) goto L0 else goto L1
    if (b#$Boolean($t7)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t9)
    if (true) { assume $DebugTrackAbort(8, 21752, i#$Integer($t9)); }
    $abort_code := i#$Integer($t9);
    goto Abort;

    // L0:
L0:

    // $t10 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t10 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t11 := borrow_global<DualAttestation::Limit>($t10)
    call $t11 := $BorrowGlobal($DualAttestation_Limit_$memory, $t10, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 21851, $abort_code);
      goto Abort;
    }

    // unpack_ref($t11)

    // $t12 := borrow_field<DualAttestation::Limit>.micro_lbr_limit($t11)
    call $t12 := $BorrowField($t11, $DualAttestation_Limit_micro_lbr_limit);

    // unpack_ref($t12)

    // write_ref($t12, $t5)
    call $t12 := $WriteRef($t12, $t5);

    // pack_ref($t12)

    // write_back[Reference($t11)]($t12)
    call $t11 := $WritebackToReference($t12, $t11);

    // pack_ref($t11)

    // write_back[DualAttestation::Limit]($t11)
    call $DualAttestation_Limit_$memory := $WritebackToGlobal($DualAttestation_Limit_$memory, $t11);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $DualAttestation_set_microlibra_limit_$direct_inter(tc_account: $Value, micro_lbr_limit: $Value) returns ()
{
    assume is#$Address(tc_account);

    assume $IsValidU64(micro_lbr_limit);

    call $DualAttestation_set_microlibra_limit_$def(tc_account, micro_lbr_limit);
}


procedure {:inline 1} $DualAttestation_set_microlibra_limit_$direct_intra(tc_account: $Value, micro_lbr_limit: $Value) returns ()
{
    assume is#$Address(tc_account);

    assume $IsValidU64(micro_lbr_limit);

    call $DualAttestation_set_microlibra_limit_$def(tc_account, micro_lbr_limit);
}


procedure {:inline 1} $DualAttestation_set_microlibra_limit(tc_account: $Value, micro_lbr_limit: $Value) returns ()
{
    assume is#$Address(tc_account);

    assume $IsValidU64(micro_lbr_limit);

    call $DualAttestation_set_microlibra_limit_$def(tc_account, micro_lbr_limit);
}




// ** spec vars of module ValidatorOperatorConfig



// ** spec funs of module ValidatorOperatorConfig

function {:inline} $ValidatorOperatorConfig_$get_human_name($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory: $Memory, validator_operator_addr: $Value): $Value {
    $SelectField($ResourceValue($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, $EmptyTypeValueArray, validator_operator_addr), $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name)
}

function {:inline} $ValidatorOperatorConfig_$has_validator_operator_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory: $Memory, validator_operator_addr: $Value): $Value {
    $ResourceExists($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, $EmptyTypeValueArray, validator_operator_addr)
}



// ** structs of module ValidatorOperatorConfig

const unique $ValidatorOperatorConfig_ValidatorOperatorConfig: $TypeName;
const $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name: $FieldName;
axiom $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name == 0;
function $ValidatorOperatorConfig_ValidatorOperatorConfig_type_value(): $TypeValue {
    $StructType($ValidatorOperatorConfig_ValidatorOperatorConfig, $EmptyTypeValueArray)
}
var $ValidatorOperatorConfig_ValidatorOperatorConfig_$memory: $Memory;
var $ValidatorOperatorConfig_ValidatorOperatorConfig_$memory_$old: $Memory;
function {:inline} $ValidatorOperatorConfig_ValidatorOperatorConfig_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && $Vector_$is_well_formed($SelectField($this, $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name)) && (forall $$0: int :: {$select_vector($SelectField($this, $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name),$$0)))
}
function {:inline} $ValidatorOperatorConfig_ValidatorOperatorConfig_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $ValidatorOperatorConfig_ValidatorOperatorConfig_$is_well_formed($this: $Value): bool {
    $ValidatorOperatorConfig_ValidatorOperatorConfig_$is_well_typed($this) && $ValidatorOperatorConfig_ValidatorOperatorConfig_$invariant_holds($this)}

procedure {:inline 1} $ValidatorOperatorConfig_ValidatorOperatorConfig_pack($file_id: int, $byte_index: int, $var_idx: int, human_name: $Value) returns ($struct: $Value)
{
    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := human_name], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $ValidatorOperatorConfig_ValidatorOperatorConfig_unpack($struct: $Value) returns (human_name: $Value)
{
    assume is#$Vector($struct);
    human_name := $SelectField($struct, $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name);
    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));
}



// ** functions of module ValidatorOperatorConfig

procedure {:inline 1} $ValidatorOperatorConfig_get_human_name_$def(validator_operator_addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $ValidatorOperatorConfig_ValidatorOperatorConfig_type_value()
    var $t8: $Value; // $Vector_type_value($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 1945, 0, validator_operator_addr); }

    // bytecode translation starts here
    // $t3 := move(validator_operator_addr)
    call $t3 := $CopyOrMoveValue(validator_operator_addr);

    // $t4 := ValidatorOperatorConfig::has_validator_operator_config($t3)
    call $t4 := $ValidatorOperatorConfig_has_validator_operator_config($t3);
    if ($abort_flag) {
      goto Abort;
    }

    // $t5 := 0
    $t5 := $Integer(0);

    // $t6 := Errors::not_published($t5)
    call $t6 := $Errors_not_published($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 2131, $abort_code);
      goto Abort;
    }

    // if ($t4) goto L0 else goto L1
    if (b#$Boolean($t4)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t6)
    if (true) { assume $DebugTrackAbort(29, 2060, i#$Integer($t6)); }
    $abort_code := i#$Integer($t6);
    goto Abort;

    // L0:
L0:

    // $t7 := get_global<ValidatorOperatorConfig::ValidatorOperatorConfig>($t3)
    call $t7 := $GetGlobal($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, $t3, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 2185, $abort_code);
      goto Abort;
    }

    // $t8 := get_field<ValidatorOperatorConfig::ValidatorOperatorConfig>.human_name($t7)
    call $t8 := $GetFieldFromValue($t7, $ValidatorOperatorConfig_ValidatorOperatorConfig_human_name);

    // return $t8
    $ret0 := $t8;
    if (true) { assume $DebugTrackLocal(29, 2183, 9, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $ValidatorOperatorConfig_get_human_name_$direct_inter(validator_operator_addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorOperatorConfig_$has_validator_operator_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, validator_operator_addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ValidatorOperatorConfig_$has_validator_operator_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, validator_operator_addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ValidatorOperatorConfig_$has_validator_operator_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, validator_operator_addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $ValidatorOperatorConfig_$get_human_name($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, validator_operator_addr)))));
ensures $Vector_$is_well_formed($ret0) && (forall $$0: int :: {$select_vector($ret0,$$0)} $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0,$$0)));

procedure {:inline 1} $ValidatorOperatorConfig_get_human_name_$direct_intra(validator_operator_addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorOperatorConfig_$has_validator_operator_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, validator_operator_addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ValidatorOperatorConfig_$has_validator_operator_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, validator_operator_addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ValidatorOperatorConfig_$has_validator_operator_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, validator_operator_addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $ValidatorOperatorConfig_$get_human_name($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, validator_operator_addr)))));
ensures $Vector_$is_well_formed($ret0) && (forall $$0: int :: {$select_vector($ret0,$$0)} $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0,$$0)));

procedure {:inline 1} $ValidatorOperatorConfig_get_human_name(validator_operator_addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorOperatorConfig_$has_validator_operator_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, validator_operator_addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ValidatorOperatorConfig_$has_validator_operator_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, validator_operator_addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ValidatorOperatorConfig_$has_validator_operator_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, validator_operator_addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $ValidatorOperatorConfig_$get_human_name($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, validator_operator_addr)))));
ensures $Vector_$is_well_formed($ret0) && (forall $$0: int :: {$select_vector($ret0,$$0)} $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0,$$0)));

procedure {:inline 1} $ValidatorOperatorConfig_has_validator_operator_config_$def(validator_operator_addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 2498, 0, validator_operator_addr); }

    // bytecode translation starts here
    // $t1 := move(validator_operator_addr)
    call $t1 := $CopyOrMoveValue(validator_operator_addr);

    // $t2 := exists<ValidatorOperatorConfig::ValidatorOperatorConfig>($t1)
    $t2 := $ResourceExists($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, $EmptyTypeValueArray, $t1);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(29, 2589, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $ValidatorOperatorConfig_has_validator_operator_config_$direct_inter(validator_operator_addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(validator_operator_addr);

    call $ret0 := $ValidatorOperatorConfig_has_validator_operator_config_$def(validator_operator_addr);
}


procedure {:inline 1} $ValidatorOperatorConfig_has_validator_operator_config_$direct_intra(validator_operator_addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(validator_operator_addr);

    call $ret0 := $ValidatorOperatorConfig_has_validator_operator_config_$def(validator_operator_addr);
}


procedure {:inline 1} $ValidatorOperatorConfig_has_validator_operator_config(validator_operator_addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(validator_operator_addr);

    call $ret0 := $ValidatorOperatorConfig_has_validator_operator_config_$def(validator_operator_addr);
}


procedure {:inline 1} $ValidatorOperatorConfig_publish_$def(validator_operator_account: $Value, lr_account: $Value, human_name: $Value) returns ()
{
    // declare local variables
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $Vector_type_value($IntegerType())
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $ValidatorOperatorConfig_ValidatorOperatorConfig_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 408, 0, validator_operator_account); }
    if (true) { assume $DebugTrackLocal(29, 408, 1, lr_account); }
    if (true) { assume $DebugTrackLocal(29, 408, 2, human_name); }

    // bytecode translation starts here
    // $t5 := move(validator_operator_account)
    call $t5 := $CopyOrMoveValue(validator_operator_account);

    // $t6 := move(lr_account)
    call $t6 := $CopyOrMoveValue(lr_account);

    // $t7 := move(human_name)
    call $t7 := $CopyOrMoveValue(human_name);

    // LibraTimestamp::assert_operating()
    call $LibraTimestamp_assert_operating();
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 566, $abort_code);
      goto Abort;
    }

    // Roles::assert_libra_root($t6)
    call $Roles_assert_libra_root($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 601, $abort_code);
      goto Abort;
    }

    // Roles::assert_validator_operator($t5)
    call $Roles_assert_validator_operator($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 647, $abort_code);
      goto Abort;
    }

    // $t8 := Signer::address_of($t5)
    call $t8 := $Signer_address_of($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 769, $abort_code);
      goto Abort;
    }

    // $t9 := ValidatorOperatorConfig::has_validator_operator_config($t8)
    call $t9 := $ValidatorOperatorConfig_has_validator_operator_config($t8);
    if ($abort_flag) {
      goto Abort;
    }

    // $t10 := !($t9)
    call $t10 := $Not($t9);

    // $t11 := 0
    $t11 := $Integer(0);

    // $t12 := Errors::already_published($t11)
    call $t12 := $Errors_already_published($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 830, $abort_code);
      goto Abort;
    }

    // if ($t10) goto L0 else goto L1
    if (b#$Boolean($t10)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t5)

    // abort($t12)
    if (true) { assume $DebugTrackAbort(29, 710, i#$Integer($t12)); }
    $abort_code := i#$Integer($t12);
    goto Abort;

    // L0:
L0:

    // $t13 := pack ValidatorOperatorConfig::ValidatorOperatorConfig($t7)
    call $t13 := $ValidatorOperatorConfig_ValidatorOperatorConfig_pack(0, 0, 0, $t7);

    // move_to<ValidatorOperatorConfig::ValidatorOperatorConfig>($t13, $t5)
    call $ValidatorOperatorConfig_ValidatorOperatorConfig_$memory := $MoveTo($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, $EmptyTypeValueArray, $t13, $t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 896, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $ValidatorOperatorConfig_publish_$direct_inter(validator_operator_account: $Value, lr_account: $Value, human_name: $Value) returns ()
{
    assume is#$Address(validator_operator_account);

    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    call $ValidatorOperatorConfig_publish_$def(validator_operator_account, lr_account, human_name);
}


procedure {:inline 1} $ValidatorOperatorConfig_publish_$direct_intra(validator_operator_account: $Value, lr_account: $Value, human_name: $Value) returns ()
{
    assume is#$Address(validator_operator_account);

    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    call $ValidatorOperatorConfig_publish_$def(validator_operator_account, lr_account, human_name);
}


procedure {:inline 1} $ValidatorOperatorConfig_publish(validator_operator_account: $Value, lr_account: $Value, human_name: $Value) returns ()
{
    assume is#$Address(validator_operator_account);

    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    call $ValidatorOperatorConfig_publish_$def(validator_operator_account, lr_account, human_name);
}




// ** spec vars of module Option



// ** spec funs of module Option

function {:inline} $Option_$borrow($tv0: $TypeValue, t: $Value): $Value {
    $Vector_$borrow($tv0, $SelectField(t, $Option_Option_vec), $Integer(0))
}

function {:inline} $Option_$is_none($tv0: $TypeValue, t: $Value): $Value {
    $Vector_$is_empty($tv0, $SelectField(t, $Option_Option_vec))
}

function {:inline} $Option_$is_some($tv0: $TypeValue, t: $Value): $Value {
    $Boolean(!b#$Boolean($Vector_$is_empty($tv0, $SelectField(t, $Option_Option_vec))))
}

function {:inline} $Option_spec_none($tv0: $TypeValue): $Value {
    $Vector($ExtendValueArray($EmptyValueArray(), $mk_vector()))
}

function {:inline} $Option_spec_some($tv0: $TypeValue, e: $Value): $Value {
    $Vector($ExtendValueArray($EmptyValueArray(), $Vector_spec_singleton($tv0, e)))
}

function {:inline} $Option_spec_is_none($tv0: $TypeValue, t: $Value): $Value {
    $Boolean($IsEqual($vlen_value($SelectField(t, $Option_Option_vec)), $Integer(0)))
}

function {:inline} $Option_spec_is_some($tv0: $TypeValue, t: $Value): $Value {
    $Boolean(!b#$Boolean($Option_spec_is_none($tv0, t)))
}

function {:inline} $Option_spec_contains($tv0: $TypeValue, t: $Value, e: $Value): $Value {
    $Boolean(b#$Boolean($Option_spec_is_some($tv0, t)) && b#$Boolean($Boolean($IsEqual($Option_spec_get($tv0, t), e))))
}

function {:inline} $Option_spec_get($tv0: $TypeValue, t: $Value): $Value {
    $select_vector_by_value($SelectField(t, $Option_Option_vec), $Integer(0))
}



// ** structs of module Option

const unique $Option_Option: $TypeName;
const $Option_Option_vec: $FieldName;
axiom $Option_Option_vec == 0;
function $Option_Option_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($Option_Option, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1))
}
var $Option_Option_$memory: $Memory;
var $Option_Option_$memory_$old: $Memory;
function {:inline} $Option_Option_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && $Vector_$is_well_formed($SelectField($this, $Option_Option_vec))
}
function {:inline} $Option_Option_$invariant_holds($this: $Value): bool {
    b#$Boolean($Boolean(i#$Integer($vlen_value($SelectField($this, $Option_Option_vec))) <= i#$Integer($Integer(1))))
}

function {:inline} $Option_Option_$is_well_formed($this: $Value): bool {
    $Option_Option_$is_well_typed($this) && $Option_Option_$invariant_holds($this)}

procedure {:inline 1} $Option_Option_$unpack_ref_deep($tv0: $TypeValue, $before: $Value) {
    assume $Option_Option_$invariant_holds($before);
}

procedure {:inline 1} $Option_Option_$unpack_ref($tv0: $TypeValue, $before: $Value) {
    assume $Option_Option_$invariant_holds($before);
}

procedure {:inline 1} $Option_Option_$pack_ref_deep($tv0: $TypeValue, $after: $Value) {
    assert b#$Boolean($Boolean(i#$Integer($vlen_value($SelectField($after, $Option_Option_vec))) <= i#$Integer($Integer(1))));
}

procedure {:inline 1} $Option_Option_$pack_ref($tv0: $TypeValue, $after: $Value) {
    assert b#$Boolean($Boolean(i#$Integer($vlen_value($SelectField($after, $Option_Option_vec))) <= i#$Integer($Integer(1))));
}

procedure {:inline 1} $Option_Option_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, vec: $Value) returns ($struct: $Value)
{
    assume $Vector_$is_well_formed(vec);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := vec], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
    assert b#$Boolean($Boolean(i#$Integer($vlen_value($SelectField($struct, $Option_Option_vec))) <= i#$Integer($Integer(1))));
}

procedure {:inline 1} $Option_Option_unpack($tv0: $TypeValue, $struct: $Value) returns (vec: $Value)
{
    assume is#$Vector($struct);
    vec := $SelectField($struct, $Option_Option_vec);
    assume $Vector_$is_well_formed(vec);
}



// ** functions of module Option

procedure {:inline 1} $Option_borrow_$def($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $Option_Option_type_value($tv0)
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $Vector_type_value($tv0)
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $tv0

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(20, 2941, 0, t); }

    // bytecode translation starts here
    // $t3 := move(t)
    call $t3 := $CopyOrMoveValue(t);

    // $t4 := Option::is_some<#0>($t3)
    call $t4 := $Option_is_some($tv0, $t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 2023, $abort_code);
      goto Abort;
    }

    // $t5 := 1
    $t5 := $Integer(1);

    // $t6 := Errors::invalid_argument($t5)
    call $t6 := $Errors_invalid_argument($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 3036, $abort_code);
      goto Abort;
    }

    // if ($t4) goto L0 else goto L1
    if (b#$Boolean($t4)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t3)

    // abort($t6)
    if (true) { assume $DebugTrackAbort(20, 3009, i#$Integer($t6)); }
    $abort_code := i#$Integer($t6);
    goto Abort;

    // L0:
L0:

    // $t7 := get_field<Option::Option<#0>>.vec($t3)
    call $t7 := $GetFieldFromValue($t3, $Option_Option_vec);

    // $t8 := 0
    $t8 := $Integer(0);

    // $t9 := Vector::borrow<#0>($t7, $t8)
    call $t9 := $Vector_borrow($tv0, $t7, $t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 3088, $abort_code);
      goto Abort;
    }

    // return $t9
    $ret0 := $t9;
    if (true) { assume $DebugTrackLocal(20, 3080, 10, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Option_borrow_$direct_inter($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, t)))));

procedure {:inline 1} $Option_borrow_$direct_intra($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, t)))));

procedure {:inline 1} $Option_borrow($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, t)))));

procedure {:inline 1} $Option_borrow_mut_$def($tv0: $TypeValue, t: $Value) returns ($ret0: $Mutation, $ret1: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $Option_Option_type_value($tv0)
    var $t4: $Mutation; // ReferenceType($Option_Option_type_value($tv0))
    var $t5: $Value; // $Option_Option_type_value($tv0)
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Mutation; // ReferenceType($Vector_type_value($tv0))
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $Vector_type_value($tv0)
    var $t12: $Mutation; // ReferenceType($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(20, 5615, 0, t); }

    // bytecode translation starts here
    // $t3 := move(t)
    call $t3 := $CopyOrMoveValue(t);

    // $t4 := borrow_local($t3)
    call $t4 := $BorrowLoc(3, $t3);

    // $t5 := read_ref($t4)
    call $t5 := $ReadRef($t4);
    assert $Option_Option_$invariant_holds($t5);

    // $t6 := Option::is_some<#0>($t5)
    call $t6 := $Option_is_some($tv0, $t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 2023, $abort_code);
      goto Abort;
    }

    // $t7 := 1
    $t7 := $Integer(1);

    // $t8 := Errors::invalid_argument($t7)
    call $t8 := $Errors_invalid_argument($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 5722, $abort_code);
      goto Abort;
    }

    // if ($t6) goto L0 else goto L1
    if (b#$Boolean($t6)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t4)

    // abort($t8)
    if (true) { assume $DebugTrackAbort(20, 5695, i#$Integer($t8)); }
    $abort_code := i#$Integer($t8);
    goto Abort;

    // L0:
L0:

    // $t9 := borrow_field<Option::Option<#0>>.vec($t4)
    call $t9 := $BorrowField($t4, $Option_Option_vec);

    // $t10 := 0
    $t10 := $Integer(0);

    // $t11 := read_ref($t9)
    call $t11 := $ReadRef($t9);

    // ($t12, $t11) := Vector::borrow_mut<#0>($t11, $t10)
    call $t12, $t11 := $Vector_borrow_mut($tv0, $t11, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 5774, $abort_code);
      goto Abort;
    }

    // write_ref($t9, $t11)
    call $t9 := $WriteRef($t9, $t11);

    // splice[0 -> $t9]($t12)
    call $t12 := $Splice1(0, $t9, $t12);

    // write_back[Reference($t4)]($t9)
    call $t4 := $WritebackToReference($t9, $t4);

    // write_back[LocalRoot($t3)]($t4)
    call $t3 := $WritebackToValue($t4, 3, $t3);

    // return ($t12, $t3)
    $ret0 := $t12;
    if (true) { assume $DebugTrackLocal(20, 5766, 13, $Dereference($ret0)); }
    $ret1 := $t3;
    if (true) { assume $DebugTrackLocal(20, 5766, 14, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultMutation;
    $ret1 := $DefaultValue();
}

procedure {:inline 1} $Option_borrow_mut_$direct_inter($tv0: $TypeValue, t: $Value) returns ($ret0: $Mutation, $ret1: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Dereference($ret0), $Option_spec_get($tv0, $ret1)))));
ensures $Option_Option_$is_well_formed($ret1);

procedure {:inline 1} $Option_borrow_mut_$direct_intra($tv0: $TypeValue, t: $Value) returns ($ret0: $Mutation, $ret1: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Dereference($ret0), $Option_spec_get($tv0, $ret1)))));
ensures $Option_Option_$is_well_formed($ret1);

procedure {:inline 1} $Option_borrow_mut($tv0: $TypeValue, t: $Value) returns ($ret0: $Mutation, $ret1: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Dereference($ret0), $Option_spec_get($tv0, $ret1)))));
ensures $Option_Option_$is_well_formed($ret1);

procedure {:inline 1} $Option_contains_$def($tv0: $TypeValue, t: $Value, e_ref: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t2: $Value; // $Option_Option_type_value($tv0)
    var $t3: $Value; // $tv0
    var $t4: $Value; // $Vector_type_value($tv0)
    var $t5: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(20, 2451, 0, t); }
    if (true) { assume $DebugTrackLocal(20, 2451, 1, e_ref); }

    // bytecode translation starts here
    // $t2 := move(t)
    call $t2 := $CopyOrMoveValue(t);

    // $t3 := move(e_ref)
    call $t3 := $CopyOrMoveValue(e_ref);

    // $t4 := get_field<Option::Option<#0>>.vec($t2)
    call $t4 := $GetFieldFromValue($t2, $Option_Option_vec);

    // $t5 := Vector::contains<#0>($t4, $t3)
    call $t5 := $Vector_contains($tv0, $t4, $t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 2542, $abort_code);
      goto Abort;
    }

    // return $t5
    $ret0 := $t5;
    if (true) { assume $DebugTrackLocal(20, 2534, 6, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Option_contains_$direct_inter($tv0: $TypeValue, t: $Value, e_ref: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_contains($tv0, t, e_ref)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $Option_contains_$direct_intra($tv0: $TypeValue, t: $Value, e_ref: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_contains($tv0, t, e_ref)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $Option_contains($tv0: $TypeValue, t: $Value, e_ref: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_contains($tv0, t, e_ref)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $Option_swap_$def($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    // declare local variables
    var old_value: $Value; // $tv0
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var vec_ref: $Mutation; // ReferenceType($Vector_type_value($tv0))
    var $t6: $Value; // $Option_Option_type_value($tv0)
    var $t7: $Value; // $tv0
    var $t8: $Mutation; // ReferenceType($Option_Option_type_value($tv0))
    var $t9: $Value; // $Option_Option_type_value($tv0)
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $Vector_type_value($tv0)
    var $t14: $Value; // $tv0

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(20, 6060, 0, t); }
    if (true) { assume $DebugTrackLocal(20, 6060, 1, e); }

    // bytecode translation starts here
    // $t6 := move(t)
    call $t6 := $CopyOrMoveValue(t);

    // $t7 := move(e)
    call $t7 := $CopyOrMoveValue(e);

    // $t8 := borrow_local($t6)
    call $t8 := $BorrowLoc(6, $t6);

    // unpack_ref($t8)
    call $Option_Option_$unpack_ref($tv0, $Dereference($t8));

    // $t9 := read_ref($t8)
    call $t9 := $ReadRef($t8);
    assert $Option_Option_$invariant_holds($t9);

    // $t10 := Option::is_some<#0>($t9)
    call $t10 := $Option_is_some($tv0, $t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 2023, $abort_code);
      goto Abort;
    }

    // $t11 := 1
    $t11 := $Integer(1);

    // $t12 := Errors::invalid_argument($t11)
    call $t12 := $Errors_invalid_argument($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 6168, $abort_code);
      goto Abort;
    }

    // if ($t10) goto L0 else goto L1
    if (b#$Boolean($t10)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t8)

    // pack_ref($t8)
    call $Option_Option_$pack_ref($tv0, $Dereference($t8));

    // abort($t12)
    if (true) { assume $DebugTrackAbort(20, 6141, i#$Integer($t12)); }
    $abort_code := i#$Integer($t12);
    goto Abort;

    // L0:
L0:

    // vec_ref := borrow_field<Option::Option<#0>>.vec($t8)
    call vec_ref := $BorrowField($t8, $Option_Option_vec);

    // unpack_ref(vec_ref)

    // $t13 := read_ref(vec_ref)
    call $t13 := $ReadRef(vec_ref);

    // ($t14, $t13) := Vector::pop_back<#0>($t13)
    call $t14, $t13 := $Vector_pop_back($tv0, $t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 6270, $abort_code);
      goto Abort;
    }

    // write_ref(vec_ref, $t13)
    call vec_ref := $WriteRef(vec_ref, $t13);
    if (true) { assume $DebugTrackLocal(20, 6270, 5, $Dereference(vec_ref)); }

    // old_value := $t14
    call old_value := $CopyOrMoveValue($t14);
    if (true) { assume $DebugTrackLocal(20, 6250, 2, old_value); }

    // $t13 := read_ref(vec_ref)
    call $t13 := $ReadRef(vec_ref);

    // $t13 := Vector::push_back<#0>($t13, $t7)
    call $t13 := $Vector_push_back($tv0, $t13, $t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 6305, $abort_code);
      goto Abort;
    }

    // write_ref(vec_ref, $t13)
    call vec_ref := $WriteRef(vec_ref, $t13);
    if (true) { assume $DebugTrackLocal(20, 6305, 5, $Dereference(vec_ref)); }

    // pack_ref(vec_ref)

    // write_back[Reference($t8)](vec_ref)
    call $t8 := $WritebackToReference(vec_ref, $t8);

    // pack_ref($t8)
    call $Option_Option_$pack_ref($tv0, $Dereference($t8));

    // write_back[LocalRoot($t6)]($t8)
    call $t6 := $WritebackToValue($t8, 6, $t6);

    // return (old_value, $t6)
    $ret0 := old_value;
    if (true) { assume $DebugTrackLocal(20, 6336, 15, $ret0); }
    $ret1 := $t6;
    if (true) { assume $DebugTrackLocal(20, 6336, 16, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}

procedure {:inline 1} $Option_swap_$direct_inter($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value, $ret1: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t))))));
ensures !$abort_flag ==> (b#$Boolean($Option_spec_is_some($tv0, $ret1)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Option_spec_get($tv0, $ret1), e))));
ensures $Option_Option_$is_well_formed($ret1);

procedure {:inline 1} $Option_swap_$direct_intra($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value, $ret1: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t))))));
ensures !$abort_flag ==> (b#$Boolean($Option_spec_is_some($tv0, $ret1)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Option_spec_get($tv0, $ret1), e))));
ensures $Option_Option_$is_well_formed($ret1);

procedure {:inline 1} $Option_swap($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value, $ret1: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t))))));
ensures !$abort_flag ==> (b#$Boolean($Option_spec_is_some($tv0, $ret1)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Option_spec_get($tv0, $ret1), e))));
ensures $Option_Option_$is_well_formed($ret1);

procedure {:inline 1} $Option_borrow_with_default_$def($tv0: $TypeValue, t: $Value, default_ref: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$2: $Value; // $tv0
    var vec_ref: $Value; // $Vector_type_value($tv0)
    var $t4: $Value; // $Option_Option_type_value($tv0)
    var $t5: $Value; // $tv0
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(20, 3599, 0, t); }
    if (true) { assume $DebugTrackLocal(20, 3599, 1, default_ref); }

    // bytecode translation starts here
    // $t4 := move(t)
    call $t4 := $CopyOrMoveValue(t);

    // $t5 := move(default_ref)
    call $t5 := $CopyOrMoveValue(default_ref);

    // vec_ref := get_field<Option::Option<#0>>.vec($t4)
    call vec_ref := $GetFieldFromValue($t4, $Option_Option_vec);
    if (true) { assume $DebugTrackLocal(20, 3717, 3, vec_ref); }

    // $t6 := Vector::is_empty<#0>(vec_ref)
    call $t6 := $Vector_is_empty($tv0, vec_ref);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 3745, $abort_code);
      goto Abort;
    }

    // if ($t6) goto L0 else goto L1
    if (b#$Boolean($t6)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // destroy(vec_ref)

    // tmp#$2 := $t5
    call tmp#$2 := $CopyOrMoveValue($t5);
    if (true) { assume $DebugTrackLocal(20, 3733, 2, tmp#$2); }

    // goto L3
    goto L3;

    // L2:
L2:

    // destroy($t5)

    // $t7 := 0
    $t7 := $Integer(0);

    // tmp#$2 := Vector::borrow<#0>(vec_ref, $t7)
    call tmp#$2 := $Vector_borrow($tv0, vec_ref, $t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 3797, $abort_code);
      goto Abort;
    }

    // goto L3
    goto L3;

    // L3:
L3:

    // return tmp#$2
    $ret0 := tmp#$2;
    if (true) { assume $DebugTrackLocal(20, 3733, 8, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Option_borrow_with_default_$direct_inter($tv0: $TypeValue, t: $Value, default_ref: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, if (b#$Boolean($Option_spec_is_some($tv0, t))) then ($Option_spec_get($tv0, t)) else (default_ref)))));

procedure {:inline 1} $Option_borrow_with_default_$direct_intra($tv0: $TypeValue, t: $Value, default_ref: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, if (b#$Boolean($Option_spec_is_some($tv0, t))) then ($Option_spec_get($tv0, t)) else (default_ref)))));

procedure {:inline 1} $Option_borrow_with_default($tv0: $TypeValue, t: $Value, default_ref: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, if (b#$Boolean($Option_spec_is_some($tv0, t))) then ($Option_spec_get($tv0, t)) else (default_ref)))));

procedure {:inline 1} $Option_destroy_none_$def($tv0: $TypeValue, t: $Value) returns ()
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var vec: $Value; // $Vector_type_value($tv0)
    var $t4: $Value; // $Option_Option_type_value($tv0)
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(20, 7603, 0, t); }

    // bytecode translation starts here
    // $t4 := move(t)
    call $t4 := $CopyOrMoveValue(t);

    // $t5 := Option::is_none<#0>($t4)
    call $t5 := $Option_is_none($tv0, $t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 1665, $abort_code);
      goto Abort;
    }

    // $t6 := 0
    $t6 := $Integer(0);

    // $t7 := Errors::invalid_argument($t6)
    call $t7 := $Errors_invalid_argument($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 7694, $abort_code);
      goto Abort;
    }

    // if ($t5) goto L0 else goto L1
    if (b#$Boolean($t5)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t7)
    if (true) { assume $DebugTrackAbort(20, 7666, i#$Integer($t7)); }
    $abort_code := i#$Integer($t7);
    goto Abort;

    // L0:
L0:

    // vec := unpack Option::Option<#0>($t4)
    call vec := $Option_Option_unpack($tv0, $t4);
    if (true) { assume $DebugTrackLocal(20, 7741, 3, vec); }

    // Vector::destroy_empty<#0>(vec)
    call $Vector_destroy_empty($tv0, vec);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 7777, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $Option_destroy_none_$direct_inter($tv0: $TypeValue, t: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Option_spec_is_some($tv0, t))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Option_spec_is_some($tv0, t))));
ensures $abort_flag ==> ((b#$Boolean(old($Option_spec_is_some($tv0, t))) &&
       $abort_code == i#$Integer($Integer(7))));

procedure {:inline 1} $Option_destroy_none_$direct_intra($tv0: $TypeValue, t: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Option_spec_is_some($tv0, t))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Option_spec_is_some($tv0, t))));
ensures $abort_flag ==> ((b#$Boolean(old($Option_spec_is_some($tv0, t))) &&
       $abort_code == i#$Integer($Integer(7))));

procedure {:inline 1} $Option_destroy_none($tv0: $TypeValue, t: $Value) returns ()
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Option_spec_is_some($tv0, t))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Option_spec_is_some($tv0, t))));
ensures $abort_flag ==> ((b#$Boolean(old($Option_spec_is_some($tv0, t))) &&
       $abort_code == i#$Integer($Integer(7))));

procedure {:inline 1} $Option_destroy_some_$def($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var elem: $Value; // $tv0
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var vec: $Value; // $Vector_type_value($tv0)
    var $t5: $Value; // $Option_Option_type_value($tv0)
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Mutation; // ReferenceType($Vector_type_value($tv0))
    var $t10: $Value; // $Vector_type_value($tv0)
    var $t11: $Value; // $tv0

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(20, 7132, 0, t); }

    // bytecode translation starts here
    // $t5 := move(t)
    call $t5 := $CopyOrMoveValue(t);

    // $t6 := Option::is_some<#0>($t5)
    call $t6 := $Option_is_some($tv0, $t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 2023, $abort_code);
      goto Abort;
    }

    // $t7 := 1
    $t7 := $Integer(1);

    // $t8 := Errors::invalid_argument($t7)
    call $t8 := $Errors_invalid_argument($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 7232, $abort_code);
      goto Abort;
    }

    // if ($t6) goto L0 else goto L1
    if (b#$Boolean($t6)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t8)
    if (true) { assume $DebugTrackAbort(20, 7204, i#$Integer($t8)); }
    $abort_code := i#$Integer($t8);
    goto Abort;

    // L0:
L0:

    // vec := unpack Option::Option<#0>($t5)
    call vec := $Option_Option_unpack($tv0, $t5);
    if (true) { assume $DebugTrackLocal(20, 7280, 4, vec); }

    // $t9 := borrow_local(vec)
    call $t9 := $BorrowLoc(4, vec);

    // unpack_ref($t9)

    // $t10 := read_ref($t9)
    call $t10 := $ReadRef($t9);

    // ($t11, $t10) := Vector::pop_back<#0>($t10)
    call $t11, $t10 := $Vector_pop_back($tv0, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 7327, $abort_code);
      goto Abort;
    }

    // write_ref($t9, $t10)
    call $t9 := $WriteRef($t9, $t10);

    // pack_ref($t9)

    // write_back[LocalRoot(vec)]($t9)
    call vec := $WritebackToValue($t9, 4, vec);

    // elem := $t11
    call elem := $CopyOrMoveValue($t11);
    if (true) { assume $DebugTrackLocal(20, 7312, 1, elem); }

    // Vector::destroy_empty<#0>(vec)
    call $Vector_destroy_empty($tv0, vec);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 7363, $abort_code);
      goto Abort;
    }

    // return elem
    $ret0 := elem;
    if (true) { assume $DebugTrackLocal(20, 7391, 12, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Option_destroy_some_$direct_inter($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t))))));

procedure {:inline 1} $Option_destroy_some_$direct_intra($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t))))));

procedure {:inline 1} $Option_destroy_some($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t))))));

procedure {:inline 1} $Option_destroy_with_default_$def($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$2: $Value; // $tv0
    var vec: $Value; // $Vector_type_value($tv0)
    var $t4: $Value; // $Option_Option_type_value($tv0)
    var $t5: $Value; // $tv0
    var $t6: $Mutation; // ReferenceType($Vector_type_value($tv0))
    var $t7: $Value; // $Vector_type_value($tv0)
    var $t8: $Value; // $BooleanType()
    var $t9: $Mutation; // ReferenceType($Vector_type_value($tv0))
    var $t10: $Value; // $Vector_type_value($tv0)
    var $t11: $Value; // $tv0

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(20, 6639, 0, t); }
    if (true) { assume $DebugTrackLocal(20, 6639, 1, default); }

    // bytecode translation starts here
    // $t4 := move(t)
    call $t4 := $CopyOrMoveValue(t);

    // $t5 := move(default)
    call $t5 := $CopyOrMoveValue(default);

    // vec := unpack Option::Option<#0>($t4)
    call vec := $Option_Option_unpack($tv0, $t4);
    if (true) { assume $DebugTrackLocal(20, 6751, 3, vec); }

    // $t6 := borrow_local(vec)
    call $t6 := $BorrowLoc(3, vec);

    // unpack_ref($t6)

    // $t7 := read_ref($t6)
    call $t7 := $ReadRef($t6);

    // pack_ref($t6)

    // $t8 := Vector::is_empty<#0>($t7)
    call $t8 := $Vector_is_empty($tv0, $t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 6791, $abort_code);
      goto Abort;
    }

    // if ($t8) goto L0 else goto L1
    if (b#$Boolean($t8)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // tmp#$2 := $t5
    call tmp#$2 := $CopyOrMoveValue($t5);
    if (true) { assume $DebugTrackLocal(20, 6779, 2, tmp#$2); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t9 := borrow_local(vec)
    call $t9 := $BorrowLoc(3, vec);

    // unpack_ref($t9)

    // $t10 := read_ref($t9)
    call $t10 := $ReadRef($t9);

    // ($t11, $t10) := Vector::pop_back<#0>($t10)
    call $t11, $t10 := $Vector_pop_back($tv0, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 6840, $abort_code);
      goto Abort;
    }

    // write_ref($t9, $t10)
    call $t9 := $WriteRef($t9, $t10);

    // pack_ref($t9)

    // write_back[LocalRoot(vec)]($t9)
    call vec := $WritebackToValue($t9, 3, vec);

    // tmp#$2 := $t11
    call tmp#$2 := $CopyOrMoveValue($t11);
    if (true) { assume $DebugTrackLocal(20, 6779, 2, tmp#$2); }

    // goto L3
    goto L3;

    // L3:
L3:

    // return tmp#$2
    $ret0 := tmp#$2;
    if (true) { assume $DebugTrackLocal(20, 6779, 12, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Option_destroy_with_default_$direct_inter($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, if (b#$Boolean($Option_spec_is_some($tv0, old(t)))) then ($Option_spec_get($tv0, old(t))) else (default)))));

procedure {:inline 1} $Option_destroy_with_default_$direct_intra($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, if (b#$Boolean($Option_spec_is_some($tv0, old(t)))) then ($Option_spec_get($tv0, old(t))) else (default)))));

procedure {:inline 1} $Option_destroy_with_default($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, if (b#$Boolean($Option_spec_is_some($tv0, old(t)))) then ($Option_spec_get($tv0, old(t))) else (default)))));

procedure {:inline 1} $Option_extract_$def($tv0: $TypeValue, t: $Value) returns ($ret0: $Value, $ret1: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $Option_Option_type_value($tv0)
    var $t4: $Mutation; // ReferenceType($Option_Option_type_value($tv0))
    var $t5: $Value; // $Option_Option_type_value($tv0)
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Mutation; // ReferenceType($Vector_type_value($tv0))
    var $t10: $Value; // $Vector_type_value($tv0)
    var $t11: $Value; // $tv0

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(20, 5161, 0, t); }

    // bytecode translation starts here
    // $t3 := move(t)
    call $t3 := $CopyOrMoveValue(t);

    // $t4 := borrow_local($t3)
    call $t4 := $BorrowLoc(3, $t3);

    // unpack_ref($t4)
    call $Option_Option_$unpack_ref($tv0, $Dereference($t4));

    // $t5 := read_ref($t4)
    call $t5 := $ReadRef($t4);
    assert $Option_Option_$invariant_holds($t5);

    // $t6 := Option::is_some<#0>($t5)
    call $t6 := $Option_is_some($tv0, $t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 2023, $abort_code);
      goto Abort;
    }

    // $t7 := 1
    $t7 := $Integer(1);

    // $t8 := Errors::invalid_argument($t7)
    call $t8 := $Errors_invalid_argument($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 5260, $abort_code);
      goto Abort;
    }

    // if ($t6) goto L0 else goto L1
    if (b#$Boolean($t6)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t4)

    // pack_ref($t4)
    call $Option_Option_$pack_ref($tv0, $Dereference($t4));

    // abort($t8)
    if (true) { assume $DebugTrackAbort(20, 5233, i#$Integer($t8)); }
    $abort_code := i#$Integer($t8);
    goto Abort;

    // L0:
L0:

    // $t9 := borrow_field<Option::Option<#0>>.vec($t4)
    call $t9 := $BorrowField($t4, $Option_Option_vec);

    // unpack_ref($t9)

    // $t10 := read_ref($t9)
    call $t10 := $ReadRef($t9);

    // ($t11, $t10) := Vector::pop_back<#0>($t10)
    call $t11, $t10 := $Vector_pop_back($tv0, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 5312, $abort_code);
      goto Abort;
    }

    // write_ref($t9, $t10)
    call $t9 := $WriteRef($t9, $t10);

    // pack_ref($t9)

    // write_back[Reference($t4)]($t9)
    call $t4 := $WritebackToReference($t9, $t4);

    // pack_ref($t4)
    call $Option_Option_$pack_ref($tv0, $Dereference($t4));

    // write_back[LocalRoot($t3)]($t4)
    call $t3 := $WritebackToValue($t4, 3, $t3);

    // return ($t11, $t3)
    $ret0 := $t11;
    if (true) { assume $DebugTrackLocal(20, 5304, 12, $ret0); }
    $ret1 := $t3;
    if (true) { assume $DebugTrackLocal(20, 5304, 13, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}

procedure {:inline 1} $Option_extract_$direct_inter($tv0: $TypeValue, t: $Value) returns ($ret0: $Value, $ret1: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t))))));
ensures !$abort_flag ==> (b#$Boolean($Option_spec_is_none($tv0, $ret1)));
ensures $Option_Option_$is_well_formed($ret1);

procedure {:inline 1} $Option_extract_$direct_intra($tv0: $TypeValue, t: $Value) returns ($ret0: $Value, $ret1: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t))))));
ensures !$abort_flag ==> (b#$Boolean($Option_spec_is_none($tv0, $ret1)));
ensures $Option_Option_$is_well_formed($ret1);

procedure {:inline 1} $Option_extract($tv0: $TypeValue, t: $Value) returns ($ret0: $Value, $ret1: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($Option_spec_is_some($tv0, t))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_get($tv0, old(t))))));
ensures !$abort_flag ==> (b#$Boolean($Option_spec_is_none($tv0, $ret1)));
ensures $Option_Option_$is_well_formed($ret1);

procedure {:inline 1} $Option_fill_$def($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var vec_ref: $Mutation; // ReferenceType($Vector_type_value($tv0))
    var $t3: $Value; // $Option_Option_type_value($tv0)
    var $t4: $Value; // $tv0
    var $t5: $Mutation; // ReferenceType($Option_Option_type_value($tv0))
    var $t6: $Value; // $Vector_type_value($tv0)
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $Vector_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(20, 4600, 0, t); }
    if (true) { assume $DebugTrackLocal(20, 4600, 1, e); }

    // bytecode translation starts here
    // $t3 := move(t)
    call $t3 := $CopyOrMoveValue(t);

    // $t4 := move(e)
    call $t4 := $CopyOrMoveValue(e);

    // $t5 := borrow_local($t3)
    call $t5 := $BorrowLoc(3, $t3);

    // unpack_ref($t5)
    call $Option_Option_$unpack_ref($tv0, $Dereference($t5));

    // vec_ref := borrow_field<Option::Option<#0>>.vec($t5)
    call vec_ref := $BorrowField($t5, $Option_Option_vec);

    // unpack_ref(vec_ref)

    // $t6 := read_ref(vec_ref)
    call $t6 := $ReadRef(vec_ref);

    // $t7 := Vector::is_empty<#0>($t6)
    call $t7 := $Vector_is_empty($tv0, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 4718, $abort_code);
      goto Abort;
    }

    // if ($t7) goto L0 else goto L1
    if (b#$Boolean($t7)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy(vec_ref)

    // pack_ref(vec_ref)

    // pack_ref($t5)
    call $Option_Option_$pack_ref($tv0, $Dereference($t5));

    // $t8 := 0
    $t8 := $Integer(0);

    // $t9 := Errors::invalid_argument($t8)
    call $t9 := $Errors_invalid_argument($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 4794, $abort_code);
      goto Abort;
    }

    // abort($t9)
    if (true) { assume $DebugTrackAbort(20, 4780, i#$Integer($t9)); }
    $abort_code := i#$Integer($t9);
    goto Abort;

    // L0:
L0:

    // $t10 := read_ref(vec_ref)
    call $t10 := $ReadRef(vec_ref);

    // $t10 := Vector::push_back<#0>($t10, $t4)
    call $t10 := $Vector_push_back($tv0, $t10, $t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 4745, $abort_code);
      goto Abort;
    }

    // write_ref(vec_ref, $t10)
    call vec_ref := $WriteRef(vec_ref, $t10);
    if (true) { assume $DebugTrackLocal(20, 4745, 2, $Dereference(vec_ref)); }

    // pack_ref(vec_ref)

    // write_back[Reference($t5)](vec_ref)
    call $t5 := $WritebackToReference(vec_ref, $t5);

    // pack_ref($t5)
    call $Option_Option_$pack_ref($tv0, $Dereference($t5));

    // write_back[LocalRoot($t3)]($t5)
    call $t3 := $WritebackToValue($t5, 3, $t3);

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(20, 4706, 11, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Option_fill_$direct_inter($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Option_spec_is_some($tv0, t))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Option_spec_is_some($tv0, t))));
ensures $abort_flag ==> ((b#$Boolean(old($Option_spec_is_some($tv0, t))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Option_spec_is_some($tv0, $ret0)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Option_spec_get($tv0, $ret0), e))));
ensures $Option_Option_$is_well_formed($ret0);

procedure {:inline 1} $Option_fill_$direct_intra($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Option_spec_is_some($tv0, t))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Option_spec_is_some($tv0, t))));
ensures $abort_flag ==> ((b#$Boolean(old($Option_spec_is_some($tv0, t))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Option_spec_is_some($tv0, $ret0)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Option_spec_get($tv0, $ret0), e))));
ensures $Option_Option_$is_well_formed($ret0);

procedure {:inline 1} $Option_fill($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Option_spec_is_some($tv0, t))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Option_spec_is_some($tv0, t))));
ensures $abort_flag ==> ((b#$Boolean(old($Option_spec_is_some($tv0, t))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Option_spec_is_some($tv0, $ret0)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Option_spec_get($tv0, $ret0), e))));
ensures $Option_Option_$is_well_formed($ret0);

procedure {:inline 1} $Option_get_with_default_$def($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$2: $Value; // $tv0
    var vec_ref: $Value; // $Vector_type_value($tv0)
    var $t4: $Value; // $Option_Option_type_value($tv0)
    var $t5: $Value; // $tv0
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $tv0

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(20, 4101, 0, t); }
    if (true) { assume $DebugTrackLocal(20, 4101, 1, default); }

    // bytecode translation starts here
    // $t4 := move(t)
    call $t4 := $CopyOrMoveValue(t);

    // $t5 := move(default)
    call $t5 := $CopyOrMoveValue(default);

    // vec_ref := get_field<Option::Option<#0>>.vec($t4)
    call vec_ref := $GetFieldFromValue($t4, $Option_Option_vec);
    if (true) { assume $DebugTrackLocal(20, 4220, 3, vec_ref); }

    // $t6 := Vector::is_empty<#0>(vec_ref)
    call $t6 := $Vector_is_empty($tv0, vec_ref);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 4248, $abort_code);
      goto Abort;
    }

    // if ($t6) goto L0 else goto L1
    if (b#$Boolean($t6)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // destroy(vec_ref)

    // tmp#$2 := $t5
    call tmp#$2 := $CopyOrMoveValue($t5);
    if (true) { assume $DebugTrackLocal(20, 4236, 2, tmp#$2); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t7 := 0
    $t7 := $Integer(0);

    // $t8 := Vector::borrow<#0>(vec_ref, $t7)
    call $t8 := $Vector_borrow($tv0, vec_ref, $t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 4297, $abort_code);
      goto Abort;
    }

    // tmp#$2 := $t8
    call tmp#$2 := $CopyOrMoveValue($t8);
    if (true) { assume $DebugTrackLocal(20, 4236, 2, tmp#$2); }

    // goto L3
    goto L3;

    // L3:
L3:

    // return tmp#$2
    $ret0 := tmp#$2;
    if (true) { assume $DebugTrackLocal(20, 4236, 9, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Option_get_with_default_$direct_inter($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, if (b#$Boolean($Option_spec_is_some($tv0, t))) then ($Option_spec_get($tv0, t)) else (default)))));

procedure {:inline 1} $Option_get_with_default_$direct_intra($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, if (b#$Boolean($Option_spec_is_some($tv0, t))) then ($Option_spec_get($tv0, t)) else (default)))));

procedure {:inline 1} $Option_get_with_default($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, if (b#$Boolean($Option_spec_is_some($tv0, t))) then ($Option_spec_get($tv0, t)) else (default)))));

procedure {:inline 1} $Option_is_none_$def($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $Option_Option_type_value($tv0)
    var $t2: $Value; // $Vector_type_value($tv0)
    var $t3: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(20, 1654, 0, t); }

    // bytecode translation starts here
    // $t1 := move(t)
    call $t1 := $CopyOrMoveValue(t);

    // $t2 := get_field<Option::Option<#0>>.vec($t1)
    call $t2 := $GetFieldFromValue($t1, $Option_Option_vec);

    // $t3 := Vector::is_empty<#0>($t2)
    call $t3 := $Vector_is_empty($tv0, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 1727, $abort_code);
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(20, 1719, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Option_is_none_$direct_inter($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_is_none($tv0, t)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $Option_is_none_$direct_intra($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_is_none($tv0, t)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $Option_is_none($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_is_none($tv0, t)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $Option_is_some_$def($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $Option_Option_type_value($tv0)
    var $t2: $Value; // $Vector_type_value($tv0)
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(20, 2012, 0, t); }

    // bytecode translation starts here
    // $t1 := move(t)
    call $t1 := $CopyOrMoveValue(t);

    // $t2 := get_field<Option::Option<#0>>.vec($t1)
    call $t2 := $GetFieldFromValue($t1, $Option_Option_vec);

    // $t3 := Vector::is_empty<#0>($t2)
    call $t3 := $Vector_is_empty($tv0, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 2086, $abort_code);
      goto Abort;
    }

    // $t4 := !($t3)
    call $t4 := $Not($t3);

    // return $t4
    $ret0 := $t4;
    if (true) { assume $DebugTrackLocal(20, 2077, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Option_is_some_$direct_inter($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_is_some($tv0, t)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $Option_is_some_$direct_intra($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_is_some($tv0, t)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $Option_is_some($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_is_some($tv0, t)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $Option_none_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $Vector_type_value($tv0)
    var $t1: $Value; // $Option_Option_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := Vector::empty<#0>()
    call $t0 := $Vector_empty($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 973, $abort_code);
      goto Abort;
    }

    // $t1 := pack Option::Option<#0>($t0)
    call $t1 := $Option_Option_pack(0, 0, 0, $tv0, $t0);

    // return $t1
    $ret0 := $t1;
    if (true) { assume $DebugTrackLocal(20, 951, 2, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Option_none_$direct_inter($tv0: $TypeValue) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_none($tv0)))));
ensures $Option_Option_$is_well_formed($ret0);

procedure {:inline 1} $Option_none_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_none($tv0)))));
ensures $Option_Option_$is_well_formed($ret0);

procedure {:inline 1} $Option_none($tv0: $TypeValue) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_none($tv0)))));
ensures $Option_Option_$is_well_formed($ret0);

procedure {:inline 1} $Option_some_$def($tv0: $TypeValue, e: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $tv0
    var $t2: $Value; // $Vector_type_value($tv0)
    var $t3: $Value; // $Option_Option_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(20, 1258, 0, e); }

    // bytecode translation starts here
    // $t1 := move(e)
    call $t1 := $CopyOrMoveValue(e);

    // $t2 := Vector::singleton<#0>($t1)
    call $t2 := $Vector_singleton($tv0, $t1);
    if ($abort_flag) {
      goto Abort;
    }

    // $t3 := pack Option::Option<#0>($t2)
    call $t3 := $Option_Option_pack(0, 0, 0, $tv0, $t2);

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(20, 1322, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $Option_some_$direct_inter($tv0: $TypeValue, e: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_some($tv0, e)))));
ensures $Option_Option_$is_well_formed($ret0);

procedure {:inline 1} $Option_some_$direct_intra($tv0: $TypeValue, e: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_some($tv0, e)))));
ensures $Option_Option_$is_well_formed($ret0);

procedure {:inline 1} $Option_some($tv0: $TypeValue, e: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_some($tv0, e)))));
ensures $Option_Option_$is_well_formed($ret0);



// ** spec vars of module ValidatorConfig



// ** spec funs of module ValidatorConfig

function {:inline} $ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory: $Memory, addr: $Value): $Value {
    $ResourceExists($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr)
}

function {:inline} $ValidatorConfig_$is_valid($ValidatorConfig_ValidatorConfig_$memory: $Memory, addr: $Value): $Value {
    $Boolean(b#$Boolean($ResourceExists($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr)) && b#$Boolean($Option_$is_some($ValidatorConfig_Config_type_value(), $SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr), $ValidatorConfig_ValidatorConfig_config))))
}

function {:inline} $ValidatorConfig_spec_has_operator($ValidatorConfig_ValidatorConfig_$memory: $Memory, addr: $Value): $Value {
    $Option_$is_some($AddressType(), $SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr), $ValidatorConfig_ValidatorConfig_operator_account))
}

function {:inline} $ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory: $Memory, addr: $Value): $Value {
    if (b#$Boolean($ValidatorConfig_spec_has_operator($ValidatorConfig_ValidatorConfig_$memory, addr))) then ($Option_$borrow($AddressType(), $SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr), $ValidatorConfig_ValidatorConfig_operator_account))) else (addr)
}

function {:inline} $ValidatorConfig_spec_get_human_name($ValidatorConfig_ValidatorConfig_$memory: $Memory, addr: $Value): $Value {
    $SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr), $ValidatorConfig_ValidatorConfig_human_name)
}

function {:inline} $ValidatorConfig_spec_get_config($ValidatorConfig_ValidatorConfig_$memory: $Memory, addr: $Value): $Value {
    $Option_$borrow($ValidatorConfig_Config_type_value(), $SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr), $ValidatorConfig_ValidatorConfig_config))
}

function {:inline} $ValidatorConfig_validator_addr$15(validator_account: $Value): $Value {
    $Signer_spec_address_of(validator_account)
}

function {:inline} $ValidatorConfig_validator_addr$16(validator_account: $Value): $Value {
    $Signer_spec_address_of(validator_account)
}

function {:inline} $ValidatorConfig_sender$17(validator_account: $Value): $Value {
    $Signer_spec_address_of(validator_account)
}

function {:inline} $ValidatorConfig_sender$18(validator_account: $Value): $Value {
    $Signer_spec_address_of(validator_account)
}



// ** structs of module ValidatorConfig

const unique $ValidatorConfig_Config: $TypeName;
const $ValidatorConfig_Config_consensus_pubkey: $FieldName;
axiom $ValidatorConfig_Config_consensus_pubkey == 0;
const $ValidatorConfig_Config_validator_network_addresses: $FieldName;
axiom $ValidatorConfig_Config_validator_network_addresses == 1;
const $ValidatorConfig_Config_fullnode_network_addresses: $FieldName;
axiom $ValidatorConfig_Config_fullnode_network_addresses == 2;
function $ValidatorConfig_Config_type_value(): $TypeValue {
    $StructType($ValidatorConfig_Config, $EmptyTypeValueArray)
}
var $ValidatorConfig_Config_$memory: $Memory;
var $ValidatorConfig_Config_$memory_$old: $Memory;
function {:inline} $ValidatorConfig_Config_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 3
      && $Vector_$is_well_formed($SelectField($this, $ValidatorConfig_Config_consensus_pubkey)) && (forall $$0: int :: {$select_vector($SelectField($this, $ValidatorConfig_Config_consensus_pubkey),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_consensus_pubkey)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_consensus_pubkey),$$0)))
      && $Vector_$is_well_formed($SelectField($this, $ValidatorConfig_Config_validator_network_addresses)) && (forall $$0: int :: {$select_vector($SelectField($this, $ValidatorConfig_Config_validator_network_addresses),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_validator_network_addresses)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_validator_network_addresses),$$0)))
      && $Vector_$is_well_formed($SelectField($this, $ValidatorConfig_Config_fullnode_network_addresses)) && (forall $$0: int :: {$select_vector($SelectField($this, $ValidatorConfig_Config_fullnode_network_addresses),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_fullnode_network_addresses)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_fullnode_network_addresses),$$0)))
}
function {:inline} $ValidatorConfig_Config_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $ValidatorConfig_Config_$is_well_formed($this: $Value): bool {
    $ValidatorConfig_Config_$is_well_typed($this) && $ValidatorConfig_Config_$invariant_holds($this)}

procedure {:inline 1} $ValidatorConfig_Config_pack($file_id: int, $byte_index: int, $var_idx: int, consensus_pubkey: $Value, validator_network_addresses: $Value, fullnode_network_addresses: $Value) returns ($struct: $Value)
{
    assume $Vector_$is_well_formed(consensus_pubkey) && (forall $$0: int :: {$select_vector(consensus_pubkey,$$0)} $$0 >= 0 && $$0 < $vlen(consensus_pubkey) ==> $IsValidU8($select_vector(consensus_pubkey,$$0)));
    assume $Vector_$is_well_formed(validator_network_addresses) && (forall $$0: int :: {$select_vector(validator_network_addresses,$$0)} $$0 >= 0 && $$0 < $vlen(validator_network_addresses) ==> $IsValidU8($select_vector(validator_network_addresses,$$0)));
    assume $Vector_$is_well_formed(fullnode_network_addresses) && (forall $$0: int :: {$select_vector(fullnode_network_addresses,$$0)} $$0 >= 0 && $$0 < $vlen(fullnode_network_addresses) ==> $IsValidU8($select_vector(fullnode_network_addresses,$$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := consensus_pubkey][1 := validator_network_addresses][2 := fullnode_network_addresses], 3));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $ValidatorConfig_Config_unpack($struct: $Value) returns (consensus_pubkey: $Value, validator_network_addresses: $Value, fullnode_network_addresses: $Value)
{
    assume is#$Vector($struct);
    consensus_pubkey := $SelectField($struct, $ValidatorConfig_Config_consensus_pubkey);
    assume $Vector_$is_well_formed(consensus_pubkey) && (forall $$0: int :: {$select_vector(consensus_pubkey,$$0)} $$0 >= 0 && $$0 < $vlen(consensus_pubkey) ==> $IsValidU8($select_vector(consensus_pubkey,$$0)));
    validator_network_addresses := $SelectField($struct, $ValidatorConfig_Config_validator_network_addresses);
    assume $Vector_$is_well_formed(validator_network_addresses) && (forall $$0: int :: {$select_vector(validator_network_addresses,$$0)} $$0 >= 0 && $$0 < $vlen(validator_network_addresses) ==> $IsValidU8($select_vector(validator_network_addresses,$$0)));
    fullnode_network_addresses := $SelectField($struct, $ValidatorConfig_Config_fullnode_network_addresses);
    assume $Vector_$is_well_formed(fullnode_network_addresses) && (forall $$0: int :: {$select_vector(fullnode_network_addresses,$$0)} $$0 >= 0 && $$0 < $vlen(fullnode_network_addresses) ==> $IsValidU8($select_vector(fullnode_network_addresses,$$0)));
}

const unique $ValidatorConfig_ValidatorConfig: $TypeName;
const $ValidatorConfig_ValidatorConfig_config: $FieldName;
axiom $ValidatorConfig_ValidatorConfig_config == 0;
const $ValidatorConfig_ValidatorConfig_operator_account: $FieldName;
axiom $ValidatorConfig_ValidatorConfig_operator_account == 1;
const $ValidatorConfig_ValidatorConfig_human_name: $FieldName;
axiom $ValidatorConfig_ValidatorConfig_human_name == 2;
function $ValidatorConfig_ValidatorConfig_type_value(): $TypeValue {
    $StructType($ValidatorConfig_ValidatorConfig, $EmptyTypeValueArray)
}
var $ValidatorConfig_ValidatorConfig_$memory: $Memory;
var $ValidatorConfig_ValidatorConfig_$memory_$old: $Memory;
function {:inline} $ValidatorConfig_ValidatorConfig_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 3
      && $Option_Option_$is_well_typed($SelectField($this, $ValidatorConfig_ValidatorConfig_config))
      && $Option_Option_$is_well_typed($SelectField($this, $ValidatorConfig_ValidatorConfig_operator_account))
      && $Vector_$is_well_formed($SelectField($this, $ValidatorConfig_ValidatorConfig_human_name)) && (forall $$0: int :: {$select_vector($SelectField($this, $ValidatorConfig_ValidatorConfig_human_name),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_ValidatorConfig_human_name)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_ValidatorConfig_human_name),$$0)))
}
function {:inline} $ValidatorConfig_ValidatorConfig_$invariant_holds($this: $Value): bool {
    $Option_Option_$invariant_holds($SelectField($this, $ValidatorConfig_ValidatorConfig_config))
      && $Option_Option_$invariant_holds($SelectField($this, $ValidatorConfig_ValidatorConfig_operator_account))
}

function {:inline} $ValidatorConfig_ValidatorConfig_$is_well_formed($this: $Value): bool {
    $ValidatorConfig_ValidatorConfig_$is_well_typed($this) && $ValidatorConfig_ValidatorConfig_$invariant_holds($this)}

procedure {:inline 1} $ValidatorConfig_ValidatorConfig_$unpack_ref_deep($before: $Value) {
    call $Option_Option_$unpack_ref($ValidatorConfig_Config_type_value(), $SelectField($before, $ValidatorConfig_ValidatorConfig_config));
    call $Option_Option_$unpack_ref($AddressType(), $SelectField($before, $ValidatorConfig_ValidatorConfig_operator_account));
    assume $ValidatorConfig_ValidatorConfig_$invariant_holds($before);
}

procedure {:inline 1} $ValidatorConfig_ValidatorConfig_$unpack_ref($before: $Value) {
    assume $ValidatorConfig_ValidatorConfig_$invariant_holds($before);
}

procedure {:inline 1} $ValidatorConfig_ValidatorConfig_$pack_ref_deep($after: $Value) {
    call $Option_Option_$pack_ref($ValidatorConfig_Config_type_value(), $SelectField($after, $ValidatorConfig_ValidatorConfig_config));
    call $Option_Option_$pack_ref($AddressType(), $SelectField($after, $ValidatorConfig_ValidatorConfig_operator_account));
}

procedure {:inline 1} $ValidatorConfig_ValidatorConfig_$pack_ref($after: $Value) {
}

procedure {:inline 1} $ValidatorConfig_ValidatorConfig_pack($file_id: int, $byte_index: int, $var_idx: int, config: $Value, operator_account: $Value, human_name: $Value) returns ($struct: $Value)
{
    assume $Option_Option_$is_well_formed(config);
    assume $Option_Option_$is_well_formed(operator_account);
    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := config][1 := operator_account][2 := human_name], 3));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $ValidatorConfig_ValidatorConfig_unpack($struct: $Value) returns (config: $Value, operator_account: $Value, human_name: $Value)
{
    assume is#$Vector($struct);
    config := $SelectField($struct, $ValidatorConfig_ValidatorConfig_config);
    assume $Option_Option_$is_well_formed(config);
    operator_account := $SelectField($struct, $ValidatorConfig_ValidatorConfig_operator_account);
    assume $Option_Option_$is_well_formed(operator_account);
    human_name := $SelectField($struct, $ValidatorConfig_ValidatorConfig_human_name);
    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));
}



// ** functions of module ValidatorConfig

procedure {:inline 1} $ValidatorConfig_get_human_name_$def(addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var t_ref: $Value; // $ValidatorConfig_ValidatorConfig_type_value()
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $Vector_type_value($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(28, 12563, 0, addr); }

    // bytecode translation starts here
    // $t4 := move(addr)
    call $t4 := $CopyOrMoveValue(addr);

    // $t5 := exists<ValidatorConfig::ValidatorConfig>($t4)
    $t5 := $ResourceExists($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, $t4);

    // $t6 := 0
    $t6 := $Integer(0);

    // $t7 := Errors::not_published($t6)
    call $t7 := $Errors_not_published($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 12697, $abort_code);
      goto Abort;
    }

    // if ($t5) goto L0 else goto L1
    if (b#$Boolean($t5)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t7)
    if (true) { assume $DebugTrackAbort(28, 12651, i#$Integer($t7)); }
    $abort_code := i#$Integer($t7);
    goto Abort;

    // L0:
L0:

    // t_ref := get_global<ValidatorConfig::ValidatorConfig>($t4)
    call t_ref := $GetGlobal($ValidatorConfig_ValidatorConfig_$memory, $t4, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 12752, $abort_code);
      goto Abort;
    }
    if (true) { assume $DebugTrackLocal(28, 12752, 1, t_ref); }

    // $t8 := get_field<ValidatorConfig::ValidatorConfig>.human_name(t_ref)
    call $t8 := $GetFieldFromValue(t_ref, $ValidatorConfig_ValidatorConfig_human_name);

    // return $t8
    $ret0 := $t8;
    if (true) { assume $DebugTrackLocal(28, 12798, 9, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $ValidatorConfig_get_human_name_$direct_inter(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_get_human_name($ValidatorConfig_ValidatorConfig_$memory, addr)))));
ensures $Vector_$is_well_formed($ret0) && (forall $$0: int :: {$select_vector($ret0,$$0)} $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0,$$0)));

procedure {:inline 1} $ValidatorConfig_get_human_name_$direct_intra(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_get_human_name($ValidatorConfig_ValidatorConfig_$memory, addr)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr1), $ValidatorConfig_ValidatorConfig_operator_account), old($SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr1), $ValidatorConfig_ValidatorConfig_operator_account)))))))))));
ensures $Vector_$is_well_formed($ret0) && (forall $$0: int :: {$select_vector($ret0,$$0)} $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0,$$0)));

procedure {:inline 1} $ValidatorConfig_get_human_name(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_get_human_name($ValidatorConfig_ValidatorConfig_$memory, addr)))));
ensures $Vector_$is_well_formed($ret0) && (forall $$0: int :: {$select_vector($ret0,$$0)} $$0 >= 0 && $$0 < $vlen($ret0) ==> $IsValidU8($select_vector($ret0,$$0)));

procedure {:inline 1} $ValidatorConfig_publish_$def(validator_account: $Value, lr_account: $Value, human_name: $Value) returns ()
{
    // declare local variables
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $Vector_type_value($IntegerType())
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $Option_Option_type_value($ValidatorConfig_Config_type_value())
    var $t14: $Value; // $Option_Option_type_value($AddressType())
    var $t15: $Value; // $ValidatorConfig_ValidatorConfig_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(28, 1556, 0, validator_account); }
    if (true) { assume $DebugTrackLocal(28, 1556, 1, lr_account); }
    if (true) { assume $DebugTrackLocal(28, 1556, 2, human_name); }

    // bytecode translation starts here
    // $t5 := move(validator_account)
    call $t5 := $CopyOrMoveValue(validator_account);

    // $t6 := move(lr_account)
    call $t6 := $CopyOrMoveValue(lr_account);

    // $t7 := move(human_name)
    call $t7 := $CopyOrMoveValue(human_name);

    // LibraTimestamp::assert_operating()
    call $LibraTimestamp_assert_operating();
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 1705, $abort_code);
      goto Abort;
    }

    // Roles::assert_libra_root($t6)
    call $Roles_assert_libra_root($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 1740, $abort_code);
      goto Abort;
    }

    // Roles::assert_validator($t5)
    call $Roles_assert_validator($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 1786, $abort_code);
      goto Abort;
    }

    // $t8 := Signer::address_of($t5)
    call $t8 := $Signer_address_of($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 1884, $abort_code);
      goto Abort;
    }

    // $t9 := exists<ValidatorConfig::ValidatorConfig>($t8)
    $t9 := $ResourceExists($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, $t8);

    // $t10 := !($t9)
    call $t10 := $Not($t9);

    // $t11 := 0
    $t11 := $Integer(0);

    // $t12 := Errors::already_published($t11)
    call $t12 := $Errors_already_published($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 1936, $abort_code);
      goto Abort;
    }

    // if ($t10) goto L0 else goto L1
    if (b#$Boolean($t10)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t5)

    // abort($t12)
    if (true) { assume $DebugTrackAbort(28, 1831, i#$Integer($t12)); }
    $abort_code := i#$Integer($t12);
    goto Abort;

    // L0:
L0:

    // $t13 := Option::none<ValidatorConfig::Config>()
    call $t13 := $Option_none($ValidatorConfig_Config_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 2065, $abort_code);
      goto Abort;
    }

    // $t14 := Option::none<address>()
    call $t14 := $Option_none($AddressType());
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 2111, $abort_code);
      goto Abort;
    }

    // $t15 := pack ValidatorConfig::ValidatorConfig($t13, $t14, $t7)
    call $t15 := $ValidatorConfig_ValidatorConfig_pack(0, 0, 0, $t13, $t14, $t7);

    // move_to<ValidatorConfig::ValidatorConfig>($t15, $t5)
    call $ValidatorConfig_ValidatorConfig_$memory := $MoveTo($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, $t15, $t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 1992, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $ValidatorConfig_publish_$direct_inter(validator_account: $Value, lr_account: $Value, human_name: $Value) returns ()
{
    assume is#$Address(validator_account);

    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    call $ValidatorConfig_publish_$def(validator_account, lr_account, human_name);
}


procedure {:inline 1} $ValidatorConfig_publish_$direct_intra(validator_account: $Value, lr_account: $Value, human_name: $Value) returns ()
{
    assume is#$Address(validator_account);

    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    call $ValidatorConfig_publish_$def(validator_account, lr_account, human_name);
}


procedure {:inline 1} $ValidatorConfig_publish(validator_account: $Value, lr_account: $Value, human_name: $Value) returns ()
{
    assume is#$Address(validator_account);

    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    call $ValidatorConfig_publish_$def(validator_account, lr_account, human_name);
}


procedure {:inline 1} $ValidatorConfig_exists_config_$def(addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(28, 2826, 0, addr); }

    // bytecode translation starts here
    // $t1 := move(addr)
    call $t1 := $CopyOrMoveValue(addr);

    // $t2 := exists<ValidatorConfig::ValidatorConfig>($t1)
    $t2 := $ResourceExists($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, $t1);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(28, 2875, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $ValidatorConfig_exists_config_$direct_intra(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $ValidatorConfig_exists_config_$def(addr);
}


procedure {:inline 1} $ValidatorConfig_exists_config(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $ValidatorConfig_exists_config_$def(addr);
}


procedure {:inline 1} $ValidatorConfig_get_config_$def(addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var config: $Value; // $Option_Option_type_value($ValidatorConfig_Config_type_value())
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $ValidatorConfig_ValidatorConfig_type_value()
    var $t11: $Value; // $BooleanType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $ValidatorConfig_Config_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(28, 11681, 0, addr); }

    // bytecode translation starts here
    // $t6 := move(addr)
    call $t6 := $CopyOrMoveValue(addr);

    // $t7 := ValidatorConfig::exists_config($t6)
    call $t7 := $ValidatorConfig_exists_config($t6);
    if ($abort_flag) {
      goto Abort;
    }

    // $t8 := 0
    $t8 := $Integer(0);

    // $t9 := Errors::not_published($t8)
    call $t9 := $Errors_not_published($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 11797, $abort_code);
      goto Abort;
    }

    // if ($t7) goto L0 else goto L1
    if (b#$Boolean($t7)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t9)
    if (true) { assume $DebugTrackAbort(28, 11761, i#$Integer($t9)); }
    $abort_code := i#$Integer($t9);
    goto Abort;

    // L0:
L0:

    // $t10 := get_global<ValidatorConfig::ValidatorConfig>($t6)
    call $t10 := $GetGlobal($ValidatorConfig_ValidatorConfig_$memory, $t6, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 11854, $abort_code);
      goto Abort;
    }

    // config := get_field<ValidatorConfig::ValidatorConfig>.config($t10)
    call config := $GetFieldFromValue($t10, $ValidatorConfig_ValidatorConfig_config);
    if (true) { assume $DebugTrackLocal(28, 11853, 1, config); }

    // $t11 := Option::is_some<ValidatorConfig::Config>(config)
    call $t11 := $Option_is_some($ValidatorConfig_Config_type_value(), config);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 11922, $abort_code);
      goto Abort;
    }

    // $t12 := 0
    $t12 := $Integer(0);

    // $t13 := Errors::invalid_argument($t12)
    call $t13 := $Errors_invalid_argument($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 11947, $abort_code);
      goto Abort;
    }

    // if ($t11) goto L2 else goto L3
    if (b#$Boolean($t11)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // destroy(config)

    // abort($t13)
    if (true) { assume $DebugTrackAbort(28, 11907, i#$Integer($t13)); }
    $abort_code := i#$Integer($t13);
    goto Abort;

    // L2:
L2:

    // $t14 := Option::borrow<ValidatorConfig::Config>(config)
    call $t14 := $Option_borrow($ValidatorConfig_Config_type_value(), config);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 12002, $abort_code);
      goto Abort;
    }

    // return $t14
    $ret0 := $t14;
    if (true) { assume $DebugTrackLocal(28, 11993, 15, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $ValidatorConfig_get_config_$direct_inter(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Option_spec_is_none($ValidatorConfig_Config_type_value(), $SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr), $ValidatorConfig_ValidatorConfig_config)))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr)))))
    || b#$Boolean(old($Option_spec_is_none($ValidatorConfig_Config_type_value(), $SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr), $ValidatorConfig_ValidatorConfig_config)))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Option_spec_is_none($ValidatorConfig_Config_type_value(), $SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr), $ValidatorConfig_ValidatorConfig_config)))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_get_config($ValidatorConfig_ValidatorConfig_$memory, addr)))));
ensures $ValidatorConfig_Config_$is_well_formed($ret0);

procedure {:inline 1} $ValidatorConfig_get_config_$direct_intra(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Option_spec_is_none($ValidatorConfig_Config_type_value(), $SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr), $ValidatorConfig_ValidatorConfig_config)))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr)))))
    || b#$Boolean(old($Option_spec_is_none($ValidatorConfig_Config_type_value(), $SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr), $ValidatorConfig_ValidatorConfig_config)))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Option_spec_is_none($ValidatorConfig_Config_type_value(), $SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr), $ValidatorConfig_ValidatorConfig_config)))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_get_config($ValidatorConfig_ValidatorConfig_$memory, addr)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr1), $ValidatorConfig_ValidatorConfig_operator_account), old($SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr1), $ValidatorConfig_ValidatorConfig_operator_account)))))))))));
ensures $ValidatorConfig_Config_$is_well_formed($ret0);

procedure {:inline 1} $ValidatorConfig_get_config(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Option_spec_is_none($ValidatorConfig_Config_type_value(), $SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr), $ValidatorConfig_ValidatorConfig_config)))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr)))))
    || b#$Boolean(old($Option_spec_is_none($ValidatorConfig_Config_type_value(), $SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr), $ValidatorConfig_ValidatorConfig_config)))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Option_spec_is_none($ValidatorConfig_Config_type_value(), $SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr), $ValidatorConfig_ValidatorConfig_config)))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_get_config($ValidatorConfig_ValidatorConfig_$memory, addr)))));
ensures $ValidatorConfig_Config_$is_well_formed($ret0);

procedure {:inline 1} $ValidatorConfig_get_consensus_pubkey_$def(config_ref: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $ValidatorConfig_Config_type_value()
    var $t2: $Value; // $Vector_type_value($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(28, 13661, 0, config_ref); }

    // bytecode translation starts here
    // $t1 := move(config_ref)
    call $t1 := $CopyOrMoveValue(config_ref);

    // $t2 := get_field<ValidatorConfig::Config>.consensus_pubkey($t1)
    call $t2 := $GetFieldFromValue($t1, $ValidatorConfig_Config_consensus_pubkey);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(28, 13737, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $ValidatorConfig_get_consensus_pubkey_$direct_inter(config_ref: $Value) returns ($ret0: $Value)
{
    assume $ValidatorConfig_Config_$is_well_formed(config_ref);

    call $ret0 := $ValidatorConfig_get_consensus_pubkey_$def(config_ref);
}


procedure {:inline 1} $ValidatorConfig_get_consensus_pubkey_$direct_intra(config_ref: $Value) returns ($ret0: $Value)
{
    assume $ValidatorConfig_Config_$is_well_formed(config_ref);

    call $ret0 := $ValidatorConfig_get_consensus_pubkey_$def(config_ref);
}


procedure {:inline 1} $ValidatorConfig_get_consensus_pubkey(config_ref: $Value) returns ($ret0: $Value)
{
    assume $ValidatorConfig_Config_$is_well_formed(config_ref);

    call $ret0 := $ValidatorConfig_get_consensus_pubkey_$def(config_ref);
}


procedure {:inline 1} $ValidatorConfig_get_operator_$def(addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var t_ref: $Value; // $ValidatorConfig_ValidatorConfig_type_value()
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $Option_Option_type_value($AddressType())
    var $t9: $Value; // $AddressType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(28, 13138, 0, addr); }

    // bytecode translation starts here
    // $t4 := move(addr)
    call $t4 := $CopyOrMoveValue(addr);

    // $t5 := exists<ValidatorConfig::ValidatorConfig>($t4)
    $t5 := $ResourceExists($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, $t4);

    // $t6 := 0
    $t6 := $Integer(0);

    // $t7 := Errors::not_published($t6)
    call $t7 := $Errors_not_published($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 13267, $abort_code);
      goto Abort;
    }

    // if ($t5) goto L0 else goto L1
    if (b#$Boolean($t5)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t7)
    if (true) { assume $DebugTrackAbort(28, 13221, i#$Integer($t7)); }
    $abort_code := i#$Integer($t7);
    goto Abort;

    // L0:
L0:

    // t_ref := get_global<ValidatorConfig::ValidatorConfig>($t4)
    call t_ref := $GetGlobal($ValidatorConfig_ValidatorConfig_$memory, $t4, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 13322, $abort_code);
      goto Abort;
    }
    if (true) { assume $DebugTrackLocal(28, 13322, 1, t_ref); }

    // $t8 := get_field<ValidatorConfig::ValidatorConfig>.operator_account(t_ref)
    call $t8 := $GetFieldFromValue(t_ref, $ValidatorConfig_ValidatorConfig_operator_account);

    // $t9 := Option::borrow_with_default<address>($t8, $t4)
    call $t9 := $Option_borrow_with_default($AddressType(), $t8, $t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 13377, $abort_code);
      goto Abort;
    }

    // return $t9
    $ret0 := $t9;
    if (true) { assume $DebugTrackLocal(28, 13368, 10, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $ValidatorConfig_get_operator_$direct_inter(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory, addr)))));
ensures is#$Address($ret0);

procedure {:inline 1} $ValidatorConfig_get_operator_$direct_intra(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory, addr)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr1), $ValidatorConfig_ValidatorConfig_operator_account), old($SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr1), $ValidatorConfig_ValidatorConfig_operator_account)))))))))));
ensures is#$Address($ret0);

procedure {:inline 1} $ValidatorConfig_get_operator(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory, addr)))));
ensures is#$Address($ret0);

procedure {:inline 1} $ValidatorConfig_get_validator_network_addresses_$def(config_ref: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $ValidatorConfig_Config_type_value()
    var $t2: $Value; // $Vector_type_value($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(28, 13850, 0, config_ref); }

    // bytecode translation starts here
    // $t1 := move(config_ref)
    call $t1 := $CopyOrMoveValue(config_ref);

    // $t2 := get_field<ValidatorConfig::Config>.validator_network_addresses($t1)
    call $t2 := $GetFieldFromValue($t1, $ValidatorConfig_Config_validator_network_addresses);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(28, 13937, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $ValidatorConfig_get_validator_network_addresses_$direct_inter(config_ref: $Value) returns ($ret0: $Value)
{
    assume $ValidatorConfig_Config_$is_well_formed(config_ref);

    call $ret0 := $ValidatorConfig_get_validator_network_addresses_$def(config_ref);
}


procedure {:inline 1} $ValidatorConfig_get_validator_network_addresses_$direct_intra(config_ref: $Value) returns ($ret0: $Value)
{
    assume $ValidatorConfig_Config_$is_well_formed(config_ref);

    call $ret0 := $ValidatorConfig_get_validator_network_addresses_$def(config_ref);
}


procedure {:inline 1} $ValidatorConfig_get_validator_network_addresses(config_ref: $Value) returns ($ret0: $Value)
{
    assume $ValidatorConfig_Config_$is_well_formed(config_ref);

    call $ret0 := $ValidatorConfig_get_validator_network_addresses_$def(config_ref);
}


procedure {:inline 1} $ValidatorConfig_is_valid_$def(addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $ValidatorConfig_ValidatorConfig_type_value()
    var $t5: $Value; // $Option_Option_type_value($ValidatorConfig_Config_type_value())
    var $t6: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(28, 10940, 0, addr); }

    // bytecode translation starts here
    // $t2 := move(addr)
    call $t2 := $CopyOrMoveValue(addr);

    // $t3 := exists<ValidatorConfig::ValidatorConfig>($t2)
    $t3 := $ResourceExists($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, $t2);

    // if ($t3) goto L0 else goto L1
    if (b#$Boolean($t3)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t4 := get_global<ValidatorConfig::ValidatorConfig>($t2)
    call $t4 := $GetGlobal($ValidatorConfig_ValidatorConfig_$memory, $t2, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 11066, $abort_code);
      goto Abort;
    }

    // $t5 := get_field<ValidatorConfig::ValidatorConfig>.config($t4)
    call $t5 := $GetFieldFromValue($t4, $ValidatorConfig_ValidatorConfig_config);

    // tmp#$1 := Option::is_some<ValidatorConfig::Config>($t5)
    call tmp#$1 := $Option_is_some($ValidatorConfig_Config_type_value(), $t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 11057, $abort_code);
      goto Abort;
    }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t6 := false
    $t6 := $Boolean(false);

    // tmp#$1 := $t6
    call tmp#$1 := $CopyOrMoveValue($t6);
    if (true) { assume $DebugTrackLocal(28, 11016, 1, tmp#$1); }

    // goto L3
    goto L3;

    // L3:
L3:

    // return tmp#$1
    $ret0 := tmp#$1;
    if (true) { assume $DebugTrackLocal(28, 11016, 7, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $ValidatorConfig_is_valid_$direct_inter(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_$is_valid($ValidatorConfig_ValidatorConfig_$memory, addr)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $ValidatorConfig_is_valid_$direct_intra(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_$is_valid($ValidatorConfig_ValidatorConfig_$memory, addr)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr1), $ValidatorConfig_ValidatorConfig_operator_account), old($SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr1), $ValidatorConfig_ValidatorConfig_operator_account)))))))))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $ValidatorConfig_is_valid(addr: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $ValidatorConfig_$is_valid($ValidatorConfig_ValidatorConfig_$memory, addr)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $ValidatorConfig_remove_operator_$def(validator_account: $Value) returns ()
{
    // declare local variables
    var sender: $Value; // $AddressType()
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $Option_Option_type_value($AddressType())
    var $t9: $Mutation; // ReferenceType($ValidatorConfig_ValidatorConfig_type_value())
    var $t10: $Mutation; // ReferenceType($Option_Option_type_value($AddressType()))

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(28, 6727, 0, validator_account); }

    // bytecode translation starts here
    // $t4 := move(validator_account)
    call $t4 := $CopyOrMoveValue(validator_account);

    // Roles::assert_validator($t4)
    call $Roles_assert_validator($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 6824, $abort_code);
      goto Abort;
    }

    // sender := Signer::address_of($t4)
    call sender := $Signer_address_of($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 6890, $abort_code);
      goto Abort;
    }

    // $t5 := ValidatorConfig::exists_config(sender)
    call $t5 := $ValidatorConfig_exists_config(sender);
    if ($abort_flag) {
      goto Abort;
    }

    // $t6 := 0
    $t6 := $Integer(0);

    // $t7 := Errors::not_published($t6)
    call $t7 := $Errors_not_published($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 7003, $abort_code);
      goto Abort;
    }

    // if ($t5) goto L0 else goto L1
    if (b#$Boolean($t5)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t7)
    if (true) { assume $DebugTrackAbort(28, 6965, i#$Integer($t7)); }
    $abort_code := i#$Integer($t7);
    goto Abort;

    // L0:
L0:

    // $t8 := Option::none<address>()
    call $t8 := $Option_none($AddressType());
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 7118, $abort_code);
      goto Abort;
    }

    // $t9 := borrow_global<ValidatorConfig::ValidatorConfig>(sender)
    call $t9 := $BorrowGlobal($ValidatorConfig_ValidatorConfig_$memory, sender, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 7047, $abort_code);
      goto Abort;
    }

    // unpack_ref($t9)
    call $ValidatorConfig_ValidatorConfig_$unpack_ref($Dereference($t9));

    // $t10 := borrow_field<ValidatorConfig::ValidatorConfig>.operator_account($t9)
    call $t10 := $BorrowField($t9, $ValidatorConfig_ValidatorConfig_operator_account);

    // unpack_ref($t10)
    call $Option_Option_$unpack_ref($AddressType(), $Dereference($t10));

    // write_ref($t10, $t8)
    call $t10 := $WriteRef($t10, $t8);

    // pack_ref($t10)
    call $Option_Option_$pack_ref($AddressType(), $Dereference($t10));

    // write_back[Reference($t9)]($t10)
    call $t9 := $WritebackToReference($t10, $t9);

    // pack_ref($t9)
    call $ValidatorConfig_ValidatorConfig_$pack_ref($Dereference($t9));

    // write_back[ValidatorConfig::ValidatorConfig]($t9)
    call $ValidatorConfig_ValidatorConfig_$memory := $WritebackToGlobal($ValidatorConfig_ValidatorConfig_$memory, $t9);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $ValidatorConfig_remove_operator_$direct_inter(validator_account: $Value) returns ()
{
    assume is#$Address(validator_account);

    call $ValidatorConfig_remove_operator_$def(validator_account);
}


procedure {:inline 1} $ValidatorConfig_remove_operator_$direct_intra(validator_account: $Value) returns ()
{
    assume is#$Address(validator_account);

    call $ValidatorConfig_remove_operator_$def(validator_account);
}


procedure {:inline 1} $ValidatorConfig_remove_operator(validator_account: $Value) returns ()
{
    assume is#$Address(validator_account);

    call $ValidatorConfig_remove_operator_$def(validator_account);
}


procedure {:inline 1} $ValidatorConfig_set_config_$def(validator_operator_account: $Value, validator_addr: $Value, consensus_pubkey: $Value, validator_network_addresses: $Value, fullnode_network_addresses: $Value, $ValidatorConfig_ValidatorConfig_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var t_ref: $Mutation; // ReferenceType($ValidatorConfig_ValidatorConfig_type_value())
    var tmp#$6: $Value; // $BooleanType()
    var tmp#$7: $Value; // $IntegerType()
    var tmp#$8: $Value; // $BooleanType()
    var tmp#$9: $Value; // $IntegerType()
    var tmp#$10: $Value; // $BooleanType()
    var tmp#$11: $Value; // $IntegerType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $Vector_type_value($IntegerType())
    var $t15: $Value; // $Vector_type_value($IntegerType())
    var $t16: $Value; // $Vector_type_value($IntegerType())
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $BooleanType()
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $BooleanType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $ValidatorConfig_Config_type_value()
    var $t29: $Value; // $Option_Option_type_value($ValidatorConfig_Config_type_value())
    var $t30: $Mutation; // ReferenceType($Option_Option_type_value($ValidatorConfig_Config_type_value()))
    var $ValidatorConfig_ValidatorConfig_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(28, 8309, 0, validator_operator_account); }
    if (true) { assume $DebugTrackLocal(28, 8309, 1, validator_addr); }
    if (true) { assume $DebugTrackLocal(28, 8309, 2, consensus_pubkey); }
    if (true) { assume $DebugTrackLocal(28, 8309, 3, validator_network_addresses); }
    if (true) { assume $DebugTrackLocal(28, 8309, 4, fullnode_network_addresses); }
    $ValidatorConfig_ValidatorConfig_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address(validator_addr) := true];

    // bytecode translation starts here
    // $t12 := move(validator_operator_account)
    call $t12 := $CopyOrMoveValue(validator_operator_account);

    // $t13 := move(validator_addr)
    call $t13 := $CopyOrMoveValue(validator_addr);

    // $t14 := move(consensus_pubkey)
    call $t14 := $CopyOrMoveValue(consensus_pubkey);

    // $t15 := move(validator_network_addresses)
    call $t15 := $CopyOrMoveValue(validator_network_addresses);

    // $t16 := move(fullnode_network_addresses)
    call $t16 := $CopyOrMoveValue(fullnode_network_addresses);

    // $t17 := Signer::address_of($t12)
    call $t17 := $Signer_address_of($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 8614, $abort_code);
      goto Abort;
    }

    // $t18 := ValidatorConfig::get_operator($t13)
    call $t18 := $ValidatorConfig_get_operator($t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 13149, $abort_code);
      goto Abort;
    }

    // $t19 := ==($t17, $t18)
    $t19 := $Boolean($IsEqual($t17, $t18));

    // $t20 := 1
    $t20 := $Integer(1);

    // $t21 := Errors::invalid_argument($t20)
    call $t21 := $Errors_invalid_argument($t20);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 8706, $abort_code);
      goto Abort;
    }

    // if ($t19) goto L0 else goto L1
    if (b#$Boolean($t19)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t21)
    if (true) { assume $DebugTrackAbort(28, 8586, i#$Integer($t21)); }
    $abort_code := i#$Integer($t21);
    goto Abort;

    // L0:
L0:

    // $t22 := Signature::ed25519_validate_pubkey($t14)
    call $t22 := $Signature_ed25519_validate_pubkey($t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 8802, $abort_code);
      goto Abort;
    }

    // $t23 := 2
    $t23 := $Integer(2);

    // $t24 := Errors::invalid_argument($t23)
    call $t24 := $Errors_invalid_argument($t23);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 8870, $abort_code);
      goto Abort;
    }

    // if ($t22) goto L2 else goto L3
    if (b#$Boolean($t22)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t24)
    if (true) { assume $DebugTrackAbort(28, 8771, i#$Integer($t24)); }
    $abort_code := i#$Integer($t24);
    goto Abort;

    // L2:
L2:

    // $t25 := ValidatorConfig::exists_config($t13)
    call $t25 := $ValidatorConfig_exists_config($t13);
    if ($abort_flag) {
      goto Abort;
    }

    // $t26 := 0
    $t26 := $Integer(0);

    // $t27 := Errors::not_published($t26)
    call $t27 := $Errors_not_published($t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 9054, $abort_code);
      goto Abort;
    }

    // if ($t25) goto L4 else goto L5
    if (b#$Boolean($t25)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // abort($t27)
    if (true) { assume $DebugTrackAbort(28, 9008, i#$Integer($t27)); }
    $abort_code := i#$Integer($t27);
    goto Abort;

    // L4:
L4:

    // t_ref := borrow_global<ValidatorConfig::ValidatorConfig>($t13)
    assert $ValidatorConfig_ValidatorConfig_$SelfDomain[$EmptyTypeValueArray, a#$Address($t13)];
    call t_ref := $BorrowGlobal($ValidatorConfig_ValidatorConfig_$memory, $t13, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 9109, $abort_code);
      goto Abort;
    }

    // unpack_ref(t_ref)
    call $ValidatorConfig_ValidatorConfig_$unpack_ref($Dereference(t_ref));

    // $t28 := pack ValidatorConfig::Config($t14, $t15, $t16)
    call $t28 := $ValidatorConfig_Config_pack(0, 0, 0, $t14, $t15, $t16);

    // $t29 := Option::some<ValidatorConfig::Config>($t28)
    call $t29 := $Option_some($ValidatorConfig_Config_type_value(), $t28);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 9192, $abort_code);
      goto Abort;
    }

    // $t30 := borrow_field<ValidatorConfig::ValidatorConfig>.config(t_ref)
    call $t30 := $BorrowField(t_ref, $ValidatorConfig_ValidatorConfig_config);

    // unpack_ref($t30)
    call $Option_Option_$unpack_ref($ValidatorConfig_Config_type_value(), $Dereference($t30));

    // write_ref($t30, $t29)
    call $t30 := $WriteRef($t30, $t29);
    if (true) { assume $DebugTrackLocal(28, 9169, 5, $Dereference(t_ref)); }

    // pack_ref($t30)
    call $Option_Option_$pack_ref($ValidatorConfig_Config_type_value(), $Dereference($t30));

    // write_back[Reference(t_ref)]($t30)
    call t_ref := $WritebackToReference($t30, t_ref);

    // pack_ref(t_ref)
    call $ValidatorConfig_ValidatorConfig_$pack_ref($Dereference(t_ref));

    // write_back[ValidatorConfig::ValidatorConfig](t_ref)
    call $ValidatorConfig_ValidatorConfig_$memory := $WritebackToGlobal($ValidatorConfig_ValidatorConfig_$memory, t_ref);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $ValidatorConfig_set_config_$direct_inter(validator_operator_account: $Value, validator_addr: $Value, consensus_pubkey: $Value, validator_network_addresses: $Value, fullnode_network_addresses: $Value, $ValidatorConfig_ValidatorConfig_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $ValidatorConfig_ValidatorConfig_$CallerDomain[$EmptyTypeValueArray, a#$Address(validator_addr)];
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_$address_of(validator_operator_account), $ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory, validator_addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Signature_$ed25519_validate_pubkey(consensus_pubkey))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, validator_addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!$IsEqual($Signer_$address_of(validator_operator_account), $ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory, validator_addr)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Signature_$ed25519_validate_pubkey(consensus_pubkey)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, validator_addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!$IsEqual($Signer_$address_of(validator_operator_account), $ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory, validator_addr))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Signature_$ed25519_validate_pubkey(consensus_pubkey))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, validator_addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($ValidatorConfig_$is_valid($ValidatorConfig_ValidatorConfig_$memory, validator_addr)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, validator_addr), $UpdateField(old($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, validator_addr)), $ValidatorConfig_ValidatorConfig_config, $Option_spec_some($ValidatorConfig_Config_type_value(), $Vector($ExtendValueArray($ExtendValueArray($ExtendValueArray($EmptyValueArray(), consensus_pubkey), validator_network_addresses), fullnode_network_addresses))))))));
modifies $ValidatorConfig_ValidatorConfig_$memory;
ensures contents#$Memory($ValidatorConfig_ValidatorConfig_$memory) == old(contents#$Memory($ValidatorConfig_ValidatorConfig_$memory))[$EmptyTypeValueArray, a#$Address(validator_addr) := contents#$Memory($ValidatorConfig_ValidatorConfig_$memory)[$EmptyTypeValueArray, a#$Address(validator_addr)]];
ensures domain#$Memory($ValidatorConfig_ValidatorConfig_$memory) == old(domain#$Memory($ValidatorConfig_ValidatorConfig_$memory))[$EmptyTypeValueArray, a#$Address(validator_addr) := domain#$Memory($ValidatorConfig_ValidatorConfig_$memory)[$EmptyTypeValueArray, a#$Address(validator_addr)]];

procedure {:inline 1} $ValidatorConfig_set_config_$direct_intra(validator_operator_account: $Value, validator_addr: $Value, consensus_pubkey: $Value, validator_network_addresses: $Value, fullnode_network_addresses: $Value, $ValidatorConfig_ValidatorConfig_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $ValidatorConfig_ValidatorConfig_$CallerDomain[$EmptyTypeValueArray, a#$Address(validator_addr)];
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_$address_of(validator_operator_account), $ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory, validator_addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Signature_$ed25519_validate_pubkey(consensus_pubkey))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, validator_addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!$IsEqual($Signer_$address_of(validator_operator_account), $ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory, validator_addr)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Signature_$ed25519_validate_pubkey(consensus_pubkey)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, validator_addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!$IsEqual($Signer_$address_of(validator_operator_account), $ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory, validator_addr))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Signature_$ed25519_validate_pubkey(consensus_pubkey))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, validator_addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($ValidatorConfig_$is_valid($ValidatorConfig_ValidatorConfig_$memory, validator_addr)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, validator_addr), $UpdateField(old($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, validator_addr)), $ValidatorConfig_ValidatorConfig_config, $Option_spec_some($ValidatorConfig_Config_type_value(), $Vector($ExtendValueArray($ExtendValueArray($ExtendValueArray($EmptyValueArray(), consensus_pubkey), validator_network_addresses), fullnode_network_addresses))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr1), $ValidatorConfig_ValidatorConfig_operator_account), old($SelectField($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, addr1), $ValidatorConfig_ValidatorConfig_operator_account)))))))))));
modifies $ValidatorConfig_ValidatorConfig_$memory;
ensures contents#$Memory($ValidatorConfig_ValidatorConfig_$memory) == old(contents#$Memory($ValidatorConfig_ValidatorConfig_$memory))[$EmptyTypeValueArray, a#$Address(validator_addr) := contents#$Memory($ValidatorConfig_ValidatorConfig_$memory)[$EmptyTypeValueArray, a#$Address(validator_addr)]];
ensures domain#$Memory($ValidatorConfig_ValidatorConfig_$memory) == old(domain#$Memory($ValidatorConfig_ValidatorConfig_$memory))[$EmptyTypeValueArray, a#$Address(validator_addr) := domain#$Memory($ValidatorConfig_ValidatorConfig_$memory)[$EmptyTypeValueArray, a#$Address(validator_addr)]];

procedure {:inline 1} $ValidatorConfig_set_config(validator_operator_account: $Value, validator_addr: $Value, consensus_pubkey: $Value, validator_network_addresses: $Value, fullnode_network_addresses: $Value, $ValidatorConfig_ValidatorConfig_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $ValidatorConfig_ValidatorConfig_$CallerDomain[$EmptyTypeValueArray, a#$Address(validator_addr)];
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_$address_of(validator_operator_account), $ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory, validator_addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Signature_$ed25519_validate_pubkey(consensus_pubkey))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, validator_addr))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!$IsEqual($Signer_$address_of(validator_operator_account), $ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory, validator_addr)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Signature_$ed25519_validate_pubkey(consensus_pubkey)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, validator_addr))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!$IsEqual($Signer_$address_of(validator_operator_account), $ValidatorConfig_spec_get_operator($ValidatorConfig_ValidatorConfig_$memory, validator_addr))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Signature_$ed25519_validate_pubkey(consensus_pubkey))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, validator_addr))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($ValidatorConfig_$is_valid($ValidatorConfig_ValidatorConfig_$memory, validator_addr)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, validator_addr), $UpdateField(old($ResourceValue($ValidatorConfig_ValidatorConfig_$memory, $EmptyTypeValueArray, validator_addr)), $ValidatorConfig_ValidatorConfig_config, $Option_spec_some($ValidatorConfig_Config_type_value(), $Vector($ExtendValueArray($ExtendValueArray($ExtendValueArray($EmptyValueArray(), consensus_pubkey), validator_network_addresses), fullnode_network_addresses))))))));
modifies $ValidatorConfig_ValidatorConfig_$memory;
ensures contents#$Memory($ValidatorConfig_ValidatorConfig_$memory) == old(contents#$Memory($ValidatorConfig_ValidatorConfig_$memory))[$EmptyTypeValueArray, a#$Address(validator_addr) := contents#$Memory($ValidatorConfig_ValidatorConfig_$memory)[$EmptyTypeValueArray, a#$Address(validator_addr)]];
ensures domain#$Memory($ValidatorConfig_ValidatorConfig_$memory) == old(domain#$Memory($ValidatorConfig_ValidatorConfig_$memory))[$EmptyTypeValueArray, a#$Address(validator_addr) := domain#$Memory($ValidatorConfig_ValidatorConfig_$memory)[$EmptyTypeValueArray, a#$Address(validator_addr)]];

procedure {:inline 1} $ValidatorConfig_set_operator_$def(validator_account: $Value, operator_addr: $Value) returns ()
{
    // declare local variables
    var sender: $Value; // $AddressType()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var tmp#$5: $Value; // $BooleanType()
    var tmp#$6: $Value; // $IntegerType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $Option_Option_type_value($AddressType())
    var $t16: $Mutation; // ReferenceType($ValidatorConfig_ValidatorConfig_type_value())
    var $t17: $Mutation; // ReferenceType($Option_Option_type_value($AddressType()))

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(28, 3495, 0, validator_account); }
    if (true) { assume $DebugTrackLocal(28, 3495, 1, operator_addr); }

    // bytecode translation starts here
    // $t7 := move(validator_account)
    call $t7 := $CopyOrMoveValue(validator_account);

    // $t8 := move(operator_addr)
    call $t8 := $CopyOrMoveValue(operator_addr);

    // Roles::assert_validator($t7)
    call $Roles_assert_validator($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 3613, $abort_code);
      goto Abort;
    }

    // $t9 := ValidatorOperatorConfig::has_validator_operator_config($t8)
    call $t9 := $ValidatorOperatorConfig_has_validator_operator_config($t8);
    if ($abort_flag) {
      goto Abort;
    }

    // $t10 := 3
    $t10 := $Integer(3);

    // $t11 := Errors::invalid_argument($t10)
    call $t11 := $Errors_invalid_argument($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 3968, $abort_code);
      goto Abort;
    }

    // if ($t9) goto L0 else goto L1
    if (b#$Boolean($t9)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t7)

    // abort($t11)
    if (true) { assume $DebugTrackAbort(28, 3857, i#$Integer($t11)); }
    $abort_code := i#$Integer($t11);
    goto Abort;

    // L0:
L0:

    // sender := Signer::address_of($t7)
    call sender := $Signer_address_of($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 4052, $abort_code);
      goto Abort;
    }

    // $t12 := ValidatorConfig::exists_config(sender)
    call $t12 := $ValidatorConfig_exists_config(sender);
    if ($abort_flag) {
      goto Abort;
    }

    // $t13 := 0
    $t13 := $Integer(0);

    // $t14 := Errors::not_published($t13)
    call $t14 := $Errors_not_published($t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 4129, $abort_code);
      goto Abort;
    }

    // if ($t12) goto L2 else goto L3
    if (b#$Boolean($t12)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t14)
    if (true) { assume $DebugTrackAbort(28, 4091, i#$Integer($t14)); }
    $abort_code := i#$Integer($t14);
    goto Abort;

    // L2:
L2:

    // $t15 := Option::some<address>($t8)
    call $t15 := $Option_some($AddressType(), $t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 4244, $abort_code);
      goto Abort;
    }

    // $t16 := borrow_global<ValidatorConfig::ValidatorConfig>(sender)
    call $t16 := $BorrowGlobal($ValidatorConfig_ValidatorConfig_$memory, sender, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 4173, $abort_code);
      goto Abort;
    }

    // unpack_ref($t16)
    call $ValidatorConfig_ValidatorConfig_$unpack_ref($Dereference($t16));

    // $t17 := borrow_field<ValidatorConfig::ValidatorConfig>.operator_account($t16)
    call $t17 := $BorrowField($t16, $ValidatorConfig_ValidatorConfig_operator_account);

    // unpack_ref($t17)
    call $Option_Option_$unpack_ref($AddressType(), $Dereference($t17));

    // write_ref($t17, $t15)
    call $t17 := $WriteRef($t17, $t15);

    // pack_ref($t17)
    call $Option_Option_$pack_ref($AddressType(), $Dereference($t17));

    // write_back[Reference($t16)]($t17)
    call $t16 := $WritebackToReference($t17, $t16);

    // pack_ref($t16)
    call $ValidatorConfig_ValidatorConfig_$pack_ref($Dereference($t16));

    // write_back[ValidatorConfig::ValidatorConfig]($t16)
    call $ValidatorConfig_ValidatorConfig_$memory := $WritebackToGlobal($ValidatorConfig_ValidatorConfig_$memory, $t16);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $ValidatorConfig_set_operator_$direct_inter(validator_account: $Value, operator_addr: $Value) returns ()
{
    assume is#$Address(validator_account);

    assume is#$Address(operator_addr);

    call $ValidatorConfig_set_operator_$def(validator_account, operator_addr);
}


procedure {:inline 1} $ValidatorConfig_set_operator_$direct_intra(validator_account: $Value, operator_addr: $Value) returns ()
{
    assume is#$Address(validator_account);

    assume is#$Address(operator_addr);

    call $ValidatorConfig_set_operator_$def(validator_account, operator_addr);
}


procedure {:inline 1} $ValidatorConfig_set_operator(validator_account: $Value, operator_addr: $Value) returns ()
{
    assume is#$Address(validator_account);

    assume is#$Address(operator_addr);

    call $ValidatorConfig_set_operator_$def(validator_account, operator_addr);
}




// ** spec vars of module TransactionFee



// ** spec funs of module TransactionFee

function {:inline} $TransactionFee_$is_coin_initialized($TransactionFee_TransactionFee_$memory: $Memory, $tv0: $TypeValue): $Value {
    $ResourceExists($TransactionFee_TransactionFee_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())
}

function {:inline} $TransactionFee_$is_initialized($TransactionFee_TransactionFee_$memory: $Memory): $Value {
    $TransactionFee_$is_coin_initialized($TransactionFee_TransactionFee_$memory, $Coin1_Coin1_type_value())
}

function {:inline} $TransactionFee_transaction_fee($TransactionFee_TransactionFee_$memory: $Memory, $tv0: $TypeValue): $Value {
    $ResourceValue($TransactionFee_TransactionFee_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())
}

function {:inline} $TransactionFee_fees$7($TransactionFee_TransactionFee_$memory: $Memory, $tv0: $TypeValue): $Value {
    $TransactionFee_transaction_fee($TransactionFee_TransactionFee_$memory, $tv0)
}

function {:inline} $TransactionFee_fees$8($TransactionFee_TransactionFee_$memory: $Memory, $tv0: $TypeValue): $Value {
    $SelectField($TransactionFee_transaction_fee($TransactionFee_TransactionFee_$memory, $tv0), $TransactionFee_TransactionFee_balance)
}



// ** structs of module TransactionFee

const unique $TransactionFee_TransactionFee: $TypeName;
const $TransactionFee_TransactionFee_balance: $FieldName;
axiom $TransactionFee_TransactionFee_balance == 0;
const $TransactionFee_TransactionFee_preburn: $FieldName;
axiom $TransactionFee_TransactionFee_preburn == 1;
function $TransactionFee_TransactionFee_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($TransactionFee_TransactionFee, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1))
}
var $TransactionFee_TransactionFee_$memory: $Memory;
var $TransactionFee_TransactionFee_$memory_$old: $Memory;
function {:inline} $TransactionFee_TransactionFee_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 2
      && $Libra_Libra_$is_well_typed($SelectField($this, $TransactionFee_TransactionFee_balance))
      && $Libra_Preburn_$is_well_typed($SelectField($this, $TransactionFee_TransactionFee_preburn))
}
function {:inline} $TransactionFee_TransactionFee_$invariant_holds($this: $Value): bool {
    $Libra_Libra_$invariant_holds($SelectField($this, $TransactionFee_TransactionFee_balance))
      && $Libra_Preburn_$invariant_holds($SelectField($this, $TransactionFee_TransactionFee_preburn))
}

function {:inline} $TransactionFee_TransactionFee_$is_well_formed($this: $Value): bool {
    $TransactionFee_TransactionFee_$is_well_typed($this) && $TransactionFee_TransactionFee_$invariant_holds($this)}

procedure {:inline 1} $TransactionFee_TransactionFee_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, balance: $Value, preburn: $Value) returns ($struct: $Value)
{
    assume $Libra_Libra_$is_well_formed(balance);
    assume $Libra_Preburn_$is_well_formed(preburn);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := balance][1 := preburn], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $TransactionFee_TransactionFee_unpack($tv0: $TypeValue, $struct: $Value) returns (balance: $Value, preburn: $Value)
{
    assume is#$Vector($struct);
    balance := $SelectField($struct, $TransactionFee_TransactionFee_balance);
    assume $Libra_Libra_$is_well_formed(balance);
    preburn := $SelectField($struct, $TransactionFee_TransactionFee_preburn);
    assume $Libra_Preburn_$is_well_formed(preburn);
}



// ** functions of module TransactionFee

procedure {:inline 1} $TransactionFee_initialize_$def(tc_account: $Value) returns ()
{
    // declare local variables
    var $t1: $Value; // $AddressType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(26, 888, 0, tc_account); }

    // bytecode translation starts here
    // $t1 := move(tc_account)
    call $t1 := $CopyOrMoveValue(tc_account);

    // LibraTimestamp::assert_genesis()
    call $LibraTimestamp_assert_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 972, $abort_code);
      goto Abort;
    }

    // Roles::assert_treasury_compliance($t1)
    call $Roles_assert_treasury_compliance($t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 1005, $abort_code);
      goto Abort;
    }

    // TransactionFee::add_txn_fee_currency<Coin1::Coin1>($t1)
    call $TransactionFee_add_txn_fee_currency($Coin1_Coin1_type_value(), $t1);
    if ($abort_flag) {
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $TransactionFee_initialize_$direct_inter(tc_account: $Value) returns ()
{
    assume is#$Address(tc_account);

    call $TransactionFee_initialize_$def(tc_account);
}


procedure {:inline 1} $TransactionFee_initialize_$direct_intra(tc_account: $Value) returns ()
{
    assume is#$Address(tc_account);

    call $TransactionFee_initialize_$def(tc_account);
}


procedure {:inline 1} $TransactionFee_initialize(tc_account: $Value) returns ()
{
    assume is#$Address(tc_account);

    call $TransactionFee_initialize_$def(tc_account);
}


procedure {:inline 1} $TransactionFee_add_txn_fee_currency_$def($tv0: $TypeValue, tc_account: $Value) returns ()
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $Libra_Libra_type_value($tv0)
    var $t10: $Value; // $Libra_Preburn_type_value($tv0)
    var $t11: $Value; // $TransactionFee_TransactionFee_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(26, 2319, 0, tc_account); }

    // bytecode translation starts here
    // $t3 := move(tc_account)
    call $t3 := $CopyOrMoveValue(tc_account);

    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 2399, $abort_code);
      goto Abort;
    }

    // $t4 := CoreAddresses::TREASURY_COMPLIANCE_ADDRESS()
    call $t4 := $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t5 := exists<TransactionFee::TransactionFee<#0>>($t4)
    $t5 := $ResourceExists($TransactionFee_TransactionFee_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t4);

    // $t6 := !($t5)
    call $t6 := $Not($t5);

    // $t7 := 0
    $t7 := $Integer(0);

    // $t8 := Errors::already_published($t7)
    call $t8 := $Errors_already_published($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 2560, $abort_code);
      goto Abort;
    }

    // if ($t6) goto L0 else goto L1
    if (b#$Boolean($t6)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t3)

    // abort($t8)
    if (true) { assume $DebugTrackAbort(26, 2439, i#$Integer($t8)); }
    $abort_code := i#$Integer($t8);
    goto Abort;

    // L0:
L0:

    // $t9 := Libra::zero<#0>()
    call $t9 := $Libra_zero($tv0);
    if ($abort_flag) {
      goto Abort;
    }

    // $t10 := Libra::create_preburn<#0>($t3)
    call $t10 := $Libra_create_preburn($tv0, $t3);
    if ($abort_flag) {
      goto Abort;
    }

    // $t11 := pack TransactionFee::TransactionFee<#0>($t9, $t10)
    call $t11 := $TransactionFee_TransactionFee_pack(0, 0, 0, $tv0, $t9, $t10);

    // move_to<TransactionFee::TransactionFee<#0>>($t11, $t3)
    call $TransactionFee_TransactionFee_$memory := $MoveTo($TransactionFee_TransactionFee_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t11, $t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 2615, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $TransactionFee_add_txn_fee_currency_$direct_inter($tv0: $TypeValue, tc_account: $Value) returns ()
{
    assume is#$Address(tc_account);

    call $TransactionFee_add_txn_fee_currency_$def($tv0, tc_account);
}


procedure {:inline 1} $TransactionFee_add_txn_fee_currency_$direct_intra($tv0: $TypeValue, tc_account: $Value) returns ()
{
    assume is#$Address(tc_account);

    call $TransactionFee_add_txn_fee_currency_$def($tv0, tc_account);
}


procedure {:inline 1} $TransactionFee_add_txn_fee_currency($tv0: $TypeValue, tc_account: $Value) returns ()
{
    assume is#$Address(tc_account);

    call $TransactionFee_add_txn_fee_currency_$def($tv0, tc_account);
}


procedure {:inline 1} $TransactionFee_burn_fees_$def($tv0: $TypeValue, tc_account: $Value) returns ()
{
    // declare local variables
    var burn_cap: $Value; // $Libra_BurnCapability_type_value($tv0)
    var coin: $Value; // $Libra_Libra_type_value($tv0)
    var fees: $Mutation; // ReferenceType($TransactionFee_TransactionFee_type_value($tv0))
    var tc_address: $Value; // $AddressType()
    var tmp#$5: $Value; // $BooleanType()
    var tmp#$6: $Value; // $IntegerType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $BooleanType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Mutation; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t15: $Value; // $Libra_Libra_type_value($tv0)
    var $t16: $Value; // $Libra_Libra_type_value($tv0)
    var $t17: $Mutation; // ReferenceType($Libra_Preburn_type_value($tv0))
    var $t18: $Value; // $Libra_Preburn_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(26, 3807, 0, tc_account); }

    // bytecode translation starts here
    // $t7 := move(tc_account)
    call $t7 := $CopyOrMoveValue(tc_account);

    // LibraTimestamp::assert_operating()
    call $LibraTimestamp_assert_operating();
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 3924, $abort_code);
      goto Abort;
    }

    // Roles::assert_treasury_compliance($t7)
    call $Roles_assert_treasury_compliance($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 3959, $abort_code);
      goto Abort;
    }

    // $t8 := TransactionFee::is_coin_initialized<#0>()
    call $t8 := $TransactionFee_is_coin_initialized($tv0);
    if ($abort_flag) {
      goto Abort;
    }

    // $t9 := 0
    $t9 := $Integer(0);

    // $t10 := Errors::not_published($t9)
    call $t10 := $Errors_not_published($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 4055, $abort_code);
      goto Abort;
    }

    // if ($t8) goto L0 else goto L1
    if (b#$Boolean($t8)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t7)

    // abort($t10)
    if (true) { assume $DebugTrackAbort(26, 4007, i#$Integer($t10)); }
    $abort_code := i#$Integer($t10);
    goto Abort;

    // L0:
L0:

    // tc_address := CoreAddresses::TREASURY_COMPLIANCE_ADDRESS()
    call tc_address := $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t11 := LBR::is_lbr<#0>()
    call $t11 := $LBR_is_lbr($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 4177, $abort_code);
      goto Abort;
    }

    // if ($t11) goto L2 else goto L3
    if (b#$Boolean($t11)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // goto L4
    goto L4;

    // L2:
L2:

    // destroy($t7)

    // $t12 := 0
    $t12 := $Integer(0);

    // $t13 := Errors::invalid_state($t12)
    call $t13 := $Errors_invalid_state($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 4370, $abort_code);
      goto Abort;
    }

    // abort($t13)
    if (true) { assume $DebugTrackAbort(26, 4356, i#$Integer($t13)); }
    $abort_code := i#$Integer($t13);
    goto Abort;

    // L4:
L4:

    // fees := borrow_global<TransactionFee::TransactionFee<#0>>(tc_address)
    call fees := $BorrowGlobal($TransactionFee_TransactionFee_$memory, tc_address, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 4470, $abort_code);
      goto Abort;
    }

    // unpack_ref(fees)

    // $t14 := borrow_field<TransactionFee::TransactionFee<#0>>.balance(fees)
    call $t14 := $BorrowField(fees, $TransactionFee_TransactionFee_balance);

    // unpack_ref($t14)

    // $t15 := read_ref($t14)
    call $t15 := $ReadRef($t14);
    assert $Libra_Libra_$invariant_holds($t15);

    // ($t16, $t15) := Libra::withdraw_all<#0>($t15)
    call $t16, $t15 := $Libra_withdraw_all($tv0, $t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 4557, $abort_code);
      goto Abort;
    }

    // write_ref($t14, $t15)
    call $t14 := $WriteRef($t14, $t15);
    if (true) { assume $DebugTrackLocal(26, 4557, 3, $Dereference(fees)); }

    // pack_ref($t14)

    // write_back[Reference(fees)]($t14)
    call fees := $WritebackToReference($t14, fees);

    // coin := $t16
    call coin := $CopyOrMoveValue($t16);
    if (true) { assume $DebugTrackLocal(26, 4543, 2, coin); }

    // burn_cap := Libra::remove_burn_capability<#0>($t7)
    call burn_cap := $Libra_remove_burn_capability($tv0, $t7);
    if ($abort_flag) {
      goto Abort;
    }

    // $t17 := borrow_field<TransactionFee::TransactionFee<#0>>.preburn(fees)
    call $t17 := $BorrowField(fees, $TransactionFee_TransactionFee_preburn);

    // unpack_ref($t17)

    // $t18 := read_ref($t17)
    call $t18 := $ReadRef($t17);
    assert $Libra_Preburn_$invariant_holds($t18);

    // $t18 := Libra::burn_now<#0>(coin, $t18, tc_address, burn_cap)
    call $t18 := $Libra_burn_now($tv0, coin, $t18, tc_address, burn_cap);
    if ($abort_flag) {
      goto Abort;
    }

    // write_ref($t17, $t18)
    call $t17 := $WriteRef($t17, $t18);
    if (true) { assume $DebugTrackLocal(26, 4709, 3, $Dereference(fees)); }

    // pack_ref($t17)

    // write_back[Reference(fees)]($t17)
    call fees := $WritebackToReference($t17, fees);

    // pack_ref(fees)

    // write_back[TransactionFee::TransactionFee](fees)
    call $TransactionFee_TransactionFee_$memory := $WritebackToGlobal($TransactionFee_TransactionFee_$memory, fees);

    // Libra::publish_burn_capability<#0>($t7, burn_cap)
    call $Libra_publish_burn_capability($tv0, $t7, burn_cap);
    if ($abort_flag) {
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $TransactionFee_burn_fees_$direct_inter($tv0: $TypeValue, tc_account: $Value) returns ()
{
    assume is#$Address(tc_account);

    call $TransactionFee_burn_fees_$def($tv0, tc_account);
}


procedure {:inline 1} $TransactionFee_burn_fees_$direct_intra($tv0: $TypeValue, tc_account: $Value) returns ()
{
    assume is#$Address(tc_account);

    call $TransactionFee_burn_fees_$def($tv0, tc_account);
}


procedure {:inline 1} $TransactionFee_burn_fees($tv0: $TypeValue, tc_account: $Value) returns ()
{
    assume is#$Address(tc_account);

    call $TransactionFee_burn_fees_$def($tv0, tc_account);
}


procedure {:inline 1} $TransactionFee_is_coin_initialized_$def($tv0: $TypeValue) returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := CoreAddresses::TREASURY_COMPLIANCE_ADDRESS()
    call $t0 := $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t1 := exists<TransactionFee::TransactionFee<#0>>($t0)
    $t1 := $ResourceExists($TransactionFee_TransactionFee_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t0);

    // return $t1
    $ret0 := $t1;
    if (true) { assume $DebugTrackLocal(26, 1748, 2, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $TransactionFee_is_coin_initialized_$direct_intra($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $TransactionFee_is_coin_initialized_$def($tv0);
}


procedure {:inline 1} $TransactionFee_is_coin_initialized($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $TransactionFee_is_coin_initialized_$def($tv0);
}


procedure {:inline 1} $TransactionFee_is_initialized_$def() returns ($ret0: $Value)
{
    // declare local variables
    var $t0: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := TransactionFee::is_coin_initialized<Coin1::Coin1>()
    call $t0 := $TransactionFee_is_coin_initialized($Coin1_Coin1_type_value());
    if ($abort_flag) {
      goto Abort;
    }

    // return $t0
    $ret0 := $t0;
    if (true) { assume $DebugTrackLocal(26, 1875, 1, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $TransactionFee_is_initialized_$direct_intra() returns ($ret0: $Value)
{
    call $ret0 := $TransactionFee_is_initialized_$def();
}


procedure {:inline 1} $TransactionFee_is_initialized() returns ($ret0: $Value)
{
    call $ret0 := $TransactionFee_is_initialized_$def();
}


procedure {:inline 1} $TransactionFee_pay_fee_$def($tv0: $TypeValue, coin: $Value) returns ()
{
    // declare local variables
    var fees: $Mutation; // ReferenceType($TransactionFee_TransactionFee_type_value($tv0))
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var $t4: $Value; // $Libra_Libra_type_value($tv0)
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $AddressType()
    var $t9: $Mutation; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t10: $Value; // $Libra_Libra_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(26, 2877, 0, coin); }

    // bytecode translation starts here
    // $t4 := move(coin)
    call $t4 := $CopyOrMoveValue(coin);

    // LibraTimestamp::assert_operating()
    call $LibraTimestamp_assert_operating();
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 2979, $abort_code);
      goto Abort;
    }

    // $t5 := TransactionFee::is_coin_initialized<#0>()
    call $t5 := $TransactionFee_is_coin_initialized($tv0);
    if ($abort_flag) {
      goto Abort;
    }

    // $t6 := 0
    $t6 := $Integer(0);

    // $t7 := Errors::not_published($t6)
    call $t7 := $Errors_not_published($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 3055, $abort_code);
      goto Abort;
    }

    // if ($t5) goto L0 else goto L1
    if (b#$Boolean($t5)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t7)
    if (true) { assume $DebugTrackAbort(26, 3007, i#$Integer($t7)); }
    $abort_code := i#$Integer($t7);
    goto Abort;

    // L0:
L0:

    // $t8 := CoreAddresses::TREASURY_COMPLIANCE_ADDRESS()
    call $t8 := $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // fees := borrow_global<TransactionFee::TransactionFee<#0>>($t8)
    call fees := $BorrowGlobal($TransactionFee_TransactionFee_$memory, $t8, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 3108, $abort_code);
      goto Abort;
    }

    // unpack_ref(fees)

    // $t9 := borrow_field<TransactionFee::TransactionFee<#0>>.balance(fees)
    call $t9 := $BorrowField(fees, $TransactionFee_TransactionFee_balance);

    // unpack_ref($t9)

    // $t10 := read_ref($t9)
    call $t10 := $ReadRef($t9);
    assert $Libra_Libra_$invariant_holds($t10);

    // $t10 := Libra::deposit<#0>($t10, $t4)
    call $t10 := $Libra_deposit($tv0, $t10, $t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 3237, $abort_code);
      goto Abort;
    }

    // write_ref($t9, $t10)
    call $t9 := $WriteRef($t9, $t10);
    if (true) { assume $DebugTrackLocal(26, 3237, 1, $Dereference(fees)); }

    // pack_ref($t9)

    // write_back[Reference(fees)]($t9)
    call fees := $WritebackToReference($t9, fees);

    // pack_ref(fees)

    // write_back[TransactionFee::TransactionFee](fees)
    call $TransactionFee_TransactionFee_$memory := $WritebackToGlobal($TransactionFee_TransactionFee_$memory, fees);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $TransactionFee_pay_fee_$direct_inter($tv0: $TypeValue, coin: $Value) returns ()
{
    assume $Libra_Libra_$is_well_formed(coin);

    call $TransactionFee_pay_fee_$def($tv0, coin);
}


procedure {:inline 1} $TransactionFee_pay_fee_$direct_intra($tv0: $TypeValue, coin: $Value) returns ()
{
    assume $Libra_Libra_$is_well_formed(coin);

    call $TransactionFee_pay_fee_$def($tv0, coin);
}


procedure {:inline 1} $TransactionFee_pay_fee($tv0: $TypeValue, coin: $Value) returns ()
{
    assume $Libra_Libra_$is_well_formed(coin);

    call $TransactionFee_pay_fee_$def($tv0, coin);
}




// ** spec vars of module SlidingNonce



// ** spec funs of module SlidingNonce

function {:inline} $SlidingNonce_spec_try_record_nonce(account: $Value, seq_nonce: $Value): $Value;
axiom (forall account: $Value, seq_nonce: $Value :: $IsValidU64($SlidingNonce_spec_try_record_nonce(account, seq_nonce)));


// ** structs of module SlidingNonce

const unique $SlidingNonce_SlidingNonce: $TypeName;
const $SlidingNonce_SlidingNonce_min_nonce: $FieldName;
axiom $SlidingNonce_SlidingNonce_min_nonce == 0;
const $SlidingNonce_SlidingNonce_nonce_mask: $FieldName;
axiom $SlidingNonce_SlidingNonce_nonce_mask == 1;
function $SlidingNonce_SlidingNonce_type_value(): $TypeValue {
    $StructType($SlidingNonce_SlidingNonce, $EmptyTypeValueArray)
}
var $SlidingNonce_SlidingNonce_$memory: $Memory;
var $SlidingNonce_SlidingNonce_$memory_$old: $Memory;
function {:inline} $SlidingNonce_SlidingNonce_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 2
      && $IsValidU64($SelectField($this, $SlidingNonce_SlidingNonce_min_nonce))
      && $IsValidU128($SelectField($this, $SlidingNonce_SlidingNonce_nonce_mask))
}
function {:inline} $SlidingNonce_SlidingNonce_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $SlidingNonce_SlidingNonce_$is_well_formed($this: $Value): bool {
    $SlidingNonce_SlidingNonce_$is_well_typed($this) && $SlidingNonce_SlidingNonce_$invariant_holds($this)}

procedure {:inline 1} $SlidingNonce_SlidingNonce_pack($file_id: int, $byte_index: int, $var_idx: int, min_nonce: $Value, nonce_mask: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(min_nonce);
    assume $IsValidU128(nonce_mask);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := min_nonce][1 := nonce_mask], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $SlidingNonce_SlidingNonce_unpack($struct: $Value) returns (min_nonce: $Value, nonce_mask: $Value)
{
    assume is#$Vector($struct);
    min_nonce := $SelectField($struct, $SlidingNonce_SlidingNonce_min_nonce);
    assume $IsValidU64(min_nonce);
    nonce_mask := $SelectField($struct, $SlidingNonce_SlidingNonce_nonce_mask);
    assume $IsValidU128(nonce_mask);
}



// ** functions of module SlidingNonce

procedure {:inline 1} $SlidingNonce_publish_$def(account: $Value) returns ()
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $SlidingNonce_SlidingNonce_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(25, 4140, 0, account); }

    // bytecode translation starts here
    // $t3 := move(account)
    call $t3 := $CopyOrMoveValue(account);

    // $t4 := Signer::address_of($t3)
    call $t4 := $Signer_address_of($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 4224, $abort_code);
      goto Abort;
    }

    // $t5 := exists<SlidingNonce::SlidingNonce>($t4)
    $t5 := $ResourceExists($SlidingNonce_SlidingNonce_$memory, $EmptyTypeValueArray, $t4);

    // $t6 := !($t5)
    call $t6 := $Not($t5);

    // $t7 := 4
    $t7 := $Integer(4);

    // $t8 := Errors::invalid_argument($t7)
    call $t8 := $Errors_invalid_argument($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 4254, $abort_code);
      goto Abort;
    }

    // if ($t6) goto L0 else goto L1
    if (b#$Boolean($t6)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t3)

    // abort($t8)
    if (true) { assume $DebugTrackAbort(25, 4187, i#$Integer($t8)); }
    $abort_code := i#$Integer($t8);
    goto Abort;

    // L0:
L0:

    // $t9 := 0
    $t9 := $Integer(0);

    // $t10 := 0
    $t10 := $Integer(0);

    // $t11 := pack SlidingNonce::SlidingNonce($t9, $t10)
    call $t11 := $SlidingNonce_SlidingNonce_pack(0, 0, 0, $t9, $t10);

    // move_to<SlidingNonce::SlidingNonce>($t11, $t3)
    call $SlidingNonce_SlidingNonce_$memory := $MoveTo($SlidingNonce_SlidingNonce_$memory, $EmptyTypeValueArray, $t11, $t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 4307, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $SlidingNonce_publish_$direct_inter(account: $Value) returns ()
{
    assume is#$Address(account);

    call $SlidingNonce_publish_$def(account);
}


procedure {:inline 1} $SlidingNonce_publish_$direct_intra(account: $Value) returns ()
{
    assume is#$Address(account);

    call $SlidingNonce_publish_$def(account);
}


procedure {:inline 1} $SlidingNonce_publish(account: $Value) returns ()
{
    assume is#$Address(account);

    call $SlidingNonce_publish_$def(account);
}


procedure {:inline 1} $SlidingNonce_publish_nonce_resource_$def(lr_account: $Value, account: $Value) returns ()
{
    // declare local variables
    var new_resource: $Value; // $SlidingNonce_SlidingNonce_type_value()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $SlidingNonce_SlidingNonce_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(25, 4522, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(25, 4522, 1, account); }

    // bytecode translation starts here
    // $t5 := move(lr_account)
    call $t5 := $CopyOrMoveValue(lr_account);

    // $t6 := move(account)
    call $t6 := $CopyOrMoveValue(account);

    // Roles::assert_libra_root($t5)
    call $Roles_assert_libra_root($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 4634, $abort_code);
      goto Abort;
    }

    // $t7 := Signer::address_of($t6)
    call $t7 := $Signer_address_of($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 4816, $abort_code);
      goto Abort;
    }

    // $t8 := exists<SlidingNonce::SlidingNonce>($t7)
    $t8 := $ResourceExists($SlidingNonce_SlidingNonce_$memory, $EmptyTypeValueArray, $t7);

    // $t9 := !($t8)
    call $t9 := $Not($t8);

    // $t10 := 4
    $t10 := $Integer(4);

    // $t11 := Errors::invalid_argument($t10)
    call $t11 := $Errors_invalid_argument($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 4862, $abort_code);
      goto Abort;
    }

    // if ($t9) goto L0 else goto L1
    if (b#$Boolean($t9)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t6)

    // abort($t11)
    if (true) { assume $DebugTrackAbort(25, 4779, i#$Integer($t11)); }
    $abort_code := i#$Integer($t11);
    goto Abort;

    // L0:
L0:

    // $t12 := 0
    $t12 := $Integer(0);

    // $t13 := 0
    $t13 := $Integer(0);

    // $t14 := pack SlidingNonce::SlidingNonce($t12, $t13)
    call $t14 := $SlidingNonce_SlidingNonce_pack(0, 0, 0, $t12, $t13);

    // move_to<SlidingNonce::SlidingNonce>($t14, $t6)
    call $SlidingNonce_SlidingNonce_$memory := $MoveTo($SlidingNonce_SlidingNonce_$memory, $EmptyTypeValueArray, $t14, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 4915, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $SlidingNonce_publish_nonce_resource_$direct_inter(lr_account: $Value, account: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume is#$Address(account);

    call $SlidingNonce_publish_nonce_resource_$def(lr_account, account);
}


procedure {:inline 1} $SlidingNonce_publish_nonce_resource_$direct_intra(lr_account: $Value, account: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume is#$Address(account);

    call $SlidingNonce_publish_nonce_resource_$def(lr_account, account);
}


procedure {:inline 1} $SlidingNonce_publish_nonce_resource(lr_account: $Value, account: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume is#$Address(account);

    call $SlidingNonce_publish_nonce_resource_$def(lr_account, account);
}


procedure {:inline 1} $SlidingNonce_record_nonce_or_abort_$def(account: $Value, seq_nonce: $Value) returns ()
{
    // declare local variables
    var code: $Value; // $IntegerType()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(25, 1422, 0, account); }
    if (true) { assume $DebugTrackLocal(25, 1422, 1, seq_nonce); }

    // bytecode translation starts here
    // $t5 := move(account)
    call $t5 := $CopyOrMoveValue(account);

    // $t6 := move(seq_nonce)
    call $t6 := $CopyOrMoveValue(seq_nonce);

    // code := SlidingNonce::try_record_nonce($t5, $t6)
    call code := $SlidingNonce_try_record_nonce($t5, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 2137, $abort_code);
      goto Abort;
    }

    // $t7 := 0
    $t7 := $Integer(0);

    // $t8 := ==(code, $t7)
    $t8 := $Boolean($IsEqual(code, $t7));

    // $t9 := Errors::invalid_argument(code)
    call $t9 := $Errors_invalid_argument(code);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 1604, $abort_code);
      goto Abort;
    }

    // if ($t8) goto L0 else goto L1
    if (b#$Boolean($t8)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t9)
    if (true) { assume $DebugTrackAbort(25, 1578, i#$Integer($t9)); }
    $abort_code := i#$Integer($t9);
    goto Abort;

    // L0:
L0:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $SlidingNonce_record_nonce_or_abort_$direct_inter(account: $Value, seq_nonce: $Value) returns ()
{
    assume is#$Address(account);

    assume $IsValidU64(seq_nonce);

    call $SlidingNonce_record_nonce_or_abort_$def(account, seq_nonce);
}


procedure {:inline 1} $SlidingNonce_record_nonce_or_abort_$direct_intra(account: $Value, seq_nonce: $Value) returns ()
{
    assume is#$Address(account);

    assume $IsValidU64(seq_nonce);

    call $SlidingNonce_record_nonce_or_abort_$def(account, seq_nonce);
}


procedure {:inline 1} $SlidingNonce_record_nonce_or_abort(account: $Value, seq_nonce: $Value) returns ()
{
    assume is#$Address(account);

    assume $IsValidU64(seq_nonce);

    call $SlidingNonce_record_nonce_or_abort_$def(account, seq_nonce);
}


procedure {:inline 1} $SlidingNonce_try_record_nonce_$def(account: $Value, seq_nonce: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var bit_pos: $Value; // $IntegerType()
    var bit_pos#1740: $Value; // $IntegerType()
    var jump_limit: $Value; // $IntegerType()
    var set: $Value; // $IntegerType()
    var shift: $Value; // $IntegerType()
    var t: $Mutation; // ReferenceType($SlidingNonce_SlidingNonce_type_value())
    var tmp#$8: $Value; // $BooleanType()
    var tmp#$9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $BooleanType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $BooleanType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $IntegerType()
    var $t30: $Value; // $BooleanType()
    var $t31: $Value; // $IntegerType()
    var $t32: $Value; // $IntegerType()
    var $t33: $Value; // $IntegerType()
    var $t34: $Value; // $IntegerType()
    var $t35: $Value; // $BooleanType()
    var $t36: $Value; // $IntegerType()
    var $t37: $Mutation; // ReferenceType($IntegerType())
    var $t38: $Value; // $IntegerType()
    var $t39: $Value; // $IntegerType()
    var $t40: $Value; // $IntegerType()
    var $t41: $Value; // $IntegerType()
    var $t42: $Mutation; // ReferenceType($IntegerType())
    var $t43: $Value; // $IntegerType()
    var $t44: $Value; // $IntegerType()
    var $t45: $Value; // $IntegerType()
    var $t46: $Mutation; // ReferenceType($IntegerType())
    var $t47: $Value; // $IntegerType()
    var $t48: $Value; // $IntegerType()
    var $t49: $Mutation; // ReferenceType($IntegerType())
    var $t50: $Value; // $IntegerType()
    var $t51: $Value; // $IntegerType()
    var $t52: $Value; // $IntegerType()
    var $t53: $Value; // $IntegerType()
    var $t54: $Value; // $IntegerType()
    var $t55: $Value; // $IntegerType()
    var $t56: $Value; // $BooleanType()
    var $t57: $Value; // $IntegerType()
    var $t58: $Value; // $IntegerType()
    var $t59: $Value; // $IntegerType()
    var $t60: $Mutation; // ReferenceType($IntegerType())
    var $t61: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(25, 2126, 0, account); }
    if (true) { assume $DebugTrackLocal(25, 2126, 1, seq_nonce); }

    // bytecode translation starts here
    // $t10 := move(account)
    call $t10 := $CopyOrMoveValue(account);

    // $t11 := move(seq_nonce)
    call $t11 := $CopyOrMoveValue(seq_nonce);

    // $t12 := 0
    $t12 := $Integer(0);

    // $t13 := ==($t11, $t12)
    $t13 := $Boolean($IsEqual($t11, $t12));

    // if ($t13) goto L0 else goto L1
    if (b#$Boolean($t13)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // destroy($t10)

    // $t14 := 0
    $t14 := $Integer(0);

    // return $t14
    $ret0 := $t14;
    if (true) { assume $DebugTrackLocal(25, 2259, 62, $ret0); }
    return;

    // L2:
L2:

    // $t15 := Signer::address_of($t10)
    call $t15 := $Signer_address_of($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 2323, $abort_code);
      goto Abort;
    }

    // $t16 := exists<SlidingNonce::SlidingNonce>($t15)
    $t16 := $ResourceExists($SlidingNonce_SlidingNonce_$memory, $EmptyTypeValueArray, $t15);

    // $t17 := 0
    $t17 := $Integer(0);

    // $t18 := Errors::not_published($t17)
    call $t18 := $Errors_not_published($t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 2353, $abort_code);
      goto Abort;
    }

    // if ($t16) goto L3 else goto L4
    if (b#$Boolean($t16)) { goto L3; } else { goto L4; }

    // L4:
L4:

    // destroy($t10)

    // abort($t18)
    if (true) { assume $DebugTrackAbort(25, 2287, i#$Integer($t18)); }
    $abort_code := i#$Integer($t18);
    goto Abort;

    // L3:
L3:

    // $t19 := Signer::address_of($t10)
    call $t19 := $Signer_address_of($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 2441, $abort_code);
      goto Abort;
    }

    // t := borrow_global<SlidingNonce::SlidingNonce>($t19)
    call t := $BorrowGlobal($SlidingNonce_SlidingNonce_$memory, $t19, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 2401, $abort_code);
      goto Abort;
    }

    // unpack_ref(t)

    // $t20 := get_field<SlidingNonce::SlidingNonce>.min_nonce(t)
    call $t20 := $GetFieldFromReference(t, $SlidingNonce_SlidingNonce_min_nonce);

    // $t21 := >($t20, $t11)
    call $t21 := $Gt($t20, $t11);

    // if ($t21) goto L5 else goto L6
    if (b#$Boolean($t21)) { goto L5; } else { goto L6; }

    // L6:
L6:

    // goto L7
    goto L7;

    // L5:
L5:

    // destroy(t)

    // pack_ref(t)

    // $t22 := 1
    $t22 := $Integer(1);

    // return $t22
    $ret0 := $t22;
    if (true) { assume $DebugTrackLocal(25, 2514, 62, $ret0); }
    return;

    // L7:
L7:

    // $t23 := get_field<SlidingNonce::SlidingNonce>.min_nonce(t)
    call $t23 := $GetFieldFromReference(t, $SlidingNonce_SlidingNonce_min_nonce);

    // $t24 := 10000
    $t24 := $Integer(10000);

    // $t25 := +($t23, $t24)
    call $t25 := $AddU64($t23, $t24);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 2675, $abort_code);
      goto Abort;
    }

    // $t26 := <=($t25, $t11)
    call $t26 := $Le($t25, $t11);

    // if ($t26) goto L8 else goto L9
    if (b#$Boolean($t26)) { goto L8; } else { goto L9; }

    // L9:
L9:

    // goto L10
    goto L10;

    // L8:
L8:

    // destroy(t)

    // pack_ref(t)

    // $t27 := 2
    $t27 := $Integer(2);

    // return $t27
    $ret0 := $t27;
    if (true) { assume $DebugTrackLocal(25, 2716, 62, $ret0); }
    return;

    // L10:
L10:

    // $t28 := get_field<SlidingNonce::SlidingNonce>.min_nonce(t)
    call $t28 := $GetFieldFromReference(t, $SlidingNonce_SlidingNonce_min_nonce);

    // bit_pos := -($t11, $t28)
    call bit_pos := $Sub($t11, $t28);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 2781, $abort_code);
      goto Abort;
    }
    if (true) { assume $DebugTrackLocal(25, 2781, 2, bit_pos); }

    // $t29 := 128
    $t29 := $Integer(128);

    // $t30 := >=(bit_pos, $t29)
    call $t30 := $Ge(bit_pos, $t29);

    // if ($t30) goto L11 else goto L12
    if (b#$Boolean($t30)) { goto L11; } else { goto L12; }

    // L12:
L12:

    // goto L13
    goto L13;

    // L11:
L11:

    // $t31 := 128
    $t31 := $Integer(128);

    // $t32 := -(bit_pos, $t31)
    call $t32 := $Sub(bit_pos, $t31);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 2871, $abort_code);
      goto Abort;
    }

    // $t33 := 1
    $t33 := $Integer(1);

    // shift := +($t32, $t33)
    call shift := $AddU64($t32, $t33);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 2889, $abort_code);
      goto Abort;
    }
    if (true) { assume $DebugTrackLocal(25, 2889, 6, shift); }

    // $t34 := 128
    $t34 := $Integer(128);

    // $t35 := >=(shift, $t34)
    call $t35 := $Ge(shift, $t34);

    // if ($t35) goto L14 else goto L15
    if (b#$Boolean($t35)) { goto L14; } else { goto L15; }

    // L15:
L15:

    // goto L16
    goto L16;

    // L14:
L14:

    // $t36 := 0
    $t36 := $Integer(0);

    // $t37 := borrow_field<SlidingNonce::SlidingNonce>.nonce_mask(t)
    call $t37 := $BorrowField(t, $SlidingNonce_SlidingNonce_nonce_mask);

    // unpack_ref($t37)

    // write_ref($t37, $t36)
    call $t37 := $WriteRef($t37, $t36);
    if (true) { assume $DebugTrackLocal(25, 2954, 7, $Dereference(t)); }

    // pack_ref($t37)

    // write_back[Reference(t)]($t37)
    call t := $WritebackToReference($t37, t);

    // $t38 := 1
    $t38 := $Integer(1);

    // $t39 := +($t11, $t38)
    call $t39 := $AddU64($t11, $t38);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 3012, $abort_code);
      goto Abort;
    }

    // $t40 := 128
    $t40 := $Integer(128);

    // $t41 := -($t39, $t40)
    call $t41 := $Sub($t39, $t40);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 3016, $abort_code);
      goto Abort;
    }

    // $t42 := borrow_field<SlidingNonce::SlidingNonce>.min_nonce(t)
    call $t42 := $BorrowField(t, $SlidingNonce_SlidingNonce_min_nonce);

    // unpack_ref($t42)

    // write_ref($t42, $t41)
    call $t42 := $WriteRef($t42, $t41);
    if (true) { assume $DebugTrackLocal(25, 2988, 7, $Dereference(t)); }

    // pack_ref($t42)

    // write_back[Reference(t)]($t42)
    call t := $WritebackToReference($t42, t);

    // goto L13
    goto L13;

    // L16:
L16:

    // $t43 := get_field<SlidingNonce::SlidingNonce>.nonce_mask(t)
    call $t43 := $GetFieldFromReference(t, $SlidingNonce_SlidingNonce_nonce_mask);

    // $t44 := (u8)(shift)
    call $t44 := $CastU8(shift);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 3103, $abort_code);
      goto Abort;
    }

    // $t45 := <<($t43, $t44)
    call $t45 := $Shr($t43, $t44);

    // $t46 := borrow_field<SlidingNonce::SlidingNonce>.nonce_mask(t)
    call $t46 := $BorrowField(t, $SlidingNonce_SlidingNonce_nonce_mask);

    // unpack_ref($t46)

    // write_ref($t46, $t45)
    call $t46 := $WriteRef($t46, $t45);
    if (true) { assume $DebugTrackLocal(25, 3072, 7, $Dereference(t)); }

    // pack_ref($t46)

    // write_back[Reference(t)]($t46)
    call t := $WritebackToReference($t46, t);

    // $t47 := get_field<SlidingNonce::SlidingNonce>.min_nonce(t)
    call $t47 := $GetFieldFromReference(t, $SlidingNonce_SlidingNonce_min_nonce);

    // $t48 := +($t47, shift)
    call $t48 := $AddU64($t47, shift);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 3160, $abort_code);
      goto Abort;
    }

    // $t49 := borrow_field<SlidingNonce::SlidingNonce>.min_nonce(t)
    call $t49 := $BorrowField(t, $SlidingNonce_SlidingNonce_min_nonce);

    // unpack_ref($t49)

    // write_ref($t49, $t48)
    call $t49 := $WriteRef($t49, $t48);
    if (true) { assume $DebugTrackLocal(25, 3134, 7, $Dereference(t)); }

    // pack_ref($t49)

    // write_back[Reference(t)]($t49)
    call t := $WritebackToReference($t49, t);

    // goto L13
    goto L13;

    // L13:
L13:

    // $t50 := get_field<SlidingNonce::SlidingNonce>.min_nonce(t)
    call $t50 := $GetFieldFromReference(t, $SlidingNonce_SlidingNonce_min_nonce);

    // bit_pos#1740 := -($t11, $t50)
    call bit_pos#1740 := $Sub($t11, $t50);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 3226, $abort_code);
      goto Abort;
    }
    if (true) { assume $DebugTrackLocal(25, 3226, 3, bit_pos#1740); }

    // $t51 := 1
    $t51 := $Integer(1);

    // $t52 := (u8)(bit_pos#1740)
    call $t52 := $CastU8(bit_pos#1740);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 3268, $abort_code);
      goto Abort;
    }

    // set := <<($t51, $t52)
    call set := $Shl($t51, $t52);
    if (true) { assume $DebugTrackLocal(25, 3265, 5, set); }

    // $t53 := get_field<SlidingNonce::SlidingNonce>.nonce_mask(t)
    call $t53 := $GetFieldFromReference(t, $SlidingNonce_SlidingNonce_nonce_mask);

    // $t54 := &($t53, set)
    // bit operation not supported: Call(AttrId(134), [54], BitAnd, [53, 5])
    assert false;

    // $t55 := 0
    $t55 := $Integer(0);

    // $t56 := !=($t54, $t55)
    $t56 := $Boolean(!$IsEqual($t54, $t55));

    // if ($t56) goto L17 else goto L18
    if (b#$Boolean($t56)) { goto L17; } else { goto L18; }

    // L18:
L18:

    // goto L19
    goto L19;

    // L17:
L17:

    // destroy(t)

    // pack_ref(t)

    // write_back[SlidingNonce::SlidingNonce](t)
    call $SlidingNonce_SlidingNonce_$memory := $WritebackToGlobal($SlidingNonce_SlidingNonce_$memory, t);

    // $t57 := 3
    $t57 := $Integer(3);

    // return $t57
    $ret0 := $t57;
    if (true) { assume $DebugTrackLocal(25, 3336, 62, $ret0); }
    return;

    // L19:
L19:

    // $t58 := get_field<SlidingNonce::SlidingNonce>.nonce_mask(t)
    call $t58 := $GetFieldFromReference(t, $SlidingNonce_SlidingNonce_nonce_mask);

    // $t59 := |($t58, set)
    // bit operation not supported: Call(AttrId(150), [59], BitOr, [58, 5])
    assert false;

    // $t60 := borrow_field<SlidingNonce::SlidingNonce>.nonce_mask(t)
    call $t60 := $BorrowField(t, $SlidingNonce_SlidingNonce_nonce_mask);

    // unpack_ref($t60)

    // write_ref($t60, $t59)
    call $t60 := $WriteRef($t60, $t59);
    if (true) { assume $DebugTrackLocal(25, 3386, 7, $Dereference(t)); }

    // pack_ref($t60)

    // write_back[Reference(t)]($t60)
    call t := $WritebackToReference($t60, t);

    // pack_ref(t)

    // write_back[SlidingNonce::SlidingNonce](t)
    call $SlidingNonce_SlidingNonce_$memory := $WritebackToGlobal($SlidingNonce_SlidingNonce_$memory, t);

    // $t61 := 0
    $t61 := $Integer(0);

    // return $t61
    $ret0 := $t61;
    if (true) { assume $DebugTrackLocal(25, 3429, 62, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $SlidingNonce_try_record_nonce_$direct_inter(account: $Value, seq_nonce: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($SlidingNonce_SlidingNonce_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account)))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($SlidingNonce_SlidingNonce_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account)))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($SlidingNonce_SlidingNonce_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account)))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $SlidingNonce_spec_try_record_nonce(account, seq_nonce)))));
ensures $IsValidU64($ret0);
modifies $SlidingNonce_SlidingNonce_$memory;

procedure {:inline 1} $SlidingNonce_try_record_nonce_$direct_intra(account: $Value, seq_nonce: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($SlidingNonce_SlidingNonce_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account)))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($SlidingNonce_SlidingNonce_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account)))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($SlidingNonce_SlidingNonce_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account)))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $SlidingNonce_spec_try_record_nonce(account, seq_nonce)))));
ensures $IsValidU64($ret0);
modifies $SlidingNonce_SlidingNonce_$memory;

procedure {:inline 1} $SlidingNonce_try_record_nonce(account: $Value, seq_nonce: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($SlidingNonce_SlidingNonce_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account)))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($SlidingNonce_SlidingNonce_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account)))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($SlidingNonce_SlidingNonce_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(account)))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $SlidingNonce_spec_try_record_nonce(account, seq_nonce)))));
ensures $IsValidU64($ret0);
modifies $SlidingNonce_SlidingNonce_$memory;



// ** spec vars of module LibraTransactionPublishingOption



// ** spec funs of module LibraTransactionPublishingOption

function {:inline} $LibraTransactionPublishingOption_spec_is_script_allowed($Roles_RoleId_$memory: $Memory, $LibraConfig_LibraConfig_$memory: $Memory, account: $Value, hash: $Value): $Value {
    (var publish_option := $LibraConfig_spec_get_config($LibraConfig_LibraConfig_$memory, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value()); $Boolean(b#$Boolean($Boolean(b#$Boolean($Vector_$is_empty($Vector_type_value($IntegerType()), $SelectField(publish_option, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_script_allow_list))) || b#$Boolean($Vector_spec_contains($Vector_type_value($IntegerType()), $SelectField(publish_option, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_script_allow_list), hash)))) || b#$Boolean($Roles_$has_libra_root_role($Roles_RoleId_$memory, account))))
}

function {:inline} $LibraTransactionPublishingOption_spec_is_module_allowed($Roles_RoleId_$memory: $Memory, $LibraConfig_LibraConfig_$memory: $Memory, account: $Value): $Value {
    (var publish_option := $LibraConfig_spec_get_config($LibraConfig_LibraConfig_$memory, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value()); $Boolean(b#$Boolean($SelectField(publish_option, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_module_publishing_allowed)) || b#$Boolean($Roles_$has_libra_root_role($Roles_RoleId_$memory, account))))
}



// ** structs of module LibraTransactionPublishingOption

const unique $LibraTransactionPublishingOption_LibraTransactionPublishingOption: $TypeName;
const $LibraTransactionPublishingOption_LibraTransactionPublishingOption_script_allow_list: $FieldName;
axiom $LibraTransactionPublishingOption_LibraTransactionPublishingOption_script_allow_list == 0;
const $LibraTransactionPublishingOption_LibraTransactionPublishingOption_module_publishing_allowed: $FieldName;
axiom $LibraTransactionPublishingOption_LibraTransactionPublishingOption_module_publishing_allowed == 1;
function $LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value(): $TypeValue {
    $StructType($LibraTransactionPublishingOption_LibraTransactionPublishingOption, $EmptyTypeValueArray)
}
var $LibraTransactionPublishingOption_LibraTransactionPublishingOption_$memory: $Memory;
var $LibraTransactionPublishingOption_LibraTransactionPublishingOption_$memory_$old: $Memory;
function {:inline} $LibraTransactionPublishingOption_LibraTransactionPublishingOption_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 2
      && $Vector_$is_well_formed($SelectField($this, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_script_allow_list)) && (forall $$0: int :: {$select_vector($SelectField($this, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_script_allow_list),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_script_allow_list)) ==> $Vector_$is_well_formed($select_vector($SelectField($this, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_script_allow_list),$$0)) && (forall $$1: int :: {$select_vector($select_vector($SelectField($this, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_script_allow_list),$$0),$$1)} $$1 >= 0 && $$1 < $vlen($select_vector($SelectField($this, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_script_allow_list),$$0)) ==> $IsValidU8($select_vector($select_vector($SelectField($this, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_script_allow_list),$$0),$$1))))
      && is#$Boolean($SelectField($this, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_module_publishing_allowed))
}
function {:inline} $LibraTransactionPublishingOption_LibraTransactionPublishingOption_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $LibraTransactionPublishingOption_LibraTransactionPublishingOption_$is_well_formed($this: $Value): bool {
    $LibraTransactionPublishingOption_LibraTransactionPublishingOption_$is_well_typed($this) && $LibraTransactionPublishingOption_LibraTransactionPublishingOption_$invariant_holds($this)}

procedure {:inline 1} $LibraTransactionPublishingOption_LibraTransactionPublishingOption_pack($file_id: int, $byte_index: int, $var_idx: int, script_allow_list: $Value, module_publishing_allowed: $Value) returns ($struct: $Value)
{
    assume $Vector_$is_well_formed(script_allow_list) && (forall $$0: int :: {$select_vector(script_allow_list,$$0)} $$0 >= 0 && $$0 < $vlen(script_allow_list) ==> $Vector_$is_well_formed($select_vector(script_allow_list,$$0)) && (forall $$1: int :: {$select_vector($select_vector(script_allow_list,$$0),$$1)} $$1 >= 0 && $$1 < $vlen($select_vector(script_allow_list,$$0)) ==> $IsValidU8($select_vector($select_vector(script_allow_list,$$0),$$1))));
    assume is#$Boolean(module_publishing_allowed);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := script_allow_list][1 := module_publishing_allowed], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraTransactionPublishingOption_LibraTransactionPublishingOption_unpack($struct: $Value) returns (script_allow_list: $Value, module_publishing_allowed: $Value)
{
    assume is#$Vector($struct);
    script_allow_list := $SelectField($struct, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_script_allow_list);
    assume $Vector_$is_well_formed(script_allow_list) && (forall $$0: int :: {$select_vector(script_allow_list,$$0)} $$0 >= 0 && $$0 < $vlen(script_allow_list) ==> $Vector_$is_well_formed($select_vector(script_allow_list,$$0)) && (forall $$1: int :: {$select_vector($select_vector(script_allow_list,$$0),$$1)} $$1 >= 0 && $$1 < $vlen($select_vector(script_allow_list,$$0)) ==> $IsValidU8($select_vector($select_vector(script_allow_list,$$0),$$1))));
    module_publishing_allowed := $SelectField($struct, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_module_publishing_allowed);
    assume is#$Boolean(module_publishing_allowed);
}



// ** functions of module LibraTransactionPublishingOption

procedure {:inline 1} $LibraTransactionPublishingOption_initialize_$def(lr_account: $Value, script_allow_list: $Value, module_publishing_allowed: $Value) returns ()
{
    // declare local variables
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $Vector_type_value($Vector_type_value($IntegerType()))
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(19, 1186, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(19, 1186, 1, script_allow_list); }
    if (true) { assume $DebugTrackLocal(19, 1186, 2, module_publishing_allowed); }

    // bytecode translation starts here
    // $t3 := move(lr_account)
    call $t3 := $CopyOrMoveValue(lr_account);

    // $t4 := move(script_allow_list)
    call $t4 := $CopyOrMoveValue(script_allow_list);

    // $t5 := move(module_publishing_allowed)
    call $t5 := $CopyOrMoveValue(module_publishing_allowed);

    // LibraTimestamp::assert_genesis()
    call $LibraTimestamp_assert_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 1358, $abort_code);
      goto Abort;
    }

    // Roles::assert_libra_root($t3)
    call $Roles_assert_libra_root($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 1391, $abort_code);
      goto Abort;
    }

    // $t6 := pack LibraTransactionPublishingOption::LibraTransactionPublishingOption($t4, $t5)
    call $t6 := $LibraTransactionPublishingOption_LibraTransactionPublishingOption_pack(0, 0, 0, $t4, $t5);

    // LibraConfig::publish_new_config<LibraTransactionPublishingOption::LibraTransactionPublishingOption>($t3, $t6)
    call $LibraConfig_publish_new_config($LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value(), $t3, $t6, $ConstMemoryDomain(true), $ConstMemoryDomain(true));
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 1444, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraTransactionPublishingOption_initialize_$direct_inter(lr_account: $Value, script_allow_list: $Value, module_publishing_allowed: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(script_allow_list) && (forall $$0: int :: {$select_vector(script_allow_list,$$0)} $$0 >= 0 && $$0 < $vlen(script_allow_list) ==> $Vector_$is_well_formed($select_vector(script_allow_list,$$0)) && (forall $$1: int :: {$select_vector($select_vector(script_allow_list,$$0),$$1)} $$1 >= 0 && $$1 < $vlen($select_vector(script_allow_list,$$0)) ==> $IsValidU8($select_vector($select_vector(script_allow_list,$$0),$$1))));

    assume is#$Boolean(module_publishing_allowed);

    call $LibraTransactionPublishingOption_initialize_$def(lr_account, script_allow_list, module_publishing_allowed);
}


procedure {:inline 1} $LibraTransactionPublishingOption_initialize_$direct_intra(lr_account: $Value, script_allow_list: $Value, module_publishing_allowed: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(script_allow_list) && (forall $$0: int :: {$select_vector(script_allow_list,$$0)} $$0 >= 0 && $$0 < $vlen(script_allow_list) ==> $Vector_$is_well_formed($select_vector(script_allow_list,$$0)) && (forall $$1: int :: {$select_vector($select_vector(script_allow_list,$$0),$$1)} $$1 >= 0 && $$1 < $vlen($select_vector(script_allow_list,$$0)) ==> $IsValidU8($select_vector($select_vector(script_allow_list,$$0),$$1))));

    assume is#$Boolean(module_publishing_allowed);

    call $LibraTransactionPublishingOption_initialize_$def(lr_account, script_allow_list, module_publishing_allowed);
}


procedure {:inline 1} $LibraTransactionPublishingOption_initialize(lr_account: $Value, script_allow_list: $Value, module_publishing_allowed: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(script_allow_list) && (forall $$0: int :: {$select_vector(script_allow_list,$$0)} $$0 >= 0 && $$0 < $vlen(script_allow_list) ==> $Vector_$is_well_formed($select_vector(script_allow_list,$$0)) && (forall $$1: int :: {$select_vector($select_vector(script_allow_list,$$0),$$1)} $$1 >= 0 && $$1 < $vlen($select_vector(script_allow_list,$$0)) ==> $IsValidU8($select_vector($select_vector(script_allow_list,$$0),$$1))));

    assume is#$Boolean(module_publishing_allowed);

    call $LibraTransactionPublishingOption_initialize_$def(lr_account, script_allow_list, module_publishing_allowed);
}


procedure {:inline 1} $LibraTransactionPublishingOption_add_to_script_allow_list_$def(lr_account: $Value, new_hash: $Value) returns ()
{
    // declare local variables
    var publish_option: $Value; // $LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $Vector_type_value($IntegerType())
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $Vector_type_value($Vector_type_value($IntegerType()))
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Mutation; // ReferenceType($LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value())
    var $t17: $Mutation; // ReferenceType($Vector_type_value($Vector_type_value($IntegerType())))
    var $t18: $Value; // $Vector_type_value($Vector_type_value($IntegerType()))

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(19, 3510, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(19, 3510, 1, new_hash); }

    // bytecode translation starts here
    // $t5 := move(lr_account)
    call $t5 := $CopyOrMoveValue(lr_account);

    // $t6 := move(new_hash)
    call $t6 := $CopyOrMoveValue(new_hash);

    // Roles::assert_libra_root($t5)
    call $Roles_assert_libra_root($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 3606, $abort_code);
      goto Abort;
    }

    // $t7 := Vector::length<u8>($t6)
    call $t7 := $Vector_length($IntegerType(), $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 3661, $abort_code);
      goto Abort;
    }

    // $t8 := 32
    $t8 := $Integer(32);

    // $t9 := ==($t7, $t8)
    $t9 := $Boolean($IsEqual($t7, $t8));

    // $t10 := 0
    $t10 := $Integer(0);

    // $t11 := Errors::invalid_argument($t10)
    call $t11 := $Errors_invalid_argument($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 3710, $abort_code);
      goto Abort;
    }

    // if ($t9) goto L0 else goto L1
    if (b#$Boolean($t9)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t5)

    // abort($t11)
    if (true) { assume $DebugTrackAbort(19, 3646, i#$Integer($t11)); }
    $abort_code := i#$Integer($t11);
    goto Abort;

    // L0:
L0:

    // publish_option := LibraConfig::get<LibraTransactionPublishingOption::LibraTransactionPublishingOption>()
    call publish_option := $LibraConfig_get($LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 3794, $abort_code);
      goto Abort;
    }

    // $t12 := get_field<LibraTransactionPublishingOption::LibraTransactionPublishingOption>.script_allow_list(publish_option)
    call $t12 := $GetFieldFromValue(publish_option, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_script_allow_list);

    // $t13 := Vector::contains<vector<u8>>($t12, $t6)
    call $t13 := $Vector_contains($Vector_type_value($IntegerType()), $t12, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 3855, $abort_code);
      goto Abort;
    }

    // if ($t13) goto L2 else goto L3
    if (b#$Boolean($t13)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // goto L4
    goto L4;

    // L2:
L2:

    // destroy($t5)

    // $t14 := 1
    $t14 := $Integer(1);

    // $t15 := Errors::invalid_argument($t14)
    call $t15 := $Errors_invalid_argument($t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 3941, $abort_code);
      goto Abort;
    }

    // abort($t15)
    if (true) { assume $DebugTrackAbort(19, 3927, i#$Integer($t15)); }
    $abort_code := i#$Integer($t15);
    goto Abort;

    // L4:
L4:

    // $t16 := borrow_local(publish_option)
    call $t16 := $BorrowLoc(2, publish_option);

    // unpack_ref($t16)

    // $t17 := borrow_field<LibraTransactionPublishingOption::LibraTransactionPublishingOption>.script_allow_list($t16)
    call $t17 := $BorrowField($t16, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_script_allow_list);

    // unpack_ref($t17)

    // $t18 := read_ref($t17)
    call $t18 := $ReadRef($t17);

    // $t18 := Vector::push_back<vector<u8>>($t18, $t6)
    call $t18 := $Vector_push_back($Vector_type_value($IntegerType()), $t18, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 4021, $abort_code);
      goto Abort;
    }

    // write_ref($t17, $t18)
    call $t17 := $WriteRef($t17, $t18);

    // pack_ref($t17)

    // write_back[Reference($t16)]($t17)
    call $t16 := $WritebackToReference($t17, $t16);

    // pack_ref($t16)

    // write_back[LocalRoot(publish_option)]($t16)
    call publish_option := $WritebackToValue($t16, 2, publish_option);

    // LibraConfig::set<LibraTransactionPublishingOption::LibraTransactionPublishingOption>($t5, publish_option)
    call $LibraConfig_set($LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value(), $t5, publish_option);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 4103, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraTransactionPublishingOption_add_to_script_allow_list_$direct_inter(lr_account: $Value, new_hash: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(new_hash) && (forall $$0: int :: {$select_vector(new_hash,$$0)} $$0 >= 0 && $$0 < $vlen(new_hash) ==> $IsValidU8($select_vector(new_hash,$$0)));

    call $LibraTransactionPublishingOption_add_to_script_allow_list_$def(lr_account, new_hash);
}


procedure {:inline 1} $LibraTransactionPublishingOption_add_to_script_allow_list_$direct_intra(lr_account: $Value, new_hash: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(new_hash) && (forall $$0: int :: {$select_vector(new_hash,$$0)} $$0 >= 0 && $$0 < $vlen(new_hash) ==> $IsValidU8($select_vector(new_hash,$$0)));

    call $LibraTransactionPublishingOption_add_to_script_allow_list_$def(lr_account, new_hash);
}


procedure {:inline 1} $LibraTransactionPublishingOption_add_to_script_allow_list(lr_account: $Value, new_hash: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(new_hash) && (forall $$0: int :: {$select_vector(new_hash,$$0)} $$0 >= 0 && $$0 < $vlen(new_hash) ==> $IsValidU8($select_vector(new_hash,$$0)));

    call $LibraTransactionPublishingOption_add_to_script_allow_list_$def(lr_account, new_hash);
}


procedure {:inline 1} $LibraTransactionPublishingOption_is_module_allowed_$def(account: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var publish_option: $Value; // $LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value()
    var tmp#$2: $Value; // $BooleanType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(19, 3081, 0, account); }

    // bytecode translation starts here
    // $t3 := move(account)
    call $t3 := $CopyOrMoveValue(account);

    // publish_option := LibraConfig::get<LibraTransactionPublishingOption::LibraTransactionPublishingOption>()
    call publish_option := $LibraConfig_get($LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 3178, $abort_code);
      goto Abort;
    }

    // $t4 := get_field<LibraTransactionPublishingOption::LibraTransactionPublishingOption>.module_publishing_allowed(publish_option)
    call $t4 := $GetFieldFromValue(publish_option, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_module_publishing_allowed);

    // if ($t4) goto L0 else goto L1
    if (b#$Boolean($t4)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // destroy($t3)

    // $t5 := true
    $t5 := $Boolean(true);

    // tmp#$2 := $t5
    call tmp#$2 := $CopyOrMoveValue($t5);
    if (true) { assume $DebugTrackLocal(19, 3228, 2, tmp#$2); }

    // goto L3
    goto L3;

    // L2:
L2:

    // tmp#$2 := Roles::has_libra_root_role($t3)
    call tmp#$2 := $Roles_has_libra_root_role($t3);
    if ($abort_flag) {
      goto Abort;
    }

    // goto L3
    goto L3;

    // L3:
L3:

    // return tmp#$2
    $ret0 := tmp#$2;
    if (true) { assume $DebugTrackLocal(19, 3228, 6, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraTransactionPublishingOption_is_module_allowed_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $LibraTransactionPublishingOption_is_module_allowed_$def(account);
}


procedure {:inline 1} $LibraTransactionPublishingOption_is_module_allowed_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $LibraTransactionPublishingOption_is_module_allowed_$def(account);
}


procedure {:inline 1} $LibraTransactionPublishingOption_is_module_allowed(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $LibraTransactionPublishingOption_is_module_allowed_$def(account);
}


procedure {:inline 1} $LibraTransactionPublishingOption_is_script_allowed_$def(account: $Value, hash: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var publish_option: $Value; // $LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $BooleanType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $Vector_type_value($IntegerType())
    var $t7: $Value; // $Vector_type_value($Vector_type_value($IntegerType()))
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $Vector_type_value($Vector_type_value($IntegerType()))
    var $t11: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(19, 2239, 0, account); }
    if (true) { assume $DebugTrackLocal(19, 2239, 1, hash); }

    // bytecode translation starts here
    // $t5 := move(account)
    call $t5 := $CopyOrMoveValue(account);

    // $t6 := move(hash)
    call $t6 := $CopyOrMoveValue(hash);

    // publish_option := LibraConfig::get<LibraTransactionPublishingOption::LibraTransactionPublishingOption>()
    call publish_option := $LibraConfig_get($LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 2355, $abort_code);
      goto Abort;
    }

    // $t7 := get_field<LibraTransactionPublishingOption::LibraTransactionPublishingOption>.script_allow_list(publish_option)
    call $t7 := $GetFieldFromValue(publish_option, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_script_allow_list);

    // $t8 := Vector::is_empty<vector<u8>>($t7)
    call $t8 := $Vector_is_empty($Vector_type_value($IntegerType()), $t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 2413, $abort_code);
      goto Abort;
    }

    // if ($t8) goto L0 else goto L1
    if (b#$Boolean($t8)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // destroy($t6)

    // $t9 := true
    $t9 := $Boolean(true);

    // tmp#$3 := $t9
    call tmp#$3 := $CopyOrMoveValue($t9);
    if (true) { assume $DebugTrackLocal(19, 2405, 3, tmp#$3); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t10 := get_field<LibraTransactionPublishingOption::LibraTransactionPublishingOption>.script_allow_list(publish_option)
    call $t10 := $GetFieldFromValue(publish_option, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_script_allow_list);

    // tmp#$3 := Vector::contains<vector<u8>>($t10, $t6)
    call tmp#$3 := $Vector_contains($Vector_type_value($IntegerType()), $t10, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 2480, $abort_code);
      goto Abort;
    }

    // goto L3
    goto L3;

    // L3:
L3:

    // if (tmp#$3) goto L4 else goto L5
    if (b#$Boolean(tmp#$3)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // goto L6
    goto L6;

    // L4:
L4:

    // destroy($t5)

    // $t11 := true
    $t11 := $Boolean(true);

    // tmp#$4 := $t11
    call tmp#$4 := $CopyOrMoveValue($t11);
    if (true) { assume $DebugTrackLocal(19, 2405, 4, tmp#$4); }

    // goto L7
    goto L7;

    // L6:
L6:

    // tmp#$4 := Roles::has_libra_root_role($t5)
    call tmp#$4 := $Roles_has_libra_root_role($t5);
    if ($abort_flag) {
      goto Abort;
    }

    // goto L7
    goto L7;

    // L7:
L7:

    // return tmp#$4
    $ret0 := tmp#$4;
    if (true) { assume $DebugTrackLocal(19, 2405, 12, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraTransactionPublishingOption_is_script_allowed_$direct_inter(account: $Value, hash: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    assume $Vector_$is_well_formed(hash) && (forall $$0: int :: {$select_vector(hash,$$0)} $$0 >= 0 && $$0 < $vlen(hash) ==> $IsValidU8($select_vector(hash,$$0)));

    call $ret0 := $LibraTransactionPublishingOption_is_script_allowed_$def(account, hash);
}


procedure {:inline 1} $LibraTransactionPublishingOption_is_script_allowed_$direct_intra(account: $Value, hash: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    assume $Vector_$is_well_formed(hash) && (forall $$0: int :: {$select_vector(hash,$$0)} $$0 >= 0 && $$0 < $vlen(hash) ==> $IsValidU8($select_vector(hash,$$0)));

    call $ret0 := $LibraTransactionPublishingOption_is_script_allowed_$def(account, hash);
}


procedure {:inline 1} $LibraTransactionPublishingOption_is_script_allowed(account: $Value, hash: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    assume $Vector_$is_well_formed(hash) && (forall $$0: int :: {$select_vector(hash,$$0)} $$0 >= 0 && $$0 < $vlen(hash) ==> $IsValidU8($select_vector(hash,$$0)));

    call $ret0 := $LibraTransactionPublishingOption_is_script_allowed_$def(account, hash);
}


procedure {:inline 1} $LibraTransactionPublishingOption_set_open_module_$def(lr_account: $Value, open_module: $Value) returns ()
{
    // declare local variables
    var publish_option: $Value; // $LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Mutation; // ReferenceType($LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value())
    var $t6: $Mutation; // ReferenceType($BooleanType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(19, 5477, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(19, 5477, 1, open_module); }

    // bytecode translation starts here
    // $t3 := move(lr_account)
    call $t3 := $CopyOrMoveValue(lr_account);

    // $t4 := move(open_module)
    call $t4 := $CopyOrMoveValue(open_module);

    // Roles::assert_libra_root($t3)
    call $Roles_assert_libra_root($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 5561, $abort_code);
      goto Abort;
    }

    // publish_option := LibraConfig::get<LibraTransactionPublishingOption::LibraTransactionPublishingOption>()
    call publish_option := $LibraConfig_get($LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 5635, $abort_code);
      goto Abort;
    }

    // $t5 := borrow_local(publish_option)
    call $t5 := $BorrowLoc(2, publish_option);

    // unpack_ref($t5)

    // $t6 := borrow_field<LibraTransactionPublishingOption::LibraTransactionPublishingOption>.module_publishing_allowed($t5)
    call $t6 := $BorrowField($t5, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_module_publishing_allowed);

    // unpack_ref($t6)

    // write_ref($t6, $t4)
    call $t6 := $WriteRef($t6, $t4);

    // pack_ref($t6)

    // write_back[Reference($t5)]($t6)
    call $t5 := $WritebackToReference($t6, $t5);

    // pack_ref($t5)

    // write_back[LocalRoot(publish_option)]($t5)
    call publish_option := $WritebackToValue($t5, 2, publish_option);

    // LibraConfig::set<LibraTransactionPublishingOption::LibraTransactionPublishingOption>($t3, publish_option)
    call $LibraConfig_set($LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value(), $t3, publish_option);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 5762, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraTransactionPublishingOption_set_open_module_$direct_inter(lr_account: $Value, open_module: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume is#$Boolean(open_module);

    call $LibraTransactionPublishingOption_set_open_module_$def(lr_account, open_module);
}


procedure {:inline 1} $LibraTransactionPublishingOption_set_open_module_$direct_intra(lr_account: $Value, open_module: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume is#$Boolean(open_module);

    call $LibraTransactionPublishingOption_set_open_module_$def(lr_account, open_module);
}


procedure {:inline 1} $LibraTransactionPublishingOption_set_open_module(lr_account: $Value, open_module: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume is#$Boolean(open_module);

    call $LibraTransactionPublishingOption_set_open_module_$def(lr_account, open_module);
}


procedure {:inline 1} $LibraTransactionPublishingOption_set_open_script_$def(lr_account: $Value) returns ()
{
    // declare local variables
    var publish_option: $Value; // $LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $Vector_type_value($Vector_type_value($IntegerType()))
    var $t4: $Mutation; // ReferenceType($LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value())
    var $t5: $Mutation; // ReferenceType($Vector_type_value($Vector_type_value($IntegerType())))

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(19, 4661, 0, lr_account); }

    // bytecode translation starts here
    // $t2 := move(lr_account)
    call $t2 := $CopyOrMoveValue(lr_account);

    // Roles::assert_libra_root($t2)
    call $Roles_assert_libra_root($t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 4726, $abort_code);
      goto Abort;
    }

    // publish_option := LibraConfig::get<LibraTransactionPublishingOption::LibraTransactionPublishingOption>()
    call publish_option := $LibraConfig_get($LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 4799, $abort_code);
      goto Abort;
    }

    // $t3 := Vector::empty<vector<u8>>()
    call $t3 := $Vector_empty($Vector_type_value($IntegerType()));
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 4892, $abort_code);
      goto Abort;
    }

    // $t4 := borrow_local(publish_option)
    call $t4 := $BorrowLoc(1, publish_option);

    // unpack_ref($t4)

    // $t5 := borrow_field<LibraTransactionPublishingOption::LibraTransactionPublishingOption>.script_allow_list($t4)
    call $t5 := $BorrowField($t4, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_script_allow_list);

    // unpack_ref($t5)

    // write_ref($t5, $t3)
    call $t5 := $WriteRef($t5, $t3);

    // pack_ref($t5)

    // write_back[Reference($t4)]($t5)
    call $t4 := $WritebackToReference($t5, $t4);

    // pack_ref($t4)

    // write_back[LocalRoot(publish_option)]($t4)
    call publish_option := $WritebackToValue($t4, 1, publish_option);

    // LibraConfig::set<LibraTransactionPublishingOption::LibraTransactionPublishingOption>($t2, publish_option)
    call $LibraConfig_set($LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value(), $t2, publish_option);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 4922, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraTransactionPublishingOption_set_open_script_$direct_inter(lr_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    call $LibraTransactionPublishingOption_set_open_script_$def(lr_account);
}


procedure {:inline 1} $LibraTransactionPublishingOption_set_open_script_$direct_intra(lr_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    call $LibraTransactionPublishingOption_set_open_script_$def(lr_account);
}


procedure {:inline 1} $LibraTransactionPublishingOption_set_open_script(lr_account: $Value) returns ()
{
    assume is#$Address(lr_account);

    call $LibraTransactionPublishingOption_set_open_script_$def(lr_account);
}




// ** spec vars of module Hash



// ** spec funs of module Hash



// ** structs of module Hash



// ** functions of module Hash



// ** spec vars of module LibraAccount



// ** spec funs of module LibraAccount

function {:inline} $LibraAccount_$balance($LibraAccount_Balance_$memory: $Memory, $tv0: $TypeValue, addr: $Value): $Value {
    $LibraAccount_$balance_for($tv0, $ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))
}

function {:inline} $LibraAccount_$balance_for($tv0: $TypeValue, balance: $Value): $Value {
    $Libra_$value($tv0, $SelectField(balance, $LibraAccount_Balance_coin))
}

function {:inline} $LibraAccount_$delegated_key_rotation_capability($LibraAccount_LibraAccount_$memory: $Memory, addr: $Value): $Value {
    $Option_$is_none($LibraAccount_KeyRotationCapability_type_value(), $SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr), $LibraAccount_LibraAccount_key_rotation_capability))
}

function {:inline} $LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory: $Memory, addr: $Value): $Value {
    $Option_$is_none($LibraAccount_WithdrawCapability_type_value(), $SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr), $LibraAccount_LibraAccount_withdrawal_capability))
}

function {:inline} $LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory: $Memory, check_addr: $Value): $Value {
    $ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, check_addr)
}

function {:inline} $LibraAccount_spec_has_published_account_limits($AccountLimits_Window_$memory: $Memory, $VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, $tv0: $TypeValue, addr: $Value): $Value {
    if (b#$Boolean($VASP_$is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, addr))) then ($VASP_spec_has_account_limits($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, addr)) else ($AccountLimits_$has_window_published($AccountLimits_Window_$memory, $tv0, addr))
}

function {:inline} $LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory: $Memory, $VASP_ChildVASP_$memory: $Memory, $VASP_ParentVASP_$memory: $Memory, $tv0: $TypeValue, payer: $Value, payee: $Value, is_withdrawal: $Value): $Value {
    if (b#$Boolean(is_withdrawal)) then ($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraAccount_spec_has_published_account_limits($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer)) && b#$Boolean($VASP_$is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)))) && b#$Boolean($Boolean(!b#$Boolean($VASP_spec_is_same_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer, payee)))))) else ($Boolean(b#$Boolean($Boolean(b#$Boolean($LibraAccount_spec_has_published_account_limits($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payee)) && b#$Boolean($VASP_$is_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))) && b#$Boolean($Boolean(!b#$Boolean($VASP_spec_is_same_vasp($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee, payer))))))
}

function {:inline} $LibraAccount_prologue_guarantees($LibraTimestamp_CurrentTimeMicroseconds_$memory: $Memory, $AccountFreezing_FreezingBit_$memory: $Memory, $LibraAccount_LibraAccount_$memory: $Memory, sender: $Value): $Value {
    (var addr := $Signer_spec_address_of(sender); $Boolean(b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, addr)))) && b#$Boolean($Boolean(!b#$Boolean($AccountFreezing_$account_is_frozen($AccountFreezing_FreezingBit_$memory, addr))))))
}

function {:inline} $LibraAccount_spec_get_key_rotation_cap_field($LibraAccount_LibraAccount_$memory: $Memory, addr: $Value): $Value {
    $SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr), $LibraAccount_LibraAccount_key_rotation_capability)
}

function {:inline} $LibraAccount_spec_get_key_rotation_cap($LibraAccount_LibraAccount_$memory: $Memory, addr: $Value): $Value {
    $Option_spec_get($LibraAccount_KeyRotationCapability_type_value(), $LibraAccount_spec_get_key_rotation_cap_field($LibraAccount_LibraAccount_$memory, addr))
}

function {:inline} $LibraAccount_spec_has_key_rotation_cap($LibraAccount_LibraAccount_$memory: $Memory, addr: $Value): $Value {
    $Option_$is_some($LibraAccount_KeyRotationCapability_type_value(), $LibraAccount_spec_get_key_rotation_cap_field($LibraAccount_LibraAccount_$memory, addr))
}

function {:inline} $LibraAccount_spec_holds_own_key_rotation_cap($LibraAccount_LibraAccount_$memory: $Memory, addr: $Value): $Value {
    $Boolean(b#$Boolean($LibraAccount_spec_has_key_rotation_cap($LibraAccount_LibraAccount_$memory, addr)) && b#$Boolean($Boolean($IsEqual(addr, $SelectField($LibraAccount_spec_get_key_rotation_cap($LibraAccount_LibraAccount_$memory, addr), $LibraAccount_KeyRotationCapability_account_address)))))
}

function {:inline} $LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory: $Memory): $Value {
    $ResourceExists($LibraAccount_AccountOperationsCapability_$memory, $EmptyTypeValueArray, $CoreAddresses_$LIBRA_ROOT_ADDRESS())
}

function {:inline} $LibraAccount_spec_get_withdraw_cap_field($LibraAccount_LibraAccount_$memory: $Memory, addr: $Value): $Value {
    $SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr), $LibraAccount_LibraAccount_withdrawal_capability)
}

function {:inline} $LibraAccount_spec_get_withdraw_cap($LibraAccount_LibraAccount_$memory: $Memory, addr: $Value): $Value {
    $Option_spec_get($LibraAccount_WithdrawCapability_type_value(), $LibraAccount_spec_get_withdraw_cap_field($LibraAccount_LibraAccount_$memory, addr))
}

function {:inline} $LibraAccount_spec_has_withdraw_cap($LibraAccount_LibraAccount_$memory: $Memory, addr: $Value): $Value {
    $Option_$is_some($LibraAccount_WithdrawCapability_type_value(), $LibraAccount_spec_get_withdraw_cap_field($LibraAccount_LibraAccount_$memory, addr))
}

function {:inline} $LibraAccount_spec_holds_own_withdraw_cap($LibraAccount_LibraAccount_$memory: $Memory, addr: $Value): $Value {
    $Boolean(b#$Boolean($LibraAccount_spec_has_withdraw_cap($LibraAccount_LibraAccount_$memory, addr)) && b#$Boolean($Boolean($IsEqual(addr, $SelectField($LibraAccount_spec_get_withdraw_cap($LibraAccount_LibraAccount_$memory, addr), $LibraAccount_WithdrawCapability_account_address)))))
}

function {:inline} $LibraAccount_spec_get_balance_value($LibraAccount_Balance_$memory: $Memory, $tv0: $TypeValue, addr: $Value): $Value {
    $Libra_$value($tv0, $SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $LibraAccount_Balance_coin))
}

function {:inline} $LibraAccount_payer$57($tv0: $TypeValue, cap: $Value): $Value {
    $SelectField(cap, $LibraAccount_WithdrawCapability_account_address)
}

function {:inline} $LibraAccount_payer_balance$58($LibraAccount_Balance_$memory: $Memory, $tv0: $TypeValue, payer: $Value): $Value {
    $SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payer), $LibraAccount_Balance_coin), $Libra_Libra_value)
}

function {:inline} $LibraAccount_preburn$59($Libra_Preburn_$memory: $Memory, $tv0: $TypeValue, dd_addr: $Value): $Value {
    $ResourceValue($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), dd_addr)
}

function {:inline} $LibraAccount_dealer_balance$60($LibraAccount_Balance_$memory: $Memory, $tv0: $TypeValue, designated_dealer_address: $Value): $Value {
    $SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address), $LibraAccount_Balance_coin), $Libra_Libra_value)
}

function {:inline} $LibraAccount_currency_info$61($Libra_CurrencyInfo_$memory: $Memory, $tv0: $TypeValue): $Value {
    $ResourceValue($Libra_CurrencyInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $CoreAddresses_$CURRENCY_INFO_ADDRESS())
}

function {:inline} $LibraAccount_amount$62($Libra_Preburn_$memory: $Memory, $tv0: $TypeValue, preburn_address: $Value): $Value {
    $SelectField($SelectField($ResourceValue($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), preburn_address), $Libra_Preburn_to_burn), $Libra_Libra_value)
}

function {:inline} $LibraAccount_payer$63($tv0: $TypeValue, cap: $Value): $Value {
    $SelectField(cap, $LibraAccount_WithdrawCapability_account_address)
}

function {:inline} $LibraAccount_account_addr$64(account: $Value): $Value {
    $Signer_spec_address_of(account)
}

function {:inline} $LibraAccount_transaction_sender$65($tv0: $TypeValue, sender: $Value): $Value {
    $Signer_spec_address_of(sender)
}

function {:inline} $LibraAccount_transaction_sender$66($tv0: $TypeValue, sender: $Value): $Value {
    $Signer_spec_address_of(sender)
}

function {:inline} $LibraAccount_transaction_sender$67(sender: $Value): $Value {
    $Signer_spec_address_of(sender)
}

function {:inline} $LibraAccount_addr$68(account: $Value): $Value {
    $Signer_spec_address_of(account)
}

function {:inline} $LibraAccount_addr$69(account: $Value): $Value {
    $Signer_spec_address_of(account)
}

function {:inline} $LibraAccount_preburn_value_at_addr$70($Libra_Preburn_$memory: $Memory, $tv0: $TypeValue, preburn_address: $Value): $Value {
    $SelectField($SelectField($ResourceValue($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), preburn_address), $Libra_Preburn_to_burn), $Libra_Libra_value)
}

function {:inline} $LibraAccount_balance_at_addr$71($LibraAccount_Balance_$memory: $Memory, $tv0: $TypeValue, preburn_address: $Value): $Value {
    $LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, preburn_address)
}

function {:inline} $LibraAccount_payer$72($tv0: $TypeValue, cap: $Value): $Value {
    $SelectField(cap, $LibraAccount_WithdrawCapability_account_address)
}

function {:inline} $LibraAccount_dd_addr$73($tv0: $TypeValue, dd: $Value): $Value {
    $Signer_spec_address_of(dd)
}

function {:inline} $LibraAccount_payer$74($tv0: $TypeValue, cap: $Value): $Value {
    $SelectField(cap, $LibraAccount_WithdrawCapability_account_address)
}

function {:inline} $LibraAccount_sender_addr$75(sender: $Value): $Value {
    $Signer_spec_address_of(sender)
}

function {:inline} $LibraAccount_cap_addr$76(cap: $Value): $Value {
    $SelectField(cap, $LibraAccount_WithdrawCapability_account_address)
}

function {:inline} $LibraAccount_payer$77($tv0: $TypeValue, cap: $Value): $Value {
    $SelectField(cap, $LibraAccount_WithdrawCapability_account_address)
}

function {:inline} $LibraAccount_new_account_addr$78($tv0: $TypeValue, new_account: $Value): $Value {
    $Signer_spec_address_of(new_account)
}

function {:inline} $LibraAccount_new_account_addr$79(new_account: $Value): $Value {
    $Signer_$address_of(new_account)
}

function {:inline} $LibraAccount_transaction_sender$80($tv0: $TypeValue, sender: $Value): $Value {
    $Signer_spec_address_of(sender)
}

function {:inline} $LibraAccount_max_transaction_fee$81($tv0: $TypeValue, txn_gas_price: $Value, txn_max_gas_units: $Value): $Value {
    $Integer(i#$Integer(txn_gas_price) * i#$Integer(txn_max_gas_units))
}

function {:inline} $LibraAccount_transaction_sender$82($tv0: $TypeValue, sender: $Value): $Value {
    $Signer_spec_address_of(sender)
}

function {:inline} $LibraAccount_max_transaction_fee$83($tv0: $TypeValue, txn_gas_price: $Value, txn_max_gas_units: $Value): $Value {
    $Integer(i#$Integer(txn_gas_price) * i#$Integer(txn_max_gas_units))
}

function {:inline} $LibraAccount_transaction_sender$84($tv0: $TypeValue, sender: $Value): $Value {
    $Signer_spec_address_of(sender)
}

function {:inline} $LibraAccount_max_transaction_fee$85($tv0: $TypeValue, txn_gas_price: $Value, txn_max_gas_units: $Value): $Value {
    $Integer(i#$Integer(txn_gas_price) * i#$Integer(txn_max_gas_units))
}



// ** structs of module LibraAccount

const unique $LibraAccount_LibraAccount: $TypeName;
const $LibraAccount_LibraAccount_authentication_key: $FieldName;
axiom $LibraAccount_LibraAccount_authentication_key == 0;
const $LibraAccount_LibraAccount_withdrawal_capability: $FieldName;
axiom $LibraAccount_LibraAccount_withdrawal_capability == 1;
const $LibraAccount_LibraAccount_key_rotation_capability: $FieldName;
axiom $LibraAccount_LibraAccount_key_rotation_capability == 2;
const $LibraAccount_LibraAccount_received_events: $FieldName;
axiom $LibraAccount_LibraAccount_received_events == 3;
const $LibraAccount_LibraAccount_sent_events: $FieldName;
axiom $LibraAccount_LibraAccount_sent_events == 4;
const $LibraAccount_LibraAccount_sequence_number: $FieldName;
axiom $LibraAccount_LibraAccount_sequence_number == 5;
function $LibraAccount_LibraAccount_type_value(): $TypeValue {
    $StructType($LibraAccount_LibraAccount, $EmptyTypeValueArray)
}
var $LibraAccount_LibraAccount_$memory: $Memory;
var $LibraAccount_LibraAccount_$memory_$old: $Memory;
function {:inline} $LibraAccount_LibraAccount_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 6
      && $Vector_$is_well_formed($SelectField($this, $LibraAccount_LibraAccount_authentication_key)) && (forall $$0: int :: {$select_vector($SelectField($this, $LibraAccount_LibraAccount_authentication_key),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_LibraAccount_authentication_key)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_LibraAccount_authentication_key),$$0)))
      && $Option_Option_$is_well_typed($SelectField($this, $LibraAccount_LibraAccount_withdrawal_capability))
      && $Option_Option_$is_well_typed($SelectField($this, $LibraAccount_LibraAccount_key_rotation_capability))
      && $Event_EventHandle_$is_well_typed($SelectField($this, $LibraAccount_LibraAccount_received_events))
      && $Event_EventHandle_$is_well_typed($SelectField($this, $LibraAccount_LibraAccount_sent_events))
      && $IsValidU64($SelectField($this, $LibraAccount_LibraAccount_sequence_number))
}
function {:inline} $LibraAccount_LibraAccount_$invariant_holds($this: $Value): bool {
    $Option_Option_$invariant_holds($SelectField($this, $LibraAccount_LibraAccount_withdrawal_capability))
      && $Option_Option_$invariant_holds($SelectField($this, $LibraAccount_LibraAccount_key_rotation_capability))
      && $Event_EventHandle_$invariant_holds($SelectField($this, $LibraAccount_LibraAccount_received_events))
      && $Event_EventHandle_$invariant_holds($SelectField($this, $LibraAccount_LibraAccount_sent_events))
}

function {:inline} $LibraAccount_LibraAccount_$is_well_formed($this: $Value): bool {
    $LibraAccount_LibraAccount_$is_well_typed($this) && $LibraAccount_LibraAccount_$invariant_holds($this)}

procedure {:inline 1} $LibraAccount_LibraAccount_$unpack_ref_deep($before: $Value) {
    call $Option_Option_$unpack_ref($LibraAccount_WithdrawCapability_type_value(), $SelectField($before, $LibraAccount_LibraAccount_withdrawal_capability));
    call $Option_Option_$unpack_ref($LibraAccount_KeyRotationCapability_type_value(), $SelectField($before, $LibraAccount_LibraAccount_key_rotation_capability));
    assume $LibraAccount_LibraAccount_$invariant_holds($before);
}

procedure {:inline 1} $LibraAccount_LibraAccount_$unpack_ref($before: $Value) {
    assume $LibraAccount_LibraAccount_$invariant_holds($before);
}

procedure {:inline 1} $LibraAccount_LibraAccount_$pack_ref_deep($after: $Value) {
    call $Option_Option_$pack_ref($LibraAccount_WithdrawCapability_type_value(), $SelectField($after, $LibraAccount_LibraAccount_withdrawal_capability));
    call $Option_Option_$pack_ref($LibraAccount_KeyRotationCapability_type_value(), $SelectField($after, $LibraAccount_LibraAccount_key_rotation_capability));
}

procedure {:inline 1} $LibraAccount_LibraAccount_$pack_ref($after: $Value) {
}

procedure {:inline 1} $LibraAccount_LibraAccount_pack($file_id: int, $byte_index: int, $var_idx: int, authentication_key: $Value, withdrawal_capability: $Value, key_rotation_capability: $Value, received_events: $Value, sent_events: $Value, sequence_number: $Value) returns ($struct: $Value)
{
    assume $Vector_$is_well_formed(authentication_key) && (forall $$0: int :: {$select_vector(authentication_key,$$0)} $$0 >= 0 && $$0 < $vlen(authentication_key) ==> $IsValidU8($select_vector(authentication_key,$$0)));
    assume $Option_Option_$is_well_formed(withdrawal_capability);
    assume $Option_Option_$is_well_formed(key_rotation_capability);
    assume $Event_EventHandle_$is_well_formed(received_events);
    assume $Event_EventHandle_$is_well_formed(sent_events);
    assume $IsValidU64(sequence_number);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := authentication_key][1 := withdrawal_capability][2 := key_rotation_capability][3 := received_events][4 := sent_events][5 := sequence_number], 6));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_LibraAccount_unpack($struct: $Value) returns (authentication_key: $Value, withdrawal_capability: $Value, key_rotation_capability: $Value, received_events: $Value, sent_events: $Value, sequence_number: $Value)
{
    assume is#$Vector($struct);
    authentication_key := $SelectField($struct, $LibraAccount_LibraAccount_authentication_key);
    assume $Vector_$is_well_formed(authentication_key) && (forall $$0: int :: {$select_vector(authentication_key,$$0)} $$0 >= 0 && $$0 < $vlen(authentication_key) ==> $IsValidU8($select_vector(authentication_key,$$0)));
    withdrawal_capability := $SelectField($struct, $LibraAccount_LibraAccount_withdrawal_capability);
    assume $Option_Option_$is_well_formed(withdrawal_capability);
    key_rotation_capability := $SelectField($struct, $LibraAccount_LibraAccount_key_rotation_capability);
    assume $Option_Option_$is_well_formed(key_rotation_capability);
    received_events := $SelectField($struct, $LibraAccount_LibraAccount_received_events);
    assume $Event_EventHandle_$is_well_formed(received_events);
    sent_events := $SelectField($struct, $LibraAccount_LibraAccount_sent_events);
    assume $Event_EventHandle_$is_well_formed(sent_events);
    sequence_number := $SelectField($struct, $LibraAccount_LibraAccount_sequence_number);
    assume $IsValidU64(sequence_number);
}

const unique $LibraAccount_AccountOperationsCapability: $TypeName;
const $LibraAccount_AccountOperationsCapability_limits_cap: $FieldName;
axiom $LibraAccount_AccountOperationsCapability_limits_cap == 0;
const $LibraAccount_AccountOperationsCapability_creation_events: $FieldName;
axiom $LibraAccount_AccountOperationsCapability_creation_events == 1;
function $LibraAccount_AccountOperationsCapability_type_value(): $TypeValue {
    $StructType($LibraAccount_AccountOperationsCapability, $EmptyTypeValueArray)
}
var $LibraAccount_AccountOperationsCapability_$memory: $Memory;
var $LibraAccount_AccountOperationsCapability_$memory_$old: $Memory;
function {:inline} $LibraAccount_AccountOperationsCapability_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 2
      && $AccountLimits_AccountLimitMutationCapability_$is_well_typed($SelectField($this, $LibraAccount_AccountOperationsCapability_limits_cap))
      && $Event_EventHandle_$is_well_typed($SelectField($this, $LibraAccount_AccountOperationsCapability_creation_events))
}
function {:inline} $LibraAccount_AccountOperationsCapability_$invariant_holds($this: $Value): bool {
    $AccountLimits_AccountLimitMutationCapability_$invariant_holds($SelectField($this, $LibraAccount_AccountOperationsCapability_limits_cap))
      && $Event_EventHandle_$invariant_holds($SelectField($this, $LibraAccount_AccountOperationsCapability_creation_events))
}

function {:inline} $LibraAccount_AccountOperationsCapability_$is_well_formed($this: $Value): bool {
    $LibraAccount_AccountOperationsCapability_$is_well_typed($this) && $LibraAccount_AccountOperationsCapability_$invariant_holds($this)}

procedure {:inline 1} $LibraAccount_AccountOperationsCapability_pack($file_id: int, $byte_index: int, $var_idx: int, limits_cap: $Value, creation_events: $Value) returns ($struct: $Value)
{
    assume $AccountLimits_AccountLimitMutationCapability_$is_well_formed(limits_cap);
    assume $Event_EventHandle_$is_well_formed(creation_events);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := limits_cap][1 := creation_events], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_AccountOperationsCapability_unpack($struct: $Value) returns (limits_cap: $Value, creation_events: $Value)
{
    assume is#$Vector($struct);
    limits_cap := $SelectField($struct, $LibraAccount_AccountOperationsCapability_limits_cap);
    assume $AccountLimits_AccountLimitMutationCapability_$is_well_formed(limits_cap);
    creation_events := $SelectField($struct, $LibraAccount_AccountOperationsCapability_creation_events);
    assume $Event_EventHandle_$is_well_formed(creation_events);
}

const unique $LibraAccount_Balance: $TypeName;
const $LibraAccount_Balance_coin: $FieldName;
axiom $LibraAccount_Balance_coin == 0;
function $LibraAccount_Balance_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($LibraAccount_Balance, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1))
}
var $LibraAccount_Balance_$memory: $Memory;
var $LibraAccount_Balance_$memory_$old: $Memory;
function {:inline} $LibraAccount_Balance_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && $Libra_Libra_$is_well_typed($SelectField($this, $LibraAccount_Balance_coin))
}
function {:inline} $LibraAccount_Balance_$invariant_holds($this: $Value): bool {
    $Libra_Libra_$invariant_holds($SelectField($this, $LibraAccount_Balance_coin))
}

function {:inline} $LibraAccount_Balance_$is_well_formed($this: $Value): bool {
    $LibraAccount_Balance_$is_well_typed($this) && $LibraAccount_Balance_$invariant_holds($this)}

procedure {:inline 1} $LibraAccount_Balance_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, coin: $Value) returns ($struct: $Value)
{
    assume $Libra_Libra_$is_well_formed(coin);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := coin], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_Balance_unpack($tv0: $TypeValue, $struct: $Value) returns (coin: $Value)
{
    assume is#$Vector($struct);
    coin := $SelectField($struct, $LibraAccount_Balance_coin);
    assume $Libra_Libra_$is_well_formed(coin);
}

const unique $LibraAccount_CreateAccountEvent: $TypeName;
const $LibraAccount_CreateAccountEvent_created: $FieldName;
axiom $LibraAccount_CreateAccountEvent_created == 0;
const $LibraAccount_CreateAccountEvent_role_id: $FieldName;
axiom $LibraAccount_CreateAccountEvent_role_id == 1;
function $LibraAccount_CreateAccountEvent_type_value(): $TypeValue {
    $StructType($LibraAccount_CreateAccountEvent, $EmptyTypeValueArray)
}
var $LibraAccount_CreateAccountEvent_$memory: $Memory;
var $LibraAccount_CreateAccountEvent_$memory_$old: $Memory;
function {:inline} $LibraAccount_CreateAccountEvent_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 2
      && is#$Address($SelectField($this, $LibraAccount_CreateAccountEvent_created))
      && $IsValidU64($SelectField($this, $LibraAccount_CreateAccountEvent_role_id))
}
function {:inline} $LibraAccount_CreateAccountEvent_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $LibraAccount_CreateAccountEvent_$is_well_formed($this: $Value): bool {
    $LibraAccount_CreateAccountEvent_$is_well_typed($this) && $LibraAccount_CreateAccountEvent_$invariant_holds($this)}

procedure {:inline 1} $LibraAccount_CreateAccountEvent_pack($file_id: int, $byte_index: int, $var_idx: int, created: $Value, role_id: $Value) returns ($struct: $Value)
{
    assume is#$Address(created);
    assume $IsValidU64(role_id);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := created][1 := role_id], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_CreateAccountEvent_unpack($struct: $Value) returns (created: $Value, role_id: $Value)
{
    assume is#$Vector($struct);
    created := $SelectField($struct, $LibraAccount_CreateAccountEvent_created);
    assume is#$Address(created);
    role_id := $SelectField($struct, $LibraAccount_CreateAccountEvent_role_id);
    assume $IsValidU64(role_id);
}

const unique $LibraAccount_KeyRotationCapability: $TypeName;
const $LibraAccount_KeyRotationCapability_account_address: $FieldName;
axiom $LibraAccount_KeyRotationCapability_account_address == 0;
function $LibraAccount_KeyRotationCapability_type_value(): $TypeValue {
    $StructType($LibraAccount_KeyRotationCapability, $EmptyTypeValueArray)
}
var $LibraAccount_KeyRotationCapability_$memory: $Memory;
var $LibraAccount_KeyRotationCapability_$memory_$old: $Memory;
function {:inline} $LibraAccount_KeyRotationCapability_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && is#$Address($SelectField($this, $LibraAccount_KeyRotationCapability_account_address))
}
function {:inline} $LibraAccount_KeyRotationCapability_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $LibraAccount_KeyRotationCapability_$is_well_formed($this: $Value): bool {
    $LibraAccount_KeyRotationCapability_$is_well_typed($this) && $LibraAccount_KeyRotationCapability_$invariant_holds($this)}

procedure {:inline 1} $LibraAccount_KeyRotationCapability_pack($file_id: int, $byte_index: int, $var_idx: int, account_address: $Value) returns ($struct: $Value)
{
    assume is#$Address(account_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := account_address], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_KeyRotationCapability_unpack($struct: $Value) returns (account_address: $Value)
{
    assume is#$Vector($struct);
    account_address := $SelectField($struct, $LibraAccount_KeyRotationCapability_account_address);
    assume is#$Address(account_address);
}

const unique $LibraAccount_LibraWriteSetManager: $TypeName;
const $LibraAccount_LibraWriteSetManager_upgrade_events: $FieldName;
axiom $LibraAccount_LibraWriteSetManager_upgrade_events == 0;
function $LibraAccount_LibraWriteSetManager_type_value(): $TypeValue {
    $StructType($LibraAccount_LibraWriteSetManager, $EmptyTypeValueArray)
}
var $LibraAccount_LibraWriteSetManager_$memory: $Memory;
var $LibraAccount_LibraWriteSetManager_$memory_$old: $Memory;
function {:inline} $LibraAccount_LibraWriteSetManager_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && $Event_EventHandle_$is_well_typed($SelectField($this, $LibraAccount_LibraWriteSetManager_upgrade_events))
}
function {:inline} $LibraAccount_LibraWriteSetManager_$invariant_holds($this: $Value): bool {
    $Event_EventHandle_$invariant_holds($SelectField($this, $LibraAccount_LibraWriteSetManager_upgrade_events))
}

function {:inline} $LibraAccount_LibraWriteSetManager_$is_well_formed($this: $Value): bool {
    $LibraAccount_LibraWriteSetManager_$is_well_typed($this) && $LibraAccount_LibraWriteSetManager_$invariant_holds($this)}

procedure {:inline 1} $LibraAccount_LibraWriteSetManager_pack($file_id: int, $byte_index: int, $var_idx: int, upgrade_events: $Value) returns ($struct: $Value)
{
    assume $Event_EventHandle_$is_well_formed(upgrade_events);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := upgrade_events], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_LibraWriteSetManager_unpack($struct: $Value) returns (upgrade_events: $Value)
{
    assume is#$Vector($struct);
    upgrade_events := $SelectField($struct, $LibraAccount_LibraWriteSetManager_upgrade_events);
    assume $Event_EventHandle_$is_well_formed(upgrade_events);
}

const unique $LibraAccount_ReceivedPaymentEvent: $TypeName;
const $LibraAccount_ReceivedPaymentEvent_amount: $FieldName;
axiom $LibraAccount_ReceivedPaymentEvent_amount == 0;
const $LibraAccount_ReceivedPaymentEvent_currency_code: $FieldName;
axiom $LibraAccount_ReceivedPaymentEvent_currency_code == 1;
const $LibraAccount_ReceivedPaymentEvent_payer: $FieldName;
axiom $LibraAccount_ReceivedPaymentEvent_payer == 2;
const $LibraAccount_ReceivedPaymentEvent_metadata: $FieldName;
axiom $LibraAccount_ReceivedPaymentEvent_metadata == 3;
function $LibraAccount_ReceivedPaymentEvent_type_value(): $TypeValue {
    $StructType($LibraAccount_ReceivedPaymentEvent, $EmptyTypeValueArray)
}
var $LibraAccount_ReceivedPaymentEvent_$memory: $Memory;
var $LibraAccount_ReceivedPaymentEvent_$memory_$old: $Memory;
function {:inline} $LibraAccount_ReceivedPaymentEvent_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 4
      && $IsValidU64($SelectField($this, $LibraAccount_ReceivedPaymentEvent_amount))
      && $Vector_$is_well_formed($SelectField($this, $LibraAccount_ReceivedPaymentEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $LibraAccount_ReceivedPaymentEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_ReceivedPaymentEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_ReceivedPaymentEvent_currency_code),$$0)))
      && is#$Address($SelectField($this, $LibraAccount_ReceivedPaymentEvent_payer))
      && $Vector_$is_well_formed($SelectField($this, $LibraAccount_ReceivedPaymentEvent_metadata)) && (forall $$0: int :: {$select_vector($SelectField($this, $LibraAccount_ReceivedPaymentEvent_metadata),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_ReceivedPaymentEvent_metadata)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_ReceivedPaymentEvent_metadata),$$0)))
}
function {:inline} $LibraAccount_ReceivedPaymentEvent_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $LibraAccount_ReceivedPaymentEvent_$is_well_formed($this: $Value): bool {
    $LibraAccount_ReceivedPaymentEvent_$is_well_typed($this) && $LibraAccount_ReceivedPaymentEvent_$invariant_holds($this)}

procedure {:inline 1} $LibraAccount_ReceivedPaymentEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value, payer: $Value, metadata: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(amount);
    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    assume is#$Address(payer);
    assume $Vector_$is_well_formed(metadata) && (forall $$0: int :: {$select_vector(metadata,$$0)} $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata,$$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := amount][1 := currency_code][2 := payer][3 := metadata], 4));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_ReceivedPaymentEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value, payer: $Value, metadata: $Value)
{
    assume is#$Vector($struct);
    amount := $SelectField($struct, $LibraAccount_ReceivedPaymentEvent_amount);
    assume $IsValidU64(amount);
    currency_code := $SelectField($struct, $LibraAccount_ReceivedPaymentEvent_currency_code);
    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    payer := $SelectField($struct, $LibraAccount_ReceivedPaymentEvent_payer);
    assume is#$Address(payer);
    metadata := $SelectField($struct, $LibraAccount_ReceivedPaymentEvent_metadata);
    assume $Vector_$is_well_formed(metadata) && (forall $$0: int :: {$select_vector(metadata,$$0)} $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata,$$0)));
}

const unique $LibraAccount_SentPaymentEvent: $TypeName;
const $LibraAccount_SentPaymentEvent_amount: $FieldName;
axiom $LibraAccount_SentPaymentEvent_amount == 0;
const $LibraAccount_SentPaymentEvent_currency_code: $FieldName;
axiom $LibraAccount_SentPaymentEvent_currency_code == 1;
const $LibraAccount_SentPaymentEvent_payee: $FieldName;
axiom $LibraAccount_SentPaymentEvent_payee == 2;
const $LibraAccount_SentPaymentEvent_metadata: $FieldName;
axiom $LibraAccount_SentPaymentEvent_metadata == 3;
function $LibraAccount_SentPaymentEvent_type_value(): $TypeValue {
    $StructType($LibraAccount_SentPaymentEvent, $EmptyTypeValueArray)
}
var $LibraAccount_SentPaymentEvent_$memory: $Memory;
var $LibraAccount_SentPaymentEvent_$memory_$old: $Memory;
function {:inline} $LibraAccount_SentPaymentEvent_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 4
      && $IsValidU64($SelectField($this, $LibraAccount_SentPaymentEvent_amount))
      && $Vector_$is_well_formed($SelectField($this, $LibraAccount_SentPaymentEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $LibraAccount_SentPaymentEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_SentPaymentEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_SentPaymentEvent_currency_code),$$0)))
      && is#$Address($SelectField($this, $LibraAccount_SentPaymentEvent_payee))
      && $Vector_$is_well_formed($SelectField($this, $LibraAccount_SentPaymentEvent_metadata)) && (forall $$0: int :: {$select_vector($SelectField($this, $LibraAccount_SentPaymentEvent_metadata),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_SentPaymentEvent_metadata)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_SentPaymentEvent_metadata),$$0)))
}
function {:inline} $LibraAccount_SentPaymentEvent_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $LibraAccount_SentPaymentEvent_$is_well_formed($this: $Value): bool {
    $LibraAccount_SentPaymentEvent_$is_well_typed($this) && $LibraAccount_SentPaymentEvent_$invariant_holds($this)}

procedure {:inline 1} $LibraAccount_SentPaymentEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value, payee: $Value, metadata: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(amount);
    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    assume is#$Address(payee);
    assume $Vector_$is_well_formed(metadata) && (forall $$0: int :: {$select_vector(metadata,$$0)} $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata,$$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := amount][1 := currency_code][2 := payee][3 := metadata], 4));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_SentPaymentEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value, payee: $Value, metadata: $Value)
{
    assume is#$Vector($struct);
    amount := $SelectField($struct, $LibraAccount_SentPaymentEvent_amount);
    assume $IsValidU64(amount);
    currency_code := $SelectField($struct, $LibraAccount_SentPaymentEvent_currency_code);
    assume $Vector_$is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    payee := $SelectField($struct, $LibraAccount_SentPaymentEvent_payee);
    assume is#$Address(payee);
    metadata := $SelectField($struct, $LibraAccount_SentPaymentEvent_metadata);
    assume $Vector_$is_well_formed(metadata) && (forall $$0: int :: {$select_vector(metadata,$$0)} $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata,$$0)));
}

const unique $LibraAccount_UpgradeEvent: $TypeName;
const $LibraAccount_UpgradeEvent_writeset_payload: $FieldName;
axiom $LibraAccount_UpgradeEvent_writeset_payload == 0;
function $LibraAccount_UpgradeEvent_type_value(): $TypeValue {
    $StructType($LibraAccount_UpgradeEvent, $EmptyTypeValueArray)
}
var $LibraAccount_UpgradeEvent_$memory: $Memory;
var $LibraAccount_UpgradeEvent_$memory_$old: $Memory;
function {:inline} $LibraAccount_UpgradeEvent_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && $Vector_$is_well_formed($SelectField($this, $LibraAccount_UpgradeEvent_writeset_payload)) && (forall $$0: int :: {$select_vector($SelectField($this, $LibraAccount_UpgradeEvent_writeset_payload),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_UpgradeEvent_writeset_payload)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_UpgradeEvent_writeset_payload),$$0)))
}
function {:inline} $LibraAccount_UpgradeEvent_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $LibraAccount_UpgradeEvent_$is_well_formed($this: $Value): bool {
    $LibraAccount_UpgradeEvent_$is_well_typed($this) && $LibraAccount_UpgradeEvent_$invariant_holds($this)}

procedure {:inline 1} $LibraAccount_UpgradeEvent_pack($file_id: int, $byte_index: int, $var_idx: int, writeset_payload: $Value) returns ($struct: $Value)
{
    assume $Vector_$is_well_formed(writeset_payload) && (forall $$0: int :: {$select_vector(writeset_payload,$$0)} $$0 >= 0 && $$0 < $vlen(writeset_payload) ==> $IsValidU8($select_vector(writeset_payload,$$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := writeset_payload], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_UpgradeEvent_unpack($struct: $Value) returns (writeset_payload: $Value)
{
    assume is#$Vector($struct);
    writeset_payload := $SelectField($struct, $LibraAccount_UpgradeEvent_writeset_payload);
    assume $Vector_$is_well_formed(writeset_payload) && (forall $$0: int :: {$select_vector(writeset_payload,$$0)} $$0 >= 0 && $$0 < $vlen(writeset_payload) ==> $IsValidU8($select_vector(writeset_payload,$$0)));
}

const unique $LibraAccount_WithdrawCapability: $TypeName;
const $LibraAccount_WithdrawCapability_account_address: $FieldName;
axiom $LibraAccount_WithdrawCapability_account_address == 0;
function $LibraAccount_WithdrawCapability_type_value(): $TypeValue {
    $StructType($LibraAccount_WithdrawCapability, $EmptyTypeValueArray)
}
var $LibraAccount_WithdrawCapability_$memory: $Memory;
var $LibraAccount_WithdrawCapability_$memory_$old: $Memory;
function {:inline} $LibraAccount_WithdrawCapability_$is_well_typed($this: $Value): bool {
    $Vector_$is_well_formed($this)
    && $vlen($this) == 1
      && is#$Address($SelectField($this, $LibraAccount_WithdrawCapability_account_address))
}
function {:inline} $LibraAccount_WithdrawCapability_$invariant_holds($this: $Value): bool {
    true
}

function {:inline} $LibraAccount_WithdrawCapability_$is_well_formed($this: $Value): bool {
    $LibraAccount_WithdrawCapability_$is_well_typed($this) && $LibraAccount_WithdrawCapability_$invariant_holds($this)}

procedure {:inline 1} $LibraAccount_WithdrawCapability_pack($file_id: int, $byte_index: int, $var_idx: int, account_address: $Value) returns ($struct: $Value)
{
    assume is#$Address(account_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := account_address], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_WithdrawCapability_unpack($struct: $Value) returns (account_address: $Value)
{
    assume is#$Vector($struct);
    account_address := $SelectField($struct, $LibraAccount_WithdrawCapability_account_address);
    assume is#$Address(account_address);
}



// ** functions of module LibraAccount

procedure {:inline 1} $LibraAccount_initialize_$def(lr_account: $Value, dummy_auth_key_prefix: $Value) returns ()
{
    // declare local variables
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $Vector_type_value($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 9111, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(16, 9111, 1, dummy_auth_key_prefix); }

    // bytecode translation starts here
    // $t2 := move(lr_account)
    call $t2 := $CopyOrMoveValue(lr_account);

    // $t3 := move(dummy_auth_key_prefix)
    call $t3 := $CopyOrMoveValue(dummy_auth_key_prefix);

    // LibraTimestamp::assert_genesis()
    call $LibraTimestamp_assert_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 9275, $abort_code);
      goto Abort;
    }

    // CoreAddresses::assert_libra_root($t2)
    call $CoreAddresses_assert_libra_root($t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 9379, $abort_code);
      goto Abort;
    }

    // LibraAccount::create_libra_root_account($t3)
    call $LibraAccount_create_libra_root_account($t3);
    if ($abort_flag) {
      goto Abort;
    }

    // LibraAccount::create_treasury_compliance_account($t2, $t3)
    call $LibraAccount_create_treasury_compliance_account($t2, $t3);
    if ($abort_flag) {
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_initialize_$direct_inter(lr_account: $Value, dummy_auth_key_prefix: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(dummy_auth_key_prefix) && (forall $$0: int :: {$select_vector(dummy_auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(dummy_auth_key_prefix) ==> $IsValidU8($select_vector(dummy_auth_key_prefix,$$0)));

    call $LibraAccount_initialize_$def(lr_account, dummy_auth_key_prefix);
}


procedure {:inline 1} $LibraAccount_initialize_$direct_intra(lr_account: $Value, dummy_auth_key_prefix: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(dummy_auth_key_prefix) && (forall $$0: int :: {$select_vector(dummy_auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(dummy_auth_key_prefix) ==> $IsValidU8($select_vector(dummy_auth_key_prefix,$$0)));

    call $LibraAccount_initialize_$def(lr_account, dummy_auth_key_prefix);
}


procedure {:inline 1} $LibraAccount_initialize(lr_account: $Value, dummy_auth_key_prefix: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(dummy_auth_key_prefix) && (forall $$0: int :: {$select_vector(dummy_auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(dummy_auth_key_prefix) ==> $IsValidU8($select_vector(dummy_auth_key_prefix,$$0)));

    call $LibraAccount_initialize_$def(lr_account, dummy_auth_key_prefix);
}


procedure {:inline 1} $LibraAccount_preburn_$def($tv0: $TypeValue, dd: $Value, cap: $Value, amount: $Value, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $Vector_type_value($IntegerType())
    var $t8: $Value; // $Libra_Libra_type_value($tv0)
    var $LibraAccount_LibraAccount_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 25821, 0, dd); }
    if (true) { assume $DebugTrackLocal(16, 25821, 1, cap); }
    if (true) { assume $DebugTrackLocal(16, 25821, 2, amount); }
    $LibraAccount_LibraAccount_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$74($tv0, cap)) := true];

    // bytecode translation starts here
    // $t3 := move(dd)
    call $t3 := $CopyOrMoveValue(dd);

    // $t4 := move(cap)
    call $t4 := $CopyOrMoveValue(cap);

    // $t5 := move(amount)
    call $t5 := $CopyOrMoveValue(amount);

    // LibraTimestamp::assert_operating()
    call $LibraTimestamp_assert_operating();
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 26015, $abort_code);
      goto Abort;
    }

    // $t6 := Signer::address_of($t3)
    call $t6 := $Signer_address_of($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 26099, $abort_code);
      goto Abort;
    }

    // $t7 := []
    $t7 := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));

    // $t8 := LibraAccount::withdraw_from<#0>($t4, $t6, $t5, $t7)
    call $t8 := $LibraAccount_withdraw_from($tv0, $t4, $t6, $t5, $t7, $LibraAccount_LibraAccount_$SelfDomain, $ConstMemoryDomain(true));
    if ($abort_flag) {
      goto Abort;
    }

    // Libra::preburn_to<#0>($t3, $t8)
    call $Libra_preburn_to($tv0, $t3, $t8);
    if ($abort_flag) {
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_preburn_$direct_inter($tv0: $TypeValue, dd: $Value, cap: $Value, amount: $Value, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraAccount_LibraAccount_$CallerDomain[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$74($tv0, cap))];
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$57($tv0, cap)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)), $LibraAccount_Balance_coin), $Libra_Libra_value)) < i#$Integer(amount)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, $LibraAccount_payer$57($tv0, cap)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_limit_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Libra_account_addr$52($tv0, dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($SelectField($Libra_preburn$53($Libra_Preburn_$memory, $tv0, dd), $Libra_Preburn_to_burn), $Libra_Libra_value), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$57($tv0, cap))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))))))))))
    || b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)), $LibraAccount_Balance_coin), $Libra_Libra_value)) < i#$Integer(amount))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, $LibraAccount_payer$57($tv0, cap))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_limit_address))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Libra_account_addr$52($tv0, dd))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($SelectField($Libra_preburn$53($Libra_Preburn_$memory, $tv0, dd), $Libra_Preburn_to_burn), $Libra_Libra_value), $Integer(0)))))
    || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$57($tv0, cap)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)), $LibraAccount_Balance_coin), $Libra_Libra_value)) < i#$Integer(amount)))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, $LibraAccount_payer$57($tv0, cap)))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_limit_address)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Libra_account_addr$52($tv0, dd)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($SelectField($Libra_preburn$53($Libra_Preburn_$memory, $tv0, dd), $Libra_Preburn_to_burn), $Libra_Libra_value), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $LibraAccount_payer$74($tv0, cap))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $LibraAccount_payer$74($tv0, cap)), $LibraAccount_LibraAccount_withdrawal_capability), old($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $LibraAccount_payer$74($tv0, cap)), $LibraAccount_LibraAccount_withdrawal_capability))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraAccount_payer_balance$58($LibraAccount_Balance_$memory, $tv0, $LibraAccount_payer$74($tv0, cap)), $Integer(i#$Integer(old($LibraAccount_payer_balance$58($LibraAccount_Balance_$memory, $tv0, $LibraAccount_payer$74($tv0, cap)))) - i#$Integer(amount))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value), $Integer(i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))) + i#$Integer(amount))))));
modifies $AccountLimits_Window_$memory;
modifies $Libra_CurrencyInfo_$memory;
modifies $Libra_Preburn_$memory;
modifies $LibraAccount_LibraAccount_$memory;
ensures contents#$Memory($LibraAccount_LibraAccount_$memory) == old(contents#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$74($tv0, cap)) := contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$74($tv0, cap))]];
ensures domain#$Memory($LibraAccount_LibraAccount_$memory) == old(domain#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$74($tv0, cap)) := domain#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$74($tv0, cap))]];
modifies $LibraAccount_Balance_$memory;

procedure {:inline 1} $LibraAccount_preburn_$direct_intra($tv0: $TypeValue, dd: $Value, cap: $Value, amount: $Value, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraAccount_LibraAccount_$CallerDomain[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$74($tv0, cap))];
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$57($tv0, cap)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)), $LibraAccount_Balance_coin), $Libra_Libra_value)) < i#$Integer(amount)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, $LibraAccount_payer$57($tv0, cap)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_limit_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Libra_account_addr$52($tv0, dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($SelectField($Libra_preburn$53($Libra_Preburn_$memory, $tv0, dd), $Libra_Preburn_to_burn), $Libra_Libra_value), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$57($tv0, cap))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))))))))))
    || b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)), $LibraAccount_Balance_coin), $Libra_Libra_value)) < i#$Integer(amount))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, $LibraAccount_payer$57($tv0, cap))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_limit_address))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Libra_account_addr$52($tv0, dd))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($SelectField($Libra_preburn$53($Libra_Preburn_$memory, $tv0, dd), $Libra_Preburn_to_burn), $Libra_Libra_value), $Integer(0)))))
    || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$57($tv0, cap)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)), $LibraAccount_Balance_coin), $Libra_Libra_value)) < i#$Integer(amount)))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, $LibraAccount_payer$57($tv0, cap)))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_limit_address)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Libra_account_addr$52($tv0, dd)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($SelectField($Libra_preburn$53($Libra_Preburn_$memory, $tv0, dd), $Libra_Preburn_to_burn), $Libra_Libra_value), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $LibraAccount_payer$74($tv0, cap))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $LibraAccount_payer$74($tv0, cap)), $LibraAccount_LibraAccount_withdrawal_capability), old($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $LibraAccount_payer$74($tv0, cap)), $LibraAccount_LibraAccount_withdrawal_capability))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraAccount_payer_balance$58($LibraAccount_Balance_$memory, $tv0, $LibraAccount_payer$74($tv0, cap)), $Integer(i#$Integer(old($LibraAccount_payer_balance$58($LibraAccount_Balance_$memory, $tv0, $LibraAccount_payer$74($tv0, cap)))) - i#$Integer(amount))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value), $Integer(i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))) + i#$Integer(amount))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1), $LibraAccount_LibraAccount_authentication_key), old($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1), $LibraAccount_LibraAccount_authentication_key)))))))))));
modifies $AccountLimits_Window_$memory;
modifies $Libra_CurrencyInfo_$memory;
modifies $Libra_Preburn_$memory;
modifies $LibraAccount_LibraAccount_$memory;
ensures contents#$Memory($LibraAccount_LibraAccount_$memory) == old(contents#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$74($tv0, cap)) := contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$74($tv0, cap))]];
ensures domain#$Memory($LibraAccount_LibraAccount_$memory) == old(domain#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$74($tv0, cap)) := domain#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$74($tv0, cap))]];
modifies $LibraAccount_Balance_$memory;

procedure {:inline 1} $LibraAccount_preburn($tv0: $TypeValue, dd: $Value, cap: $Value, amount: $Value, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraAccount_LibraAccount_$CallerDomain[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$74($tv0, cap))];
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$57($tv0, cap)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)), $LibraAccount_Balance_coin), $Libra_Libra_value)) < i#$Integer(amount)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, $LibraAccount_payer$57($tv0, cap)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_limit_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Libra_account_addr$52($tv0, dd)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($SelectField($Libra_preburn$53($Libra_Preburn_$memory, $tv0, dd), $Libra_Preburn_to_burn), $Libra_Libra_value), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$57($tv0, cap))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))))))))))
    || b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)), $LibraAccount_Balance_coin), $Libra_Libra_value)) < i#$Integer(amount))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, $LibraAccount_payer$57($tv0, cap))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_limit_address))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Libra_account_addr$52($tv0, dd))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($SelectField($Libra_preburn$53($Libra_Preburn_$memory, $tv0, dd), $Libra_Preburn_to_burn), $Libra_Libra_value), $Integer(0)))))
    || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$57($tv0, cap)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)), $LibraAccount_Balance_coin), $Libra_Libra_value)) < i#$Integer(amount)))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, $LibraAccount_payer$57($tv0, cap)))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_limit_address)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), $Signer_spec_address_of(dd), $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Libra_account_addr$52($tv0, dd)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($SelectField($Libra_preburn$53($Libra_Preburn_$memory, $tv0, dd), $Libra_Preburn_to_burn), $Libra_Libra_value), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $LibraAccount_payer$74($tv0, cap))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $LibraAccount_payer$74($tv0, cap)), $LibraAccount_LibraAccount_withdrawal_capability), old($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $LibraAccount_payer$74($tv0, cap)), $LibraAccount_LibraAccount_withdrawal_capability))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraAccount_payer_balance$58($LibraAccount_Balance_$memory, $tv0, $LibraAccount_payer$74($tv0, cap)), $Integer(i#$Integer(old($LibraAccount_payer_balance$58($LibraAccount_Balance_$memory, $tv0, $LibraAccount_payer$74($tv0, cap)))) - i#$Integer(amount))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value), $Integer(i#$Integer(old($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_preburn_value))) + i#$Integer(amount))))));
modifies $AccountLimits_Window_$memory;
modifies $Libra_CurrencyInfo_$memory;
modifies $Libra_Preburn_$memory;
modifies $LibraAccount_LibraAccount_$memory;
ensures contents#$Memory($LibraAccount_LibraAccount_$memory) == old(contents#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$74($tv0, cap)) := contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$74($tv0, cap))]];
ensures domain#$Memory($LibraAccount_LibraAccount_$memory) == old(domain#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$74($tv0, cap)) := domain#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$74($tv0, cap))]];
modifies $LibraAccount_Balance_$memory;

procedure {:inline 1} $LibraAccount_cancel_burn_$def($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ()
{
    // declare local variables
    var coin: $Value; // $Libra_Libra_type_value($tv0)
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $Vector_type_value($IntegerType())
    var $t6: $Value; // $Vector_type_value($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 18741, 0, account); }
    if (true) { assume $DebugTrackLocal(16, 18741, 1, preburn_address); }

    // bytecode translation starts here
    // $t3 := move(account)
    call $t3 := $CopyOrMoveValue(account);

    // $t4 := move(preburn_address)
    call $t4 := $CopyOrMoveValue(preburn_address);

    // coin := Libra::cancel_burn<#0>($t3, $t4)
    call coin := $Libra_cancel_burn($tv0, $t3, $t4);
    if ($abort_flag) {
      goto Abort;
    }

    // $t5 := []
    $t5 := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));

    // $t6 := []
    $t6 := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));

    // LibraAccount::deposit<#0>($t4, $t4, coin, $t5, $t6)
    call $LibraAccount_deposit($tv0, $t4, $t4, coin, $t5, $t6, $ConstMemoryDomain(true), $ConstMemoryDomain(true), $ConstMemoryDomain(true));
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 11829, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_cancel_burn_$direct_inter($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ()
{
    assume is#$Address(account);

    assume is#$Address(preburn_address);

    call $LibraAccount_cancel_burn_$def($tv0, account, preburn_address);
}


procedure {:inline 1} $LibraAccount_cancel_burn_$direct_intra($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ()
{
    assume is#$Address(account);

    assume is#$Address(preburn_address);

    call $LibraAccount_cancel_burn_$def($tv0, account, preburn_address);
}


procedure {:inline 1} $LibraAccount_cancel_burn($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ()
{
    assume is#$Address(account);

    assume is#$Address(preburn_address);

    call $LibraAccount_cancel_burn_$def($tv0, account, preburn_address);
}


procedure {:inline 1} $LibraAccount_deposit_$def($tv0: $TypeValue, payer: $Value, payee: $Value, to_deposit: $Value, metadata: $Value, metadata_signature: $Value, $AccountLimits_Window_$CallerDomain: [$TypeValueArray, int]bool, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool, $LibraAccount_Balance_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var deposit_value: $Value; // $IntegerType()
    var tmp#$6: $Value; // $BooleanType()
    var tmp#$7: $Value; // $IntegerType()
    var tmp#$8: $Value; // $BooleanType()
    var tmp#$9: $Value; // $IntegerType()
    var tmp#$10: $Value; // $BooleanType()
    var tmp#$11: $Value; // $IntegerType()
    var tmp#$12: $Value; // $BooleanType()
    var tmp#$13: $Value; // $IntegerType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $Libra_Libra_type_value($tv0)
    var $t17: $Value; // $Vector_type_value($IntegerType())
    var $t18: $Value; // $Vector_type_value($IntegerType())
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $BooleanType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $BooleanType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $BooleanType()
    var $t30: $Value; // $BooleanType()
    var $t31: $Value; // $AddressType()
    var $t32: $Value; // $AddressType()
    var $t33: $Value; // $LibraAccount_AccountOperationsCapability_type_value()
    var $t34: $Value; // $AccountLimits_AccountLimitMutationCapability_type_value()
    var $t35: $Value; // $BooleanType()
    var $t36: $Value; // $IntegerType()
    var $t37: $Value; // $IntegerType()
    var $t38: $Mutation; // ReferenceType($LibraAccount_Balance_type_value($tv0))
    var $t39: $Mutation; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t40: $Value; // $Libra_Libra_type_value($tv0)
    var $t41: $Mutation; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t42: $Mutation; // ReferenceType($Event_EventHandle_type_value($LibraAccount_ReceivedPaymentEvent_type_value()))
    var $t43: $Value; // $Vector_type_value($IntegerType())
    var $t44: $Value; // $LibraAccount_ReceivedPaymentEvent_type_value()
    var $t45: $Value; // $Event_EventHandle_type_value($LibraAccount_ReceivedPaymentEvent_type_value())
    var $AccountLimits_Window_$SelfDomain: [$TypeValueArray, int]bool;
    var $LibraAccount_LibraAccount_$SelfDomain: [$TypeValueArray, int]bool;
    var $LibraAccount_Balance_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 11825, 0, payer); }
    if (true) { assume $DebugTrackLocal(16, 11825, 1, payee); }
    if (true) { assume $DebugTrackLocal(16, 11825, 2, to_deposit); }
    if (true) { assume $DebugTrackLocal(16, 11825, 3, metadata); }
    if (true) { assume $DebugTrackLocal(16, 11825, 4, metadata_signature); }
    $AccountLimits_Window_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)) := true];
    $LibraAccount_LibraAccount_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address(payee) := true];
    $LibraAccount_Balance_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee) := true];

    // bytecode translation starts here
    // $t14 := move(payer)
    call $t14 := $CopyOrMoveValue(payer);

    // $t15 := move(payee)
    call $t15 := $CopyOrMoveValue(payee);

    // $t16 := move(to_deposit)
    call $t16 := $CopyOrMoveValue(to_deposit);

    // $t17 := move(metadata)
    call $t17 := $CopyOrMoveValue(metadata);

    // $t18 := move(metadata_signature)
    call $t18 := $CopyOrMoveValue(metadata_signature);

    // LibraTimestamp::assert_operating()
    call $LibraTimestamp_assert_operating();
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 12088, $abort_code);
      goto Abort;
    }

    // AccountFreezing::assert_not_frozen($t15)
    call $AccountFreezing_assert_not_frozen($t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 12133, $abort_code);
      goto Abort;
    }

    // deposit_value := Libra::value<#0>($t16)
    call deposit_value := $Libra_value($tv0, $t16);
    if ($abort_flag) {
      goto Abort;
    }

    // $t19 := 0
    $t19 := $Integer(0);

    // $t20 := >(deposit_value, $t19)
    call $t20 := $Gt(deposit_value, $t19);

    // $t21 := 2
    $t21 := $Integer(2);

    // $t22 := Errors::invalid_argument($t21)
    call $t22 := $Errors_invalid_argument($t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 12313, $abort_code);
      goto Abort;
    }

    // if ($t20) goto L0 else goto L1
    if (b#$Boolean($t20)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t22)
    if (true) { assume $DebugTrackAbort(16, 12279, i#$Integer($t22)); }
    $abort_code := i#$Integer($t22);
    goto Abort;

    // L0:
L0:

    // $t23 := LibraAccount::exists_at($t15)
    call $t23 := $LibraAccount_exists_at($t15);
    if ($abort_flag) {
      goto Abort;
    }

    // $t24 := 17
    $t24 := $Integer(17);

    // $t25 := Errors::not_published($t24)
    call $t25 := $Errors_not_published($t24);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 12447, $abort_code);
      goto Abort;
    }

    // if ($t23) goto L2 else goto L3
    if (b#$Boolean($t23)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t25)
    if (true) { assume $DebugTrackAbort(16, 12414, i#$Integer($t25)); }
    $abort_code := i#$Integer($t25);
    goto Abort;

    // L2:
L2:

    // $t26 := exists<LibraAccount::Balance<#0>>($t15)
    $t26 := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t15);

    // $t27 := 18
    $t27 := $Integer(18);

    // $t28 := Errors::invalid_argument($t27)
    call $t28 := $Errors_invalid_argument($t27);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 12626, $abort_code);
      goto Abort;
    }

    // if ($t26) goto L4 else goto L5
    if (b#$Boolean($t26)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // abort($t28)
    if (true) { assume $DebugTrackAbort(16, 12555, i#$Integer($t28)); }
    $abort_code := i#$Integer($t28);
    goto Abort;

    // L4:
L4:

    // DualAttestation::assert_payment_ok<#0>($t14, $t15, deposit_value, $t17, $t18)
    call $DualAttestation_assert_payment_ok($tv0, $t14, $t15, deposit_value, $t17, $t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 12785, $abort_code);
      goto Abort;
    }

    // $t29 := false
    $t29 := $Boolean(false);

    // $t30 := LibraAccount::should_track_limits_for_account<#0>($t14, $t15, $t29)
    call $t30 := $LibraAccount_should_track_limits_for_account($tv0, $t14, $t15, $t29);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 10266, $abort_code);
      goto Abort;
    }

    // if ($t30) goto L6 else goto L7
    if (b#$Boolean($t30)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // goto L8
    goto L8;

    // L6:
L6:

    // $t31 := VASP::parent_address($t15)
    call $t31 := $VASP_parent_address($t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 13215, $abort_code);
      goto Abort;
    }

    // $t32 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t32 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t33 := get_global<LibraAccount::AccountOperationsCapability>($t32)
    call $t33 := $GetGlobal($LibraAccount_AccountOperationsCapability_$memory, $t32, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 13259, $abort_code);
      goto Abort;
    }

    // $t34 := get_field<LibraAccount::AccountOperationsCapability>.limits_cap($t33)
    call $t34 := $GetFieldFromValue($t33, $LibraAccount_AccountOperationsCapability_limits_cap);

    // $t35 := AccountLimits::update_deposit_limits<#0>(deposit_value, $t31, $t34)
    call $t35 := $AccountLimits_update_deposit_limits($tv0, deposit_value, $t31, $t34, $AccountLimits_Window_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 13124, $abort_code);
      goto Abort;
    }

    // $t36 := 3
    $t36 := $Integer(3);

    // $t37 := Errors::limit_exceeded($t36)
    call $t37 := $Errors_limit_exceeded($t36);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 13393, $abort_code);
      goto Abort;
    }

    // if ($t35) goto L8 else goto L9
    if (b#$Boolean($t35)) { goto L8; } else { goto L9; }

    // L9:
L9:

    // abort($t37)
    if (true) { assume $DebugTrackAbort(16, 13085, i#$Integer($t37)); }
    $abort_code := i#$Integer($t37);
    goto Abort;

    // L8:
L8:

    // $t38 := borrow_global<LibraAccount::Balance<#0>>($t15)
    assert $LibraAccount_Balance_$SelfDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($t15)];
    call $t38 := $BorrowGlobal($LibraAccount_Balance_$memory, $t15, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 13528, $abort_code);
      goto Abort;
    }

    // unpack_ref($t38)

    // $t39 := borrow_field<LibraAccount::Balance<#0>>.coin($t38)
    call $t39 := $BorrowField($t38, $LibraAccount_Balance_coin);

    // unpack_ref($t39)

    // $t40 := read_ref($t39)
    call $t40 := $ReadRef($t39);
    assert $Libra_Libra_$invariant_holds($t40);

    // $t40 := Libra::deposit<#0>($t40, $t16)
    call $t40 := $Libra_deposit($tv0, $t40, $t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 13515, $abort_code);
      goto Abort;
    }

    // write_ref($t39, $t40)
    call $t39 := $WriteRef($t39, $t40);

    // pack_ref($t39)

    // write_back[Reference($t38)]($t39)
    call $t38 := $WritebackToReference($t39, $t38);

    // pack_ref($t38)

    // write_back[LibraAccount::Balance]($t38)
    call $LibraAccount_Balance_$memory := $WritebackToGlobal($LibraAccount_Balance_$memory, $t38);

    // $t41 := borrow_global<LibraAccount::LibraAccount>($t15)
    assert $LibraAccount_LibraAccount_$SelfDomain[$EmptyTypeValueArray, a#$Address($t15)];
    call $t41 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, $t15, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 13687, $abort_code);
      goto Abort;
    }

    // unpack_ref($t41)
    call $LibraAccount_LibraAccount_$unpack_ref($Dereference($t41));

    // $t42 := borrow_field<LibraAccount::LibraAccount>.received_events($t41)
    call $t42 := $BorrowField($t41, $LibraAccount_LibraAccount_received_events);

    // unpack_ref($t42)

    // $t43 := Libra::currency_code<#0>()
    call $t43 := $Libra_currency_code($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 13855, $abort_code);
      goto Abort;
    }

    // $t44 := pack LibraAccount::ReceivedPaymentEvent(deposit_value, $t43, $t14, $t17)
    call $t44 := $LibraAccount_ReceivedPaymentEvent_pack(0, 0, 0, deposit_value, $t43, $t14, $t17);

    // $t45 := read_ref($t42)
    call $t45 := $ReadRef($t42);
    assert $Event_EventHandle_$invariant_holds($t45);

    // $t45 := Event::emit_event<LibraAccount::ReceivedPaymentEvent>($t45, $t44)
    call $t45 := $Event_emit_event($LibraAccount_ReceivedPaymentEvent_type_value(), $t45, $t44);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 13636, $abort_code);
      goto Abort;
    }

    // write_ref($t42, $t45)
    call $t42 := $WriteRef($t42, $t45);

    // pack_ref($t42)

    // write_back[Reference($t41)]($t42)
    call $t41 := $WritebackToReference($t42, $t41);

    // pack_ref($t41)
    call $LibraAccount_LibraAccount_$pack_ref($Dereference($t41));

    // write_back[LibraAccount::LibraAccount]($t41)
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t41);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_deposit_$direct_intra($tv0: $TypeValue, payer: $Value, payee: $Value, to_deposit: $Value, metadata: $Value, metadata_signature: $Value, $AccountLimits_Window_$CallerDomain: [$TypeValueArray, int]bool, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool, $LibraAccount_Balance_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $AccountLimits_Window_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))];
requires $LibraAccount_LibraAccount_$CallerDomain[$EmptyTypeValueArray, a#$Address(payee)];
requires $LibraAccount_Balance_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee)];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, payee))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean($IsEqual($SelectField(to_deposit, $Libra_Libra_value), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, $SelectField(to_deposit, $Libra_Libra_value), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64($SelectField(to_deposit, $Libra_Libra_value), $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, $SelectField(to_deposit, $Libra_Libra_value)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_limit_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_window_inflow)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_tracked_balance)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, payee))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, payee)))))
    || b#$Boolean(old($Boolean($IsEqual($SelectField(to_deposit, $Libra_Libra_value), $Integer(0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, $SelectField(to_deposit, $Libra_Libra_value), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64($SelectField(to_deposit, $Libra_Libra_value), $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, $SelectField(to_deposit, $Libra_Libra_value))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_limit_address))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_window_inflow)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_tracked_balance)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, payee)))
    || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, payee))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean($IsEqual($SelectField(to_deposit, $Libra_Libra_value), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, $SelectField(to_deposit, $Libra_Libra_value), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64($SelectField(to_deposit, $Libra_Libra_value), $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, $SelectField(to_deposit, $Libra_Libra_value)))))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_limit_address)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_window_inflow)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_tracked_balance)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, payee))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, payee)));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, payee), $LibraAccount_LibraAccount_withdrawal_capability), old($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, payee), $LibraAccount_LibraAccount_withdrawal_capability))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, payee), $Integer(i#$Integer(old($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, payee))) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1), $LibraAccount_LibraAccount_authentication_key), old($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1), $LibraAccount_LibraAccount_authentication_key)))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr1))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr1), $LibraAccount_Balance_coin), $Libra_Libra_value)) >= i#$Integer(old($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr1), $LibraAccount_Balance_coin), $Libra_Libra_value)))))))))));
modifies $AccountLimits_Window_$memory;
ensures contents#$Memory($AccountLimits_Window_$memory) == old(contents#$Memory($AccountLimits_Window_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)) := contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))]];
ensures domain#$Memory($AccountLimits_Window_$memory) == old(domain#$Memory($AccountLimits_Window_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)) := domain#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))]];
modifies $LibraAccount_LibraAccount_$memory;
ensures contents#$Memory($LibraAccount_LibraAccount_$memory) == old(contents#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address(payee) := contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address(payee)]];
ensures domain#$Memory($LibraAccount_LibraAccount_$memory) == old(domain#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address(payee) := domain#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address(payee)]];
modifies $LibraAccount_Balance_$memory;
ensures contents#$Memory($LibraAccount_Balance_$memory) == old(contents#$Memory($LibraAccount_Balance_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee) := contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee)]];
ensures domain#$Memory($LibraAccount_Balance_$memory) == old(domain#$Memory($LibraAccount_Balance_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee) := domain#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee)]];

procedure {:inline 1} $LibraAccount_deposit($tv0: $TypeValue, payer: $Value, payee: $Value, to_deposit: $Value, metadata: $Value, metadata_signature: $Value, $AccountLimits_Window_$CallerDomain: [$TypeValueArray, int]bool, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool, $LibraAccount_Balance_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $AccountLimits_Window_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))];
requires $LibraAccount_LibraAccount_$CallerDomain[$EmptyTypeValueArray, a#$Address(payee)];
requires $LibraAccount_Balance_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee)];
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, payee))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean($IsEqual($SelectField(to_deposit, $Libra_Libra_value), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, $SelectField(to_deposit, $Libra_Libra_value), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64($SelectField(to_deposit, $Libra_Libra_value), $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, $SelectField(to_deposit, $Libra_Libra_value)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_limit_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_window_inflow)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_tracked_balance)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, payee))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, payee)))))
    || b#$Boolean(old($Boolean($IsEqual($SelectField(to_deposit, $Libra_Libra_value), $Integer(0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, $SelectField(to_deposit, $Libra_Libra_value), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64($SelectField(to_deposit, $Libra_Libra_value), $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, $SelectField(to_deposit, $Libra_Libra_value))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_limit_address))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_window_inflow)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_tracked_balance)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, payee)))
    || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, payee))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean($IsEqual($SelectField(to_deposit, $Libra_Libra_value), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, $SelectField(to_deposit, $Libra_Libra_value), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64($SelectField(to_deposit, $Libra_Libra_value), $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, payer, payee, metadata_signature, metadata, $SelectField(to_deposit, $Libra_Libra_value)))))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_limit_address)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_window_inflow)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_tracked_balance)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, payee))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) &&
       $abort_code == i#$Integer($Integer(8))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, payee)));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, payee), $LibraAccount_LibraAccount_withdrawal_capability), old($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, payee), $LibraAccount_LibraAccount_withdrawal_capability))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, payee), $Integer(i#$Integer(old($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, payee))) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))))));
modifies $AccountLimits_Window_$memory;
ensures contents#$Memory($AccountLimits_Window_$memory) == old(contents#$Memory($AccountLimits_Window_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)) := contents#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))]];
ensures domain#$Memory($AccountLimits_Window_$memory) == old(domain#$Memory($AccountLimits_Window_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)) := domain#$Memory($AccountLimits_Window_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))]];
modifies $LibraAccount_LibraAccount_$memory;
ensures contents#$Memory($LibraAccount_LibraAccount_$memory) == old(contents#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address(payee) := contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address(payee)]];
ensures domain#$Memory($LibraAccount_LibraAccount_$memory) == old(domain#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address(payee) := domain#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address(payee)]];
modifies $LibraAccount_Balance_$memory;
ensures contents#$Memory($LibraAccount_Balance_$memory) == old(contents#$Memory($LibraAccount_Balance_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee) := contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee)]];
ensures domain#$Memory($LibraAccount_Balance_$memory) == old(domain#$Memory($LibraAccount_Balance_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee) := domain#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee)]];

procedure {:inline 1} $LibraAccount_add_currency_$def($tv0: $TypeValue, account: $Value) returns ()
{
    // declare local variables
    var addr: $Value; // $AddressType()
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $BooleanType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $Libra_Libra_type_value($tv0)
    var $t15: $Value; // $LibraAccount_Balance_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 54078, 0, account); }

    // bytecode translation starts here
    // $t6 := move(account)
    call $t6 := $CopyOrMoveValue(account);

    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 54210, $abort_code);
      goto Abort;
    }

    // $t7 := Roles::can_hold_balance($t6)
    call $t7 := $Roles_can_hold_balance($t6);
    if ($abort_flag) {
      goto Abort;
    }

    // $t8 := 4
    $t8 := $Integer(4);

    // $t9 := Errors::invalid_argument($t8)
    call $t9 := $Errors_invalid_argument($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 54394, $abort_code);
      goto Abort;
    }

    // if ($t7) goto L0 else goto L1
    if (b#$Boolean($t7)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t6)

    // abort($t9)
    if (true) { assume $DebugTrackAbort(16, 54320, i#$Integer($t9)); }
    $abort_code := i#$Integer($t9);
    goto Abort;

    // L0:
L0:

    // addr := Signer::address_of($t6)
    call addr := $Signer_address_of($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 54542, $abort_code);
      goto Abort;
    }

    // $t10 := exists<LibraAccount::Balance<#0>>(addr)
    $t10 := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr);

    // $t11 := !($t10)
    call $t11 := $Not($t10);

    // $t12 := 15
    $t12 := $Integer(15);

    // $t13 := Errors::already_published($t12)
    call $t13 := $Errors_already_published($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 54617, $abort_code);
      goto Abort;
    }

    // if ($t11) goto L2 else goto L3
    if (b#$Boolean($t11)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // destroy($t6)

    // abort($t13)
    if (true) { assume $DebugTrackAbort(16, 54571, i#$Integer($t13)); }
    $abort_code := i#$Integer($t13);
    goto Abort;

    // L2:
L2:

    // $t14 := Libra::zero<#0>()
    call $t14 := $Libra_zero($tv0);
    if ($abort_flag) {
      goto Abort;
    }

    // $t15 := pack LibraAccount::Balance<#0>($t14)
    call $t15 := $LibraAccount_Balance_pack(0, 0, 0, $tv0, $t14);

    // move_to<LibraAccount::Balance<#0>>($t15, $t6)
    call $LibraAccount_Balance_$memory := $MoveTo($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t15, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 54670, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_add_currency_$direct_inter($tv0: $TypeValue, account: $Value) returns ()
{
    assume is#$Address(account);

    call $LibraAccount_add_currency_$def($tv0, account);
}


procedure {:inline 1} $LibraAccount_add_currency_$direct_intra($tv0: $TypeValue, account: $Value) returns ()
{
    assume is#$Address(account);

    call $LibraAccount_add_currency_$def($tv0, account);
}


procedure {:inline 1} $LibraAccount_add_currency($tv0: $TypeValue, account: $Value) returns ()
{
    assume is#$Address(account);

    call $LibraAccount_add_currency_$def($tv0, account);
}


procedure {:inline 1} $LibraAccount_exists_at_$def(check_addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 57918, 0, check_addr); }

    // bytecode translation starts here
    // $t1 := move(check_addr)
    call $t1 := $CopyOrMoveValue(check_addr);

    // $t2 := exists<LibraAccount::LibraAccount>($t1)
    $t2 := $ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $t1);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(16, 57976, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraAccount_exists_at_$direct_inter(check_addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(check_addr);

    call $ret0 := $LibraAccount_exists_at_$def(check_addr);
}


procedure {:inline 1} $LibraAccount_exists_at_$direct_intra(check_addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(check_addr);

    call $ret0 := $LibraAccount_exists_at_$def(check_addr);
}


procedure {:inline 1} $LibraAccount_exists_at(check_addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(check_addr);

    call $ret0 := $LibraAccount_exists_at_$def(check_addr);
}


procedure {:inline 1} $LibraAccount_tiered_mint_$def($tv0: $TypeValue, tc_account: $Value, designated_dealer_address: $Value, mint_amount: $Value, tier_index: $Value, $Libra_CurrencyInfo_$CallerDomain: [$TypeValueArray, int]bool, $LibraAccount_Balance_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var coin: $Value; // $Libra_Libra_type_value($tv0)
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $Vector_type_value($IntegerType())
    var $t11: $Value; // $Vector_type_value($IntegerType())
    var $Libra_CurrencyInfo_$SelfDomain: [$TypeValueArray, int]bool;
    var $LibraAccount_Balance_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 16444, 0, tc_account); }
    if (true) { assume $DebugTrackLocal(16, 16444, 1, designated_dealer_address); }
    if (true) { assume $DebugTrackLocal(16, 16444, 2, mint_amount); }
    if (true) { assume $DebugTrackLocal(16, 16444, 3, tier_index); }
    $Libra_CurrencyInfo_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := true];
    $LibraAccount_Balance_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(designated_dealer_address) := true];

    // bytecode translation starts here
    // $t5 := move(tc_account)
    call $t5 := $CopyOrMoveValue(tc_account);

    // $t6 := move(designated_dealer_address)
    call $t6 := $CopyOrMoveValue(designated_dealer_address);

    // $t7 := move(mint_amount)
    call $t7 := $CopyOrMoveValue(mint_amount);

    // $t8 := move(tier_index)
    call $t8 := $CopyOrMoveValue(tier_index);

    // coin := DesignatedDealer::tiered_mint<#0>($t5, $t7, $t6, $t8)
    call coin := $DesignatedDealer_tiered_mint($tv0, $t5, $t7, $t6, $t8, $Libra_CurrencyInfo_$SelfDomain, $ConstMemoryDomain(true));
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 16704, $abort_code);
      goto Abort;
    }

    // $t9 := CoreAddresses::VM_RESERVED_ADDRESS()
    call $t9 := $CoreAddresses_VM_RESERVED_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t10 := []
    $t10 := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));

    // $t11 := []
    $t11 := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));

    // LibraAccount::deposit<#0>($t9, $t6, coin, $t10, $t11)
    call $LibraAccount_deposit($tv0, $t9, $t6, coin, $t10, $t11, $ConstMemoryDomain(true), $ConstMemoryDomain(true), $LibraAccount_Balance_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 11829, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_tiered_mint_$direct_inter($tv0: $TypeValue, tc_account: $Value, designated_dealer_address: $Value, mint_amount: $Value, tier_index: $Value, $Libra_CurrencyInfo_$CallerDomain: [$TypeValueArray, int]bool, $LibraAccount_Balance_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $Libra_CurrencyInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())];
requires $LibraAccount_Balance_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(designated_dealer_address)];
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean($IsEqual(mint_amount, $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, designated_dealer_address), $DesignatedDealer_TierInfo_tiers)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($DesignatedDealer_new_amount$9($LibraTimestamp_CurrentTimeMicroseconds_$memory, $DesignatedDealer_TierInfo_$memory, $tv0, mint_amount, designated_dealer_address)) > i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, designated_dealer_address), $DesignatedDealer_TierInfo_tiers), tier_index))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, designated_dealer_address))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U128))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, designated_dealer_address))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean($IsEqual(mint_amount, $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, mint_amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(mint_amount, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Vector($ValueArray($MapConstValue($DefaultValue()), 0)), $Vector($ValueArray($MapConstValue($DefaultValue()), 0)), mint_amount))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)), $AccountLimits_Window_limit_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_Window_window_inflow)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_Window_tracked_balance)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, designated_dealer_address))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64)))))
    || b#$Boolean(old($Boolean($IsEqual(mint_amount, $Integer(0)))))
    || b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, designated_dealer_address), $DesignatedDealer_TierInfo_tiers))))))
    || b#$Boolean(old($Boolean(i#$Integer($DesignatedDealer_new_amount$9($LibraTimestamp_CurrentTimeMicroseconds_$memory, $DesignatedDealer_TierInfo_$memory, $tv0, mint_amount, designated_dealer_address)) > i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, designated_dealer_address), $DesignatedDealer_TierInfo_tiers), tier_index)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, designated_dealer_address)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint)))))
    || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U128)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, designated_dealer_address)))))
    || b#$Boolean(old($Boolean($IsEqual(mint_amount, $Integer(0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, mint_amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(mint_amount, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Vector($ValueArray($MapConstValue($DefaultValue()), 0)), $Vector($ValueArray($MapConstValue($DefaultValue()), 0)), mint_amount)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)), $AccountLimits_Window_limit_address))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_Window_window_inflow)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_Window_tracked_balance)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, designated_dealer_address))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean($IsEqual(mint_amount, $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, designated_dealer_address), $DesignatedDealer_TierInfo_tiers)))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(i#$Integer($DesignatedDealer_new_amount$9($LibraTimestamp_CurrentTimeMicroseconds_$memory, $DesignatedDealer_TierInfo_$memory, $tv0, mint_amount, designated_dealer_address)) > i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, designated_dealer_address), $DesignatedDealer_TierInfo_tiers), tier_index))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(4)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, designated_dealer_address))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U128))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, designated_dealer_address))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean($IsEqual(mint_amount, $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, mint_amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(mint_amount, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Vector($ValueArray($MapConstValue($DefaultValue()), 0)), $Vector($ValueArray($MapConstValue($DefaultValue()), 0)), mint_amount))))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)), $AccountLimits_Window_limit_address)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_Window_window_inflow)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_Window_tracked_balance)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, designated_dealer_address))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraAccount_currency_info$61($Libra_CurrencyInfo_$memory, $tv0), $UpdateField(old($LibraAccount_currency_info$61($Libra_CurrencyInfo_$memory, $tv0)), $Libra_CurrencyInfo_total_value, $Integer(i#$Integer(old($SelectField($LibraAccount_currency_info$61($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))) + i#$Integer(mint_amount)))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraAccount_dealer_balance$60($LibraAccount_Balance_$memory, $tv0, designated_dealer_address), $Integer(i#$Integer(old($LibraAccount_dealer_balance$60($LibraAccount_Balance_$memory, $tv0, designated_dealer_address))) + i#$Integer(mint_amount))))));
modifies $AccountLimits_Window_$memory;
modifies $Libra_CurrencyInfo_$memory;
ensures contents#$Memory($Libra_CurrencyInfo_$memory) == old(contents#$Memory($Libra_CurrencyInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())]];
ensures domain#$Memory($Libra_CurrencyInfo_$memory) == old(domain#$Memory($Libra_CurrencyInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := domain#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())]];
modifies $DesignatedDealer_Dealer_$memory;
modifies $DesignatedDealer_TierInfo_$memory;
modifies $LibraAccount_LibraAccount_$memory;
modifies $LibraAccount_Balance_$memory;
ensures contents#$Memory($LibraAccount_Balance_$memory) == old(contents#$Memory($LibraAccount_Balance_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(designated_dealer_address) := contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(designated_dealer_address)]];
ensures domain#$Memory($LibraAccount_Balance_$memory) == old(domain#$Memory($LibraAccount_Balance_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(designated_dealer_address) := domain#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(designated_dealer_address)]];

procedure {:inline 1} $LibraAccount_tiered_mint_$direct_intra($tv0: $TypeValue, tc_account: $Value, designated_dealer_address: $Value, mint_amount: $Value, tier_index: $Value, $Libra_CurrencyInfo_$CallerDomain: [$TypeValueArray, int]bool, $LibraAccount_Balance_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $Libra_CurrencyInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())];
requires $LibraAccount_Balance_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(designated_dealer_address)];
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean($IsEqual(mint_amount, $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, designated_dealer_address), $DesignatedDealer_TierInfo_tiers)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($DesignatedDealer_new_amount$9($LibraTimestamp_CurrentTimeMicroseconds_$memory, $DesignatedDealer_TierInfo_$memory, $tv0, mint_amount, designated_dealer_address)) > i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, designated_dealer_address), $DesignatedDealer_TierInfo_tiers), tier_index))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, designated_dealer_address))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U128))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, designated_dealer_address))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean($IsEqual(mint_amount, $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, mint_amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(mint_amount, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Vector($ValueArray($MapConstValue($DefaultValue()), 0)), $Vector($ValueArray($MapConstValue($DefaultValue()), 0)), mint_amount))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)), $AccountLimits_Window_limit_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_Window_window_inflow)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_Window_tracked_balance)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, designated_dealer_address))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64)))))
    || b#$Boolean(old($Boolean($IsEqual(mint_amount, $Integer(0)))))
    || b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, designated_dealer_address), $DesignatedDealer_TierInfo_tiers))))))
    || b#$Boolean(old($Boolean(i#$Integer($DesignatedDealer_new_amount$9($LibraTimestamp_CurrentTimeMicroseconds_$memory, $DesignatedDealer_TierInfo_$memory, $tv0, mint_amount, designated_dealer_address)) > i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, designated_dealer_address), $DesignatedDealer_TierInfo_tiers), tier_index)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, designated_dealer_address)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint)))))
    || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U128)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, designated_dealer_address)))))
    || b#$Boolean(old($Boolean($IsEqual(mint_amount, $Integer(0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, mint_amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(mint_amount, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Vector($ValueArray($MapConstValue($DefaultValue()), 0)), $Vector($ValueArray($MapConstValue($DefaultValue()), 0)), mint_amount)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)), $AccountLimits_Window_limit_address))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_Window_window_inflow)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_Window_tracked_balance)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, designated_dealer_address))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean($IsEqual(mint_amount, $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, designated_dealer_address), $DesignatedDealer_TierInfo_tiers)))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(i#$Integer($DesignatedDealer_new_amount$9($LibraTimestamp_CurrentTimeMicroseconds_$memory, $DesignatedDealer_TierInfo_$memory, $tv0, mint_amount, designated_dealer_address)) > i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, designated_dealer_address), $DesignatedDealer_TierInfo_tiers), tier_index))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(4)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, designated_dealer_address))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U128))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, designated_dealer_address))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean($IsEqual(mint_amount, $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, mint_amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(mint_amount, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Vector($ValueArray($MapConstValue($DefaultValue()), 0)), $Vector($ValueArray($MapConstValue($DefaultValue()), 0)), mint_amount))))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)), $AccountLimits_Window_limit_address)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_Window_window_inflow)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_Window_tracked_balance)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, designated_dealer_address))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraAccount_currency_info$61($Libra_CurrencyInfo_$memory, $tv0), $UpdateField(old($LibraAccount_currency_info$61($Libra_CurrencyInfo_$memory, $tv0)), $Libra_CurrencyInfo_total_value, $Integer(i#$Integer(old($SelectField($LibraAccount_currency_info$61($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))) + i#$Integer(mint_amount)))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraAccount_dealer_balance$60($LibraAccount_Balance_$memory, $tv0, designated_dealer_address), $Integer(i#$Integer(old($LibraAccount_dealer_balance$60($LibraAccount_Balance_$memory, $tv0, designated_dealer_address))) + i#$Integer(mint_amount))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1), $LibraAccount_LibraAccount_authentication_key), old($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1), $LibraAccount_LibraAccount_authentication_key)))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr1))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr1), $LibraAccount_Balance_coin), $Libra_Libra_value)) >= i#$Integer(old($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr1), $LibraAccount_Balance_coin), $Libra_Libra_value)))))))))));
modifies $AccountLimits_Window_$memory;
modifies $Libra_CurrencyInfo_$memory;
ensures contents#$Memory($Libra_CurrencyInfo_$memory) == old(contents#$Memory($Libra_CurrencyInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())]];
ensures domain#$Memory($Libra_CurrencyInfo_$memory) == old(domain#$Memory($Libra_CurrencyInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := domain#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())]];
modifies $DesignatedDealer_Dealer_$memory;
modifies $DesignatedDealer_TierInfo_$memory;
modifies $LibraAccount_LibraAccount_$memory;
modifies $LibraAccount_Balance_$memory;
ensures contents#$Memory($LibraAccount_Balance_$memory) == old(contents#$Memory($LibraAccount_Balance_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(designated_dealer_address) := contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(designated_dealer_address)]];
ensures domain#$Memory($LibraAccount_Balance_$memory) == old(domain#$Memory($LibraAccount_Balance_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(designated_dealer_address) := domain#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(designated_dealer_address)]];

procedure {:inline 1} $LibraAccount_tiered_mint($tv0: $TypeValue, tc_account: $Value, designated_dealer_address: $Value, mint_amount: $Value, tier_index: $Value, $Libra_CurrencyInfo_$CallerDomain: [$TypeValueArray, int]bool, $LibraAccount_Balance_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $Libra_CurrencyInfo_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())];
requires $LibraAccount_Balance_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(designated_dealer_address)];
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean($IsEqual(mint_amount, $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, designated_dealer_address), $DesignatedDealer_TierInfo_tiers)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($DesignatedDealer_new_amount$9($LibraTimestamp_CurrentTimeMicroseconds_$memory, $DesignatedDealer_TierInfo_$memory, $tv0, mint_amount, designated_dealer_address)) > i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, designated_dealer_address), $DesignatedDealer_TierInfo_tiers), tier_index))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, designated_dealer_address))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U128))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, designated_dealer_address))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean($IsEqual(mint_amount, $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, mint_amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(mint_amount, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Vector($ValueArray($MapConstValue($DefaultValue()), 0)), $Vector($ValueArray($MapConstValue($DefaultValue()), 0)), mint_amount))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)), $AccountLimits_Window_limit_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_Window_window_inflow)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_Window_tracked_balance)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, designated_dealer_address))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64)))))
    || b#$Boolean(old($Boolean($IsEqual(mint_amount, $Integer(0)))))
    || b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, designated_dealer_address), $DesignatedDealer_TierInfo_tiers))))))
    || b#$Boolean(old($Boolean(i#$Integer($DesignatedDealer_new_amount$9($LibraTimestamp_CurrentTimeMicroseconds_$memory, $DesignatedDealer_TierInfo_$memory, $tv0, mint_amount, designated_dealer_address)) > i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, designated_dealer_address), $DesignatedDealer_TierInfo_tiers), tier_index)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS()))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, designated_dealer_address)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint)))))
    || b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U128)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, designated_dealer_address)))))
    || b#$Boolean(old($Boolean($IsEqual(mint_amount, $Integer(0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, mint_amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(mint_amount, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Vector($ValueArray($MapConstValue($DefaultValue()), 0)), $Vector($ValueArray($MapConstValue($DefaultValue()), 0)), mint_amount)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)), $AccountLimits_Window_limit_address))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_Window_window_inflow)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_Window_tracked_balance)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, designated_dealer_address))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean($IsEqual(mint_amount, $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(i#$Integer(tier_index) >= i#$Integer($vlen_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, designated_dealer_address), $DesignatedDealer_TierInfo_tiers)))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(i#$Integer($DesignatedDealer_new_amount$9($LibraTimestamp_CurrentTimeMicroseconds_$memory, $DesignatedDealer_TierInfo_$memory, $tv0, mint_amount, designated_dealer_address)) > i#$Integer($select_vector_by_value($SelectField($DesignatedDealer_tier_info$8($DesignatedDealer_TierInfo_$memory, $tv0, designated_dealer_address), $DesignatedDealer_TierInfo_tiers), tier_index))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $Signer_spec_address_of(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(4)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, designated_dealer_address))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_can_mint))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U128))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), designated_dealer_address))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, designated_dealer_address))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean($IsEqual(mint_amount, $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, mint_amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(mint_amount, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Vector($ValueArray($MapConstValue($DefaultValue()), 0)), $Vector($ValueArray($MapConstValue($DefaultValue()), 0)), mint_amount))))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value($Vector($ValueArray($MapConstValue($DefaultValue()), 0))), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, mint_amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)), $AccountLimits_Window_limit_address)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_Window_window_inflow)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_Window_tracked_balance)) + i#$Integer(mint_amount))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $CoreAddresses_$VM_RESERVED_ADDRESS(), designated_dealer_address, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, designated_dealer_address)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, designated_dealer_address))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraAccount_currency_info$61($Libra_CurrencyInfo_$memory, $tv0), $UpdateField(old($LibraAccount_currency_info$61($Libra_CurrencyInfo_$memory, $tv0)), $Libra_CurrencyInfo_total_value, $Integer(i#$Integer(old($SelectField($LibraAccount_currency_info$61($Libra_CurrencyInfo_$memory, $tv0), $Libra_CurrencyInfo_total_value))) + i#$Integer(mint_amount)))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraAccount_dealer_balance$60($LibraAccount_Balance_$memory, $tv0, designated_dealer_address), $Integer(i#$Integer(old($LibraAccount_dealer_balance$60($LibraAccount_Balance_$memory, $tv0, designated_dealer_address))) + i#$Integer(mint_amount))))));
modifies $AccountLimits_Window_$memory;
modifies $Libra_CurrencyInfo_$memory;
ensures contents#$Memory($Libra_CurrencyInfo_$memory) == old(contents#$Memory($Libra_CurrencyInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())]];
ensures domain#$Memory($Libra_CurrencyInfo_$memory) == old(domain#$Memory($Libra_CurrencyInfo_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS()) := domain#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($CoreAddresses_$CURRENCY_INFO_ADDRESS())]];
modifies $DesignatedDealer_Dealer_$memory;
modifies $DesignatedDealer_TierInfo_$memory;
modifies $LibraAccount_LibraAccount_$memory;
modifies $LibraAccount_Balance_$memory;
ensures contents#$Memory($LibraAccount_Balance_$memory) == old(contents#$Memory($LibraAccount_Balance_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(designated_dealer_address) := contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(designated_dealer_address)]];
ensures domain#$Memory($LibraAccount_Balance_$memory) == old(domain#$Memory($LibraAccount_Balance_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(designated_dealer_address) := domain#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(designated_dealer_address)]];

procedure {:inline 1} $LibraAccount_balance_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $LibraAccount_Balance_type_value($tv0)
    var $t8: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 53681, 0, addr); }

    // bytecode translation starts here
    // $t3 := move(addr)
    call $t3 := $CopyOrMoveValue(addr);

    // $t4 := exists<LibraAccount::Balance<#0>>($t3)
    $t4 := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t3);

    // $t5 := 19
    $t5 := $Integer(19);

    // $t6 := Errors::not_published($t5)
    call $t6 := $Errors_not_published($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 53799, $abort_code);
      goto Abort;
    }

    // if ($t4) goto L0 else goto L1
    if (b#$Boolean($t4)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t6)
    if (true) { assume $DebugTrackAbort(16, 53754, i#$Integer($t6)); }
    $abort_code := i#$Integer($t6);
    goto Abort;

    // L0:
L0:

    // $t7 := get_global<LibraAccount::Balance<#0>>($t3)
    call $t7 := $GetGlobal($LibraAccount_Balance_$memory, $t3, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 53864, $abort_code);
      goto Abort;
    }

    // $t8 := LibraAccount::balance_for<#0>($t7)
    call $t8 := $LibraAccount_balance_for($tv0, $t7);
    if ($abort_flag) {
      goto Abort;
    }

    // return $t8
    $ret0 := $t8;
    if (true) { assume $DebugTrackLocal(16, 53852, 9, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraAccount_balance_$direct_inter($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $LibraAccount_balance_$def($tv0, addr);
}


procedure {:inline 1} $LibraAccount_balance_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $LibraAccount_balance_$def($tv0, addr);
}


procedure {:inline 1} $LibraAccount_balance($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $LibraAccount_balance_$def($tv0, addr);
}


procedure {:inline 1} $LibraAccount_accepts_currency_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 55940, 0, addr); }

    // bytecode translation starts here
    // $t1 := move(addr)
    call $t1 := $CopyOrMoveValue(addr);

    // $t2 := exists<LibraAccount::Balance<#0>>($t1)
    $t2 := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $t1);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(16, 56006, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraAccount_accepts_currency_$direct_inter($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $LibraAccount_accepts_currency_$def($tv0, addr);
}


procedure {:inline 1} $LibraAccount_accepts_currency_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $LibraAccount_accepts_currency_$def($tv0, addr);
}


procedure {:inline 1} $LibraAccount_accepts_currency($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $LibraAccount_accepts_currency_$def($tv0, addr);
}


procedure {:inline 1} $LibraAccount_add_currencies_for_account_$def($tv0: $TypeValue, new_account: $Value, add_all_currencies: $Value) returns ()
{
    // declare local variables
    var new_account_addr: $Value; // $AddressType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 37394, 0, new_account); }
    if (true) { assume $DebugTrackLocal(16, 37394, 1, add_all_currencies); }

    // bytecode translation starts here
    // $t3 := move(new_account)
    call $t3 := $CopyOrMoveValue(new_account);

    // $t4 := move(add_all_currencies)
    call $t4 := $CopyOrMoveValue(add_all_currencies);

    // new_account_addr := Signer::address_of($t3)
    call new_account_addr := $Signer_address_of($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 37544, $abort_code);
      goto Abort;
    }

    // LibraAccount::add_currency<#0>($t3)
    call $LibraAccount_add_currency($tv0, $t3);
    if ($abort_flag) {
      goto Abort;
    }

    // if ($t4) goto L0 else goto L1
    if (b#$Boolean($t4)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t5 := exists<LibraAccount::Balance<Coin1::Coin1>>(new_account_addr)
    $t5 := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), new_account_addr);

    // $t6 := !($t5)
    call $t6 := $Not($t5);

    // if ($t6) goto L3 else goto L4
    if (b#$Boolean($t6)) { goto L3; } else { goto L4; }

    // L4:
L4:

    // goto L5
    goto L5;

    // L3:
L3:

    // LibraAccount::add_currency<Coin1::Coin1>($t3)
    call $LibraAccount_add_currency($Coin1_Coin1_type_value(), $t3);
    if ($abort_flag) {
      goto Abort;
    }

    // goto L5
    goto L5;

    // L5:
L5:

    // $t7 := exists<LibraAccount::Balance<LBR::LBR>>(new_account_addr)
    $t7 := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $LBR_LBR_type_value()], 1), new_account_addr);

    // $t8 := !($t7)
    call $t8 := $Not($t7);

    // if ($t8) goto L6 else goto L7
    if (b#$Boolean($t8)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // goto L8
    goto L8;

    // L6:
L6:

    // LibraAccount::add_currency<LBR::LBR>($t3)
    call $LibraAccount_add_currency($LBR_LBR_type_value(), $t3);
    if ($abort_flag) {
      goto Abort;
    }

    // goto L9
    goto L9;

    // L8:
L8:

    // destroy($t3)

    // goto L9
    goto L9;

    // L9:
L9:

    // goto L10
    goto L10;

    // L2:
L2:

    // destroy($t3)

    // goto L10
    goto L10;

    // L10:
L10:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_add_currencies_for_account_$direct_intra($tv0: $TypeValue, new_account: $Value, add_all_currencies: $Value) returns ()
{
    assume is#$Address(new_account);

    assume is#$Boolean(add_all_currencies);

    call $LibraAccount_add_currencies_for_account_$def($tv0, new_account, add_all_currencies);
}


procedure {:inline 1} $LibraAccount_add_currencies_for_account($tv0: $TypeValue, new_account: $Value, add_all_currencies: $Value) returns ()
{
    assume is#$Address(new_account);

    assume is#$Boolean(add_all_currencies);

    call $LibraAccount_add_currencies_for_account_$def($tv0, new_account, add_all_currencies);
}


procedure {:inline 1} $LibraAccount_authentication_key_$def(addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $LibraAccount_LibraAccount_type_value()
    var $t8: $Value; // $Vector_type_value($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 56550, 0, addr); }

    // bytecode translation starts here
    // $t3 := move(addr)
    call $t3 := $CopyOrMoveValue(addr);

    // $t4 := LibraAccount::exists_at($t3)
    call $t4 := $LibraAccount_exists_at($t3);
    if ($abort_flag) {
      goto Abort;
    }

    // $t5 := 0
    $t5 := $Integer(0);

    // $t6 := Errors::not_published($t5)
    call $t6 := $Errors_not_published($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 56671, $abort_code);
      goto Abort;
    }

    // if ($t4) goto L0 else goto L1
    if (b#$Boolean($t4)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t6)
    if (true) { assume $DebugTrackAbort(16, 56639, i#$Integer($t6)); }
    $abort_code := i#$Integer($t6);
    goto Abort;

    // L0:
L0:

    // $t7 := get_global<LibraAccount::LibraAccount>($t3)
    call $t7 := $GetGlobal($LibraAccount_LibraAccount_$memory, $t3, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 56707, $abort_code);
      goto Abort;
    }

    // $t8 := get_field<LibraAccount::LibraAccount>.authentication_key($t7)
    call $t8 := $GetFieldFromValue($t7, $LibraAccount_LibraAccount_authentication_key);

    // return $t8
    $ret0 := $t8;
    if (true) { assume $DebugTrackLocal(16, 56705, 9, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraAccount_authentication_key_$direct_inter(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $LibraAccount_authentication_key_$def(addr);
}


procedure {:inline 1} $LibraAccount_authentication_key_$direct_intra(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $LibraAccount_authentication_key_$def(addr);
}


procedure {:inline 1} $LibraAccount_authentication_key(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $LibraAccount_authentication_key_$def(addr);
}


procedure {:inline 1} $LibraAccount_balance_for_$def($tv0: $TypeValue, balance: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $LibraAccount_Balance_type_value($tv0)
    var $t2: $Value; // $Libra_Libra_type_value($tv0)
    var $t3: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 53510, 0, balance); }

    // bytecode translation starts here
    // $t1 := move(balance)
    call $t1 := $CopyOrMoveValue(balance);

    // $t2 := get_field<LibraAccount::Balance<#0>>.coin($t1)
    call $t2 := $GetFieldFromValue($t1, $LibraAccount_Balance_coin);

    // $t3 := Libra::value<#0>($t2)
    call $t3 := $Libra_value($tv0, $t2);
    if ($abort_flag) {
      goto Abort;
    }

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(16, 53574, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraAccount_balance_for_$direct_intra($tv0: $TypeValue, balance: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_Balance_$is_well_formed(balance);

    call $ret0 := $LibraAccount_balance_for_$def($tv0, balance);
}


procedure {:inline 1} $LibraAccount_balance_for($tv0: $TypeValue, balance: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_Balance_$is_well_formed(balance);

    call $ret0 := $LibraAccount_balance_for_$def($tv0, balance);
}


procedure {:inline 1} $LibraAccount_create_child_vasp_account_$def($tv0: $TypeValue, parent: $Value, new_account_address: $Value, auth_key_prefix: $Value, add_all_currencies: $Value) returns ()
{
    // declare local variables
    var new_account: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $Vector_type_value($IntegerType())
    var $t8: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 51281, 0, parent); }
    if (true) { assume $DebugTrackLocal(16, 51281, 1, new_account_address); }
    if (true) { assume $DebugTrackLocal(16, 51281, 2, auth_key_prefix); }
    if (true) { assume $DebugTrackLocal(16, 51281, 3, add_all_currencies); }

    // bytecode translation starts here
    // $t5 := move(parent)
    call $t5 := $CopyOrMoveValue(parent);

    // $t6 := move(new_account_address)
    call $t6 := $CopyOrMoveValue(new_account_address);

    // $t7 := move(auth_key_prefix)
    call $t7 := $CopyOrMoveValue(auth_key_prefix);

    // $t8 := move(add_all_currencies)
    call $t8 := $CopyOrMoveValue(add_all_currencies);

    // new_account := LibraAccount::create_signer($t6)
    call new_account := $LibraAccount_create_signer($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 53353, $abort_code);
      goto Abort;
    }

    // Roles::new_child_vasp_role($t5, new_account)
    call $Roles_new_child_vasp_role($t5, new_account, $ConstMemoryDomain(true));
    if ($abort_flag) {
      goto Abort;
    }

    // VASP::publish_child_vasp_credential($t5, new_account)
    call $VASP_publish_child_vasp_credential($t5, new_account);
    if ($abort_flag) {
      goto Abort;
    }

    // Event::publish_generator(new_account)
    call $Event_publish_generator(new_account);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 51742, $abort_code);
      goto Abort;
    }

    // LibraAccount::add_currencies_for_account<#0>(new_account, $t8)
    call $LibraAccount_add_currencies_for_account($tv0, new_account, $t8);
    if ($abort_flag) {
      goto Abort;
    }

    // LibraAccount::make_account(new_account, $t7)
    call $LibraAccount_make_account(new_account, $t7);
    if ($abort_flag) {
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_create_child_vasp_account_$direct_inter($tv0: $TypeValue, parent: $Value, new_account_address: $Value, auth_key_prefix: $Value, add_all_currencies: $Value) returns ()
{
    assume is#$Address(parent);

    assume is#$Address(new_account_address);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    assume is#$Boolean(add_all_currencies);

    call $LibraAccount_create_child_vasp_account_$def($tv0, parent, new_account_address, auth_key_prefix, add_all_currencies);
}


procedure {:inline 1} $LibraAccount_create_child_vasp_account_$direct_intra($tv0: $TypeValue, parent: $Value, new_account_address: $Value, auth_key_prefix: $Value, add_all_currencies: $Value) returns ()
{
    assume is#$Address(parent);

    assume is#$Address(new_account_address);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    assume is#$Boolean(add_all_currencies);

    call $LibraAccount_create_child_vasp_account_$def($tv0, parent, new_account_address, auth_key_prefix, add_all_currencies);
}


procedure {:inline 1} $LibraAccount_create_child_vasp_account($tv0: $TypeValue, parent: $Value, new_account_address: $Value, auth_key_prefix: $Value, add_all_currencies: $Value) returns ()
{
    assume is#$Address(parent);

    assume is#$Address(new_account_address);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    assume is#$Boolean(add_all_currencies);

    call $LibraAccount_create_child_vasp_account_$def($tv0, parent, new_account_address, auth_key_prefix, add_all_currencies);
}


procedure {:inline 1} $LibraAccount_create_designated_dealer_$def($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, add_all_currencies: $Value) returns ()
{
    // declare local variables
    var new_dd_account: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $Vector_type_value($IntegerType())
    var $t9: $Value; // $Vector_type_value($IntegerType())
    var $t10: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 46201, 0, creator_account); }
    if (true) { assume $DebugTrackLocal(16, 46201, 1, new_account_address); }
    if (true) { assume $DebugTrackLocal(16, 46201, 2, auth_key_prefix); }
    if (true) { assume $DebugTrackLocal(16, 46201, 3, human_name); }
    if (true) { assume $DebugTrackLocal(16, 46201, 4, add_all_currencies); }

    // bytecode translation starts here
    // $t6 := move(creator_account)
    call $t6 := $CopyOrMoveValue(creator_account);

    // $t7 := move(new_account_address)
    call $t7 := $CopyOrMoveValue(new_account_address);

    // $t8 := move(auth_key_prefix)
    call $t8 := $CopyOrMoveValue(auth_key_prefix);

    // $t9 := move(human_name)
    call $t9 := $CopyOrMoveValue(human_name);

    // $t10 := move(add_all_currencies)
    call $t10 := $CopyOrMoveValue(add_all_currencies);

    // new_dd_account := LibraAccount::create_signer($t7)
    call new_dd_account := $LibraAccount_create_signer($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 53353, $abort_code);
      goto Abort;
    }

    // Event::publish_generator(new_dd_account)
    call $Event_publish_generator(new_dd_account);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 46548, $abort_code);
      goto Abort;
    }

    // Roles::new_designated_dealer_role($t6, new_dd_account)
    call $Roles_new_designated_dealer_role($t6, new_dd_account, $ConstMemoryDomain(true));
    if ($abort_flag) {
      goto Abort;
    }

    // DesignatedDealer::publish_designated_dealer_credential<#0>(new_dd_account, $t6, $t10)
    call $DesignatedDealer_publish_designated_dealer_credential($tv0, new_dd_account, $t6, $t10, $ConstMemoryDomain(true), $ConstMemoryDomain(true));
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 46687, $abort_code);
      goto Abort;
    }

    // LibraAccount::add_currencies_for_account<#0>(new_dd_account, $t10)
    call $LibraAccount_add_currencies_for_account($tv0, new_dd_account, $t10);
    if ($abort_flag) {
      goto Abort;
    }

    // DualAttestation::publish_credential(new_dd_account, $t6, $t9)
    call $DualAttestation_publish_credential(new_dd_account, $t6, $t9);
    if ($abort_flag) {
      goto Abort;
    }

    // LibraAccount::make_account(new_dd_account, $t8)
    call $LibraAccount_make_account(new_dd_account, $t8);
    if ($abort_flag) {
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_create_designated_dealer_$direct_inter($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, add_all_currencies: $Value) returns ()
{
    assume is#$Address(creator_account);

    assume is#$Address(new_account_address);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    assume is#$Boolean(add_all_currencies);

    call $LibraAccount_create_designated_dealer_$def($tv0, creator_account, new_account_address, auth_key_prefix, human_name, add_all_currencies);
}


procedure {:inline 1} $LibraAccount_create_designated_dealer_$direct_intra($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, add_all_currencies: $Value) returns ()
{
    assume is#$Address(creator_account);

    assume is#$Address(new_account_address);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    assume is#$Boolean(add_all_currencies);

    call $LibraAccount_create_designated_dealer_$def($tv0, creator_account, new_account_address, auth_key_prefix, human_name, add_all_currencies);
}


procedure {:inline 1} $LibraAccount_create_designated_dealer($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, add_all_currencies: $Value) returns ()
{
    assume is#$Address(creator_account);

    assume is#$Address(new_account_address);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    assume is#$Boolean(add_all_currencies);

    call $LibraAccount_create_designated_dealer_$def($tv0, creator_account, new_account_address, auth_key_prefix, human_name, add_all_currencies);
}


procedure {:inline 1} $LibraAccount_create_libra_root_account_$def(auth_key_prefix: $Value) returns ()
{
    // declare local variables
    var lr_account: $Value; // $AddressType()
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var $t6: $Value; // $Vector_type_value($IntegerType())
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $AccountLimits_AccountLimitMutationCapability_type_value()
    var $t14: $Value; // $Event_EventHandle_type_value($LibraAccount_CreateAccountEvent_type_value())
    var $t15: $Value; // $LibraAccount_AccountOperationsCapability_type_value()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $BooleanType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $Event_EventHandle_type_value($LibraAccount_UpgradeEvent_type_value())
    var $t22: $Value; // $LibraAccount_LibraWriteSetManager_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 43470, 0, auth_key_prefix); }

    // bytecode translation starts here
    // $t6 := move(auth_key_prefix)
    call $t6 := $CopyOrMoveValue(auth_key_prefix);

    // LibraTimestamp::assert_genesis()
    call $LibraTimestamp_assert_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 43607, $abort_code);
      goto Abort;
    }

    // $t7 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t7 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // lr_account := LibraAccount::create_signer($t7)
    call lr_account := $LibraAccount_create_signer($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 53353, $abort_code);
      goto Abort;
    }

    // CoreAddresses::assert_libra_root(lr_account)
    call $CoreAddresses_assert_libra_root(lr_account);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 43725, $abort_code);
      goto Abort;
    }

    // Roles::grant_libra_root_role(lr_account)
    call $Roles_grant_libra_root_role(lr_account, $ConstMemoryDomain(true));
    if ($abort_flag) {
      goto Abort;
    }

    // SlidingNonce::publish_nonce_resource(lr_account, lr_account)
    call $SlidingNonce_publish_nonce_resource(lr_account, lr_account);
    if ($abort_flag) {
      goto Abort;
    }

    // Event::publish_generator(lr_account)
    call $Event_publish_generator(lr_account);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 43895, $abort_code);
      goto Abort;
    }

    // $t8 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t8 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t9 := exists<LibraAccount::AccountOperationsCapability>($t8)
    $t9 := $ResourceExists($LibraAccount_AccountOperationsCapability_$memory, $EmptyTypeValueArray, $t8);

    // $t10 := !($t9)
    call $t10 := $Not($t9);

    // $t11 := 22
    $t11 := $Integer(22);

    // $t12 := Errors::already_published($t11)
    call $t12 := $Errors_already_published($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 44051, $abort_code);
      goto Abort;
    }

    // if ($t10) goto L0 else goto L1
    if (b#$Boolean($t10)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t12)
    if (true) { assume $DebugTrackAbort(16, 43936, i#$Integer($t12)); }
    $abort_code := i#$Integer($t12);
    goto Abort;

    // L0:
L0:

    // $t13 := AccountLimits::grant_mutation_capability(lr_account)
    call $t13 := $AccountLimits_grant_mutation_capability(lr_account);
    if ($abort_flag) {
      goto Abort;
    }

    // $t14 := Event::new_event_handle<LibraAccount::CreateAccountEvent>(lr_account)
    call $t14 := $Event_new_event_handle($LibraAccount_CreateAccountEvent_type_value(), lr_account);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 44319, $abort_code);
      goto Abort;
    }

    // $t15 := pack LibraAccount::AccountOperationsCapability($t13, $t14)
    call $t15 := $LibraAccount_AccountOperationsCapability_pack(0, 0, 0, $t13, $t14);

    // move_to<LibraAccount::AccountOperationsCapability>($t15, lr_account)
    call $LibraAccount_AccountOperationsCapability_$memory := $MoveTo($LibraAccount_AccountOperationsCapability_$memory, $EmptyTypeValueArray, $t15, lr_account);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 44120, $abort_code);
      goto Abort;
    }

    // $t16 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t16 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t17 := exists<LibraAccount::LibraWriteSetManager>($t16)
    $t17 := $ResourceExists($LibraAccount_LibraWriteSetManager_$memory, $EmptyTypeValueArray, $t16);

    // $t18 := !($t17)
    call $t18 := $Not($t17);

    // $t19 := 23
    $t19 := $Integer(23);

    // $t20 := Errors::already_published($t19)
    call $t20 := $Errors_already_published($t19);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 44511, $abort_code);
      goto Abort;
    }

    // if ($t18) goto L2 else goto L3
    if (b#$Boolean($t18)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t20)
    if (true) { assume $DebugTrackAbort(16, 44403, i#$Integer($t20)); }
    $abort_code := i#$Integer($t20);
    goto Abort;

    // L2:
L2:

    // $t21 := Event::new_event_handle<LibraAccount::UpgradeEvent>(lr_account)
    call $t21 := $Event_new_event_handle($LibraAccount_UpgradeEvent_type_value(), lr_account);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 44675, $abort_code);
      goto Abort;
    }

    // $t22 := pack LibraAccount::LibraWriteSetManager($t21)
    call $t22 := $LibraAccount_LibraWriteSetManager_pack(0, 0, 0, $t21);

    // move_to<LibraAccount::LibraWriteSetManager>($t22, lr_account)
    call $LibraAccount_LibraWriteSetManager_$memory := $MoveTo($LibraAccount_LibraWriteSetManager_$memory, $EmptyTypeValueArray, $t22, lr_account);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 44567, $abort_code);
      goto Abort;
    }

    // LibraAccount::make_account(lr_account, $t6)
    call $LibraAccount_make_account(lr_account, $t6);
    if ($abort_flag) {
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_create_libra_root_account_$direct_intra(auth_key_prefix: $Value) returns ()
{
    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    call $LibraAccount_create_libra_root_account_$def(auth_key_prefix);
}


procedure {:inline 1} $LibraAccount_create_libra_root_account(auth_key_prefix: $Value) returns ()
{
    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    call $LibraAccount_create_libra_root_account_$def(auth_key_prefix);
}


procedure {:inline 1} $LibraAccount_create_parent_vasp_account_$def($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, add_all_currencies: $Value) returns ()
{
    // declare local variables
    var new_account: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $Vector_type_value($IntegerType())
    var $t9: $Value; // $Vector_type_value($IntegerType())
    var $t10: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 48926, 0, creator_account); }
    if (true) { assume $DebugTrackLocal(16, 48926, 1, new_account_address); }
    if (true) { assume $DebugTrackLocal(16, 48926, 2, auth_key_prefix); }
    if (true) { assume $DebugTrackLocal(16, 48926, 3, human_name); }
    if (true) { assume $DebugTrackLocal(16, 48926, 4, add_all_currencies); }

    // bytecode translation starts here
    // $t6 := move(creator_account)
    call $t6 := $CopyOrMoveValue(creator_account);

    // $t7 := move(new_account_address)
    call $t7 := $CopyOrMoveValue(new_account_address);

    // $t8 := move(auth_key_prefix)
    call $t8 := $CopyOrMoveValue(auth_key_prefix);

    // $t9 := move(human_name)
    call $t9 := $CopyOrMoveValue(human_name);

    // $t10 := move(add_all_currencies)
    call $t10 := $CopyOrMoveValue(add_all_currencies);

    // new_account := LibraAccount::create_signer($t7)
    call new_account := $LibraAccount_create_signer($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 53353, $abort_code);
      goto Abort;
    }

    // Roles::new_parent_vasp_role($t6, new_account)
    call $Roles_new_parent_vasp_role($t6, new_account, $ConstMemoryDomain(true));
    if ($abort_flag) {
      goto Abort;
    }

    // VASP::publish_parent_vasp_credential(new_account, $t6)
    call $VASP_publish_parent_vasp_credential(new_account, $t6);
    if ($abort_flag) {
      goto Abort;
    }

    // Event::publish_generator(new_account)
    call $Event_publish_generator(new_account);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 49436, $abort_code);
      goto Abort;
    }

    // DualAttestation::publish_credential(new_account, $t6, $t9)
    call $DualAttestation_publish_credential(new_account, $t6, $t9);
    if ($abort_flag) {
      goto Abort;
    }

    // LibraAccount::add_currencies_for_account<#0>(new_account, $t10)
    call $LibraAccount_add_currencies_for_account($tv0, new_account, $t10);
    if ($abort_flag) {
      goto Abort;
    }

    // LibraAccount::make_account(new_account, $t8)
    call $LibraAccount_make_account(new_account, $t8);
    if ($abort_flag) {
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_create_parent_vasp_account_$direct_inter($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, add_all_currencies: $Value) returns ()
{
    assume is#$Address(creator_account);

    assume is#$Address(new_account_address);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    assume is#$Boolean(add_all_currencies);

    call $LibraAccount_create_parent_vasp_account_$def($tv0, creator_account, new_account_address, auth_key_prefix, human_name, add_all_currencies);
}


procedure {:inline 1} $LibraAccount_create_parent_vasp_account_$direct_intra($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, add_all_currencies: $Value) returns ()
{
    assume is#$Address(creator_account);

    assume is#$Address(new_account_address);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    assume is#$Boolean(add_all_currencies);

    call $LibraAccount_create_parent_vasp_account_$def($tv0, creator_account, new_account_address, auth_key_prefix, human_name, add_all_currencies);
}


procedure {:inline 1} $LibraAccount_create_parent_vasp_account($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, add_all_currencies: $Value) returns ()
{
    assume is#$Address(creator_account);

    assume is#$Address(new_account_address);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    assume is#$Boolean(add_all_currencies);

    call $LibraAccount_create_parent_vasp_account_$def($tv0, creator_account, new_account_address, auth_key_prefix, human_name, add_all_currencies);
}


procedure {:inline 1} $LibraAccount_create_treasury_compliance_account_$def(lr_account: $Value, auth_key_prefix: $Value) returns ()
{
    // declare local variables
    var new_account: $Value; // $AddressType()
    var new_account_address: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $Vector_type_value($IntegerType())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 45135, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(16, 45135, 1, auth_key_prefix); }

    // bytecode translation starts here
    // $t4 := move(lr_account)
    call $t4 := $CopyOrMoveValue(lr_account);

    // $t5 := move(auth_key_prefix)
    call $t5 := $CopyOrMoveValue(auth_key_prefix);

    // LibraTimestamp::assert_genesis()
    call $LibraTimestamp_assert_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 45310, $abort_code);
      goto Abort;
    }

    // Roles::assert_libra_root($t4)
    call $Roles_assert_libra_root($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 45343, $abort_code);
      goto Abort;
    }

    // new_account_address := CoreAddresses::TREASURY_COMPLIANCE_ADDRESS()
    call new_account_address := $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // new_account := LibraAccount::create_signer(new_account_address)
    call new_account := $LibraAccount_create_signer(new_account_address);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 53353, $abort_code);
      goto Abort;
    }

    // Roles::grant_treasury_compliance_role(new_account, $t4)
    call $Roles_grant_treasury_compliance_role(new_account, $t4, $ConstMemoryDomain(true));
    if ($abort_flag) {
      goto Abort;
    }

    // SlidingNonce::publish_nonce_resource($t4, new_account)
    call $SlidingNonce_publish_nonce_resource($t4, new_account);
    if ($abort_flag) {
      goto Abort;
    }

    // Event::publish_generator(new_account)
    call $Event_publish_generator(new_account);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 45676, $abort_code);
      goto Abort;
    }

    // LibraAccount::make_account(new_account, $t5)
    call $LibraAccount_make_account(new_account, $t5);
    if ($abort_flag) {
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_create_treasury_compliance_account_$direct_intra(lr_account: $Value, auth_key_prefix: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    call $LibraAccount_create_treasury_compliance_account_$def(lr_account, auth_key_prefix);
}


procedure {:inline 1} $LibraAccount_create_treasury_compliance_account(lr_account: $Value, auth_key_prefix: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    call $LibraAccount_create_treasury_compliance_account_$def(lr_account, auth_key_prefix);
}


procedure {:inline 1} $LibraAccount_create_validator_account_$def(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var new_account: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $Vector_type_value($IntegerType())
    var $t8: $Value; // $Vector_type_value($IntegerType())
    var $Roles_RoleId_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 74419, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(16, 74419, 1, new_account_address); }
    if (true) { assume $DebugTrackLocal(16, 74419, 2, auth_key_prefix); }
    if (true) { assume $DebugTrackLocal(16, 74419, 3, human_name); }
    $Roles_RoleId_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address(new_account_address) := true];

    // bytecode translation starts here
    // $t5 := move(lr_account)
    call $t5 := $CopyOrMoveValue(lr_account);

    // $t6 := move(new_account_address)
    call $t6 := $CopyOrMoveValue(new_account_address);

    // $t7 := move(auth_key_prefix)
    call $t7 := $CopyOrMoveValue(auth_key_prefix);

    // $t8 := move(human_name)
    call $t8 := $CopyOrMoveValue(human_name);

    // new_account := LibraAccount::create_signer($t6)
    call new_account := $LibraAccount_create_signer($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 53353, $abort_code);
      goto Abort;
    }

    // Roles::new_validator_role($t5, new_account)
    call $Roles_new_validator_role($t5, new_account, $Roles_RoleId_$SelfDomain);
    if ($abort_flag) {
      goto Abort;
    }

    // Event::publish_generator(new_account)
    call $Event_publish_generator(new_account);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 74880, $abort_code);
      goto Abort;
    }

    // ValidatorConfig::publish(new_account, $t5, $t8)
    call $ValidatorConfig_publish(new_account, $t5, $t8);
    if ($abort_flag) {
      goto Abort;
    }

    // LibraAccount::make_account(new_account, $t7)
    call $LibraAccount_make_account(new_account, $t7);
    if ($abort_flag) {
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_create_validator_account_$direct_inter(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address(new_account_address)];
{
    assume is#$Address(lr_account);

    assume is#$Address(new_account_address);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    call $LibraAccount_create_validator_account_$def(lr_account, new_account_address, auth_key_prefix, human_name, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $LibraAccount_create_validator_account_$direct_intra(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address(new_account_address)];
{
    assume is#$Address(lr_account);

    assume is#$Address(new_account_address);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    call $LibraAccount_create_validator_account_$def(lr_account, new_account_address, auth_key_prefix, human_name, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $LibraAccount_create_validator_account(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address(new_account_address)];
{
    assume is#$Address(lr_account);

    assume is#$Address(new_account_address);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    call $LibraAccount_create_validator_account_$def(lr_account, new_account_address, auth_key_prefix, human_name, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $LibraAccount_create_validator_operator_account_$def(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var new_account: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $Vector_type_value($IntegerType())
    var $t8: $Value; // $Vector_type_value($IntegerType())
    var $Roles_RoleId_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 76048, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(16, 76048, 1, new_account_address); }
    if (true) { assume $DebugTrackLocal(16, 76048, 2, auth_key_prefix); }
    if (true) { assume $DebugTrackLocal(16, 76048, 3, human_name); }
    $Roles_RoleId_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address(new_account_address) := true];

    // bytecode translation starts here
    // $t5 := move(lr_account)
    call $t5 := $CopyOrMoveValue(lr_account);

    // $t6 := move(new_account_address)
    call $t6 := $CopyOrMoveValue(new_account_address);

    // $t7 := move(auth_key_prefix)
    call $t7 := $CopyOrMoveValue(auth_key_prefix);

    // $t8 := move(human_name)
    call $t8 := $CopyOrMoveValue(human_name);

    // new_account := LibraAccount::create_signer($t6)
    call new_account := $LibraAccount_create_signer($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 53353, $abort_code);
      goto Abort;
    }

    // Roles::new_validator_operator_role($t5, new_account)
    call $Roles_new_validator_operator_role($t5, new_account, $Roles_RoleId_$SelfDomain);
    if ($abort_flag) {
      goto Abort;
    }

    // Event::publish_generator(new_account)
    call $Event_publish_generator(new_account);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 76528, $abort_code);
      goto Abort;
    }

    // ValidatorOperatorConfig::publish(new_account, $t5, $t8)
    call $ValidatorOperatorConfig_publish(new_account, $t5, $t8);
    if ($abort_flag) {
      goto Abort;
    }

    // LibraAccount::make_account(new_account, $t7)
    call $LibraAccount_make_account(new_account, $t7);
    if ($abort_flag) {
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_create_validator_operator_account_$direct_inter(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address(new_account_address)];
{
    assume is#$Address(lr_account);

    assume is#$Address(new_account_address);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    call $LibraAccount_create_validator_operator_account_$def(lr_account, new_account_address, auth_key_prefix, human_name, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $LibraAccount_create_validator_operator_account_$direct_intra(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address(new_account_address)];
{
    assume is#$Address(lr_account);

    assume is#$Address(new_account_address);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    call $LibraAccount_create_validator_operator_account_$def(lr_account, new_account_address, auth_key_prefix, human_name, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $LibraAccount_create_validator_operator_account(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, $Roles_RoleId_$CallerDomain: [$TypeValueArray, int]bool) returns ()
requires $Roles_RoleId_$CallerDomain[$EmptyTypeValueArray, a#$Address(new_account_address)];
{
    assume is#$Address(lr_account);

    assume is#$Address(new_account_address);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    call $LibraAccount_create_validator_operator_account_$def(lr_account, new_account_address, auth_key_prefix, human_name, $Roles_RoleId_$CallerDomain);
}


procedure {:inline 1} $LibraAccount_delegated_key_rotation_capability_$def(addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $LibraAccount_LibraAccount_type_value()
    var $t8: $Value; // $Option_Option_type_value($LibraAccount_KeyRotationCapability_type_value())
    var $t9: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 56858, 0, addr); }

    // bytecode translation starts here
    // $t3 := move(addr)
    call $t3 := $CopyOrMoveValue(addr);

    // $t4 := LibraAccount::exists_at($t3)
    call $t4 := $LibraAccount_exists_at($t3);
    if ($abort_flag) {
      goto Abort;
    }

    // $t5 := 0
    $t5 := $Integer(0);

    // $t6 := Errors::not_published($t5)
    call $t6 := $Errors_not_published($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 56992, $abort_code);
      goto Abort;
    }

    // if ($t4) goto L0 else goto L1
    if (b#$Boolean($t4)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t6)
    if (true) { assume $DebugTrackAbort(16, 56960, i#$Integer($t6)); }
    $abort_code := i#$Integer($t6);
    goto Abort;

    // L0:
L0:

    // $t7 := get_global<LibraAccount::LibraAccount>($t3)
    call $t7 := $GetGlobal($LibraAccount_LibraAccount_$memory, $t3, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 57043, $abort_code);
      goto Abort;
    }

    // $t8 := get_field<LibraAccount::LibraAccount>.key_rotation_capability($t7)
    call $t8 := $GetFieldFromValue($t7, $LibraAccount_LibraAccount_key_rotation_capability);

    // $t9 := Option::is_none<LibraAccount::KeyRotationCapability>($t8)
    call $t9 := $Option_is_none($LibraAccount_KeyRotationCapability_type_value(), $t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 57034, $abort_code);
      goto Abort;
    }

    // return $t9
    $ret0 := $t9;
    if (true) { assume $DebugTrackLocal(16, 57026, 10, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraAccount_delegated_key_rotation_capability_$direct_inter(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $LibraAccount_delegated_key_rotation_capability_$def(addr);
}


procedure {:inline 1} $LibraAccount_delegated_key_rotation_capability_$direct_intra(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $LibraAccount_delegated_key_rotation_capability_$def(addr);
}


procedure {:inline 1} $LibraAccount_delegated_key_rotation_capability(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $LibraAccount_delegated_key_rotation_capability_$def(addr);
}


procedure {:inline 1} $LibraAccount_delegated_withdraw_capability_$def(addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $LibraAccount_LibraAccount_type_value()
    var $t8: $Value; // $Option_Option_type_value($LibraAccount_WithdrawCapability_type_value())
    var $t9: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 57196, 0, addr); }

    // bytecode translation starts here
    // $t3 := move(addr)
    call $t3 := $CopyOrMoveValue(addr);

    // $t4 := LibraAccount::exists_at($t3)
    call $t4 := $LibraAccount_exists_at($t3);
    if ($abort_flag) {
      goto Abort;
    }

    // $t5 := 0
    $t5 := $Integer(0);

    // $t6 := Errors::not_published($t5)
    call $t6 := $Errors_not_published($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 57326, $abort_code);
      goto Abort;
    }

    // if ($t4) goto L0 else goto L1
    if (b#$Boolean($t4)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t6)
    if (true) { assume $DebugTrackAbort(16, 57294, i#$Integer($t6)); }
    $abort_code := i#$Integer($t6);
    goto Abort;

    // L0:
L0:

    // $t7 := get_global<LibraAccount::LibraAccount>($t3)
    call $t7 := $GetGlobal($LibraAccount_LibraAccount_$memory, $t3, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 57377, $abort_code);
      goto Abort;
    }

    // $t8 := get_field<LibraAccount::LibraAccount>.withdrawal_capability($t7)
    call $t8 := $GetFieldFromValue($t7, $LibraAccount_LibraAccount_withdrawal_capability);

    // $t9 := Option::is_none<LibraAccount::WithdrawCapability>($t8)
    call $t9 := $Option_is_none($LibraAccount_WithdrawCapability_type_value(), $t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 57368, $abort_code);
      goto Abort;
    }

    // return $t9
    $ret0 := $t9;
    if (true) { assume $DebugTrackLocal(16, 57360, 10, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraAccount_delegated_withdraw_capability_$direct_inter(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $LibraAccount_delegated_withdraw_capability_$def(addr);
}


procedure {:inline 1} $LibraAccount_delegated_withdraw_capability_$direct_intra(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $LibraAccount_delegated_withdraw_capability_$def(addr);
}


procedure {:inline 1} $LibraAccount_delegated_withdraw_capability(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $LibraAccount_delegated_withdraw_capability_$def(addr);
}


procedure {:inline 1} $LibraAccount_epilogue_$def($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value) returns ()
{
    // declare local variables
    var coin: $Mutation; // ReferenceType($Libra_Libra_type_value($tv0))
    var gas_used: $Value; // $IntegerType()
    var sender: $Value; // $AddressType()
    var sender_account: $Mutation; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var sender_balance: $Mutation; // ReferenceType($LibraAccount_Balance_type_value($tv0))
    var tmp#$10: $Value; // $BooleanType()
    var tmp#$11: $Value; // $IntegerType()
    var tmp#$12: $Value; // $BooleanType()
    var tmp#$13: $Value; // $IntegerType()
    var tmp#$14: $Value; // $BooleanType()
    var tmp#$15: $Value; // $IntegerType()
    var tmp#$16: $Value; // $BooleanType()
    var tmp#$17: $Value; // $IntegerType()
    var tmp#$18: $Value; // $BooleanType()
    var tmp#$19: $Value; // $IntegerType()
    var tmp#$20: $Value; // $BooleanType()
    var tmp#$21: $Value; // $IntegerType()
    var transaction_fee_amount: $Value; // $IntegerType()
    var $t23: $Value; // $AddressType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $BooleanType()
    var $t29: $Value; // $IntegerType()
    var $t30: $Value; // $IntegerType()
    var $t31: $Value; // $IntegerType()
    var $t32: $Value; // $IntegerType()
    var $t33: $Value; // $IntegerType()
    var $t34: $Value; // $IntegerType()
    var $t35: $Value; // $BooleanType()
    var $t36: $Value; // $IntegerType()
    var $t37: $Value; // $IntegerType()
    var $t38: $Value; // $BooleanType()
    var $t39: $Value; // $IntegerType()
    var $t40: $Value; // $IntegerType()
    var $t41: $Value; // $IntegerType()
    var $t42: $Value; // $IntegerType()
    var $t43: $Value; // $IntegerType()
    var $t44: $Value; // $BooleanType()
    var $t45: $Value; // $IntegerType()
    var $t46: $Value; // $IntegerType()
    var $t47: $Value; // $IntegerType()
    var $t48: $Value; // $BooleanType()
    var $t49: $Value; // $IntegerType()
    var $t50: $Value; // $IntegerType()
    var $t51: $Value; // $IntegerType()
    var $t52: $Value; // $IntegerType()
    var $t53: $Mutation; // ReferenceType($IntegerType())
    var $t54: $Value; // $IntegerType()
    var $t55: $Value; // $BooleanType()
    var $t56: $Value; // $Libra_Libra_type_value($tv0)
    var $t57: $Value; // $IntegerType()
    var $t58: $Value; // $BooleanType()
    var $t59: $Value; // $IntegerType()
    var $t60: $Value; // $IntegerType()
    var $t61: $Value; // $Libra_Libra_type_value($tv0)
    var $t62: $Value; // $Libra_Libra_type_value($tv0)

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 70562, 0, account); }
    if (true) { assume $DebugTrackLocal(16, 70562, 1, txn_sequence_number); }
    if (true) { assume $DebugTrackLocal(16, 70562, 2, txn_gas_price); }
    if (true) { assume $DebugTrackLocal(16, 70562, 3, txn_max_gas_units); }
    if (true) { assume $DebugTrackLocal(16, 70562, 4, gas_units_remaining); }

    // bytecode translation starts here
    // $t23 := move(account)
    call $t23 := $CopyOrMoveValue(account);

    // $t24 := move(txn_sequence_number)
    call $t24 := $CopyOrMoveValue(txn_sequence_number);

    // $t25 := move(txn_gas_price)
    call $t25 := $CopyOrMoveValue(txn_gas_price);

    // $t26 := move(txn_max_gas_units)
    call $t26 := $CopyOrMoveValue(txn_max_gas_units);

    // $t27 := move(gas_units_remaining)
    call $t27 := $CopyOrMoveValue(gas_units_remaining);

    // sender := Signer::address_of($t23)
    call sender := $Signer_address_of($t23);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 70804, $abort_code);
      goto Abort;
    }

    // $t28 := >=($t26, $t27)
    call $t28 := $Ge($t26, $t27);

    // $t29 := 20
    $t29 := $Integer(20);

    // $t30 := Errors::invalid_argument($t29)
    call $t30 := $Errors_invalid_argument($t29);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 71047, $abort_code);
      goto Abort;
    }

    // if ($t28) goto L0 else goto L1
    if (b#$Boolean($t28)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t30)
    if (true) { assume $DebugTrackAbort(16, 70990, i#$Integer($t30)); }
    $abort_code := i#$Integer($t30);
    goto Abort;

    // L0:
L0:

    // gas_used := -($t26, $t27)
    call gas_used := $Sub($t26, $t27);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 71113, $abort_code);
      goto Abort;
    }
    if (true) { assume $DebugTrackLocal(16, 71113, 6, gas_used); }

    // $t31 := (u128)($t25)
    call $t31 := $CastU128($t25);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 71325, $abort_code);
      goto Abort;
    }

    // $t32 := (u128)(gas_used)
    call $t32 := $CastU128(gas_used);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 71351, $abort_code);
      goto Abort;
    }

    // $t33 := *($t31, $t32)
    call $t33 := $MulU128($t31, $t32);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 71349, $abort_code);
      goto Abort;
    }

    // $t34 := 18446744073709551615
    $t34 := $Integer(18446744073709551615);

    // $t35 := <=($t33, $t34)
    call $t35 := $Le($t33, $t34);

    // $t36 := 20
    $t36 := $Integer(20);

    // $t37 := Errors::limit_exceeded($t36)
    call $t37 := $Errors_limit_exceeded($t36);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 71402, $abort_code);
      goto Abort;
    }

    // if ($t35) goto L2 else goto L3
    if (b#$Boolean($t35)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t37)
    if (true) { assume $DebugTrackAbort(16, 71305, i#$Integer($t37)); }
    $abort_code := i#$Integer($t37);
    goto Abort;

    // L2:
L2:

    // transaction_fee_amount := *($t25, gas_used)
    call transaction_fee_amount := $MulU64($t25, gas_used);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 71485, $abort_code);
      goto Abort;
    }
    if (true) { assume $DebugTrackLocal(16, 71485, 22, transaction_fee_amount); }

    // $t38 := LibraAccount::exists_at(sender)
    call $t38 := $LibraAccount_exists_at(sender);
    if ($abort_flag) {
      goto Abort;
    }

    // $t39 := 0
    $t39 := $Integer(0);

    // $t40 := Errors::not_published($t39)
    call $t40 := $Errors_not_published($t39);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 71681, $abort_code);
      goto Abort;
    }

    // if ($t38) goto L4 else goto L5
    if (b#$Boolean($t38)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // abort($t40)
    if (true) { assume $DebugTrackAbort(16, 71647, i#$Integer($t40)); }
    $abort_code := i#$Integer($t40);
    goto Abort;

    // L4:
L4:

    // sender_account := borrow_global<LibraAccount::LibraAccount>(sender)
    call sender_account := $BorrowGlobal($LibraAccount_LibraAccount_$memory, sender, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 71736, $abort_code);
      goto Abort;
    }

    // unpack_ref(sender_account)
    call $LibraAccount_LibraAccount_$unpack_ref($Dereference(sender_account));

    // $t41 := get_field<LibraAccount::LibraAccount>.sequence_number(sender_account)
    call $t41 := $GetFieldFromReference(sender_account, $LibraAccount_LibraAccount_sequence_number);

    // $t42 := 18446744073709551615
    $t42 := $Integer(18446744073709551615);

    // $t43 := (u64)($t42)
    call $t43 := $CastU64($t42);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 71982, $abort_code);
      goto Abort;
    }

    // $t44 := <($t41, $t43)
    call $t44 := $Lt($t41, $t43);

    // $t45 := 1
    $t45 := $Integer(1);

    // $t46 := Errors::limit_exceeded($t45)
    call $t46 := $Errors_limit_exceeded($t45);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 72020, $abort_code);
      goto Abort;
    }

    // if ($t44) goto L6 else goto L7
    if (b#$Boolean($t44)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // destroy(sender_account)

    // pack_ref(sender_account)
    call $LibraAccount_LibraAccount_$pack_ref($Dereference(sender_account));

    // abort($t46)
    if (true) { assume $DebugTrackAbort(16, 71929, i#$Integer($t46)); }
    $abort_code := i#$Integer($t46);
    goto Abort;

    // L6:
L6:

    // $t47 := get_field<LibraAccount::LibraAccount>.sequence_number(sender_account)
    call $t47 := $GetFieldFromReference(sender_account, $LibraAccount_LibraAccount_sequence_number);

    // $t48 := ==($t47, $t24)
    $t48 := $Boolean($IsEqual($t47, $t24));

    // $t49 := 1
    $t49 := $Integer(1);

    // $t50 := Errors::invalid_argument($t49)
    call $t50 := $Errors_invalid_argument($t49);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 72327, $abort_code);
      goto Abort;
    }

    // if ($t48) goto L8 else goto L9
    if (b#$Boolean($t48)) { goto L8; } else { goto L9; }

    // L9:
L9:

    // destroy(sender_account)

    // pack_ref(sender_account)
    call $LibraAccount_LibraAccount_$pack_ref($Dereference(sender_account));

    // abort($t50)
    if (true) { assume $DebugTrackAbort(16, 72232, i#$Integer($t50)); }
    $abort_code := i#$Integer($t50);
    goto Abort;

    // L8:
L8:

    // $t51 := 1
    $t51 := $Integer(1);

    // $t52 := +($t24, $t51)
    call $t52 := $AddU64($t24, $t51);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 72622, $abort_code);
      goto Abort;
    }

    // $t53 := borrow_field<LibraAccount::LibraAccount>.sequence_number(sender_account)
    call $t53 := $BorrowField(sender_account, $LibraAccount_LibraAccount_sequence_number);

    // unpack_ref($t53)

    // write_ref($t53, $t52)
    call $t53 := $WriteRef($t53, $t52);
    if (true) { assume $DebugTrackLocal(16, 72569, 5, $Dereference(coin)); }
    if (true) { assume $DebugTrackLocal(16, 72569, 8, $Dereference(sender_account)); }
    if (true) { assume $DebugTrackLocal(16, 72569, 9, $Dereference(sender_balance)); }

    // pack_ref($t53)

    // write_back[Reference(sender_account)]($t53)
    call sender_account := $WritebackToReference($t53, sender_account);

    // pack_ref(sender_account)
    call $LibraAccount_LibraAccount_$pack_ref($Dereference(sender_account));

    // write_back[LibraAccount::LibraAccount](sender_account)
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, sender_account);

    // $t54 := 0
    $t54 := $Integer(0);

    // $t55 := >(transaction_fee_amount, $t54)
    call $t55 := $Gt(transaction_fee_amount, $t54);

    // if ($t55) goto L10 else goto L11
    if (b#$Boolean($t55)) { goto L10; } else { goto L11; }

    // L11:
L11:

    // goto L12
    goto L12;

    // L10:
L10:

    // sender_balance := borrow_global<LibraAccount::Balance<#0>>(sender)
    call sender_balance := $BorrowGlobal($LibraAccount_Balance_$memory, sender, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 72821, $abort_code);
      goto Abort;
    }

    // unpack_ref(sender_balance)

    // coin := borrow_field<LibraAccount::Balance<#0>>.coin(sender_balance)
    call coin := $BorrowField(sender_balance, $LibraAccount_Balance_coin);

    // unpack_ref(coin)

    // $t56 := read_ref(coin)
    call $t56 := $ReadRef(coin);
    assert $Libra_Libra_$invariant_holds($t56);

    // $t57 := Libra::value<#0>($t56)
    call $t57 := $Libra_value($tv0, $t56);
    if ($abort_flag) {
      goto Abort;
    }

    // $t58 := <=(transaction_fee_amount, $t57)
    call $t58 := $Le(transaction_fee_amount, $t57);

    // $t59 := 1005
    $t59 := $Integer(1005);

    // $t60 := Errors::limit_exceeded($t59)
    call $t60 := $Errors_limit_exceeded($t59);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 73132, $abort_code);
      goto Abort;
    }

    // if ($t58) goto L13 else goto L14
    if (b#$Boolean($t58)) { goto L13; } else { goto L14; }

    // L14:
L14:

    // destroy(coin)

    // pack_ref(coin)

    // pack_ref(sender_balance)

    // abort($t60)
    if (true) { assume $DebugTrackAbort(16, 73038, i#$Integer($t60)); }
    $abort_code := i#$Integer($t60);
    goto Abort;

    // L13:
L13:

    // $t61 := read_ref(coin)
    call $t61 := $ReadRef(coin);
    assert $Libra_Libra_$invariant_holds($t61);

    // ($t62, $t61) := Libra::withdraw<#0>($t61, transaction_fee_amount)
    call $t62, $t61 := $Libra_withdraw($tv0, $t61, transaction_fee_amount);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 73340, $abort_code);
      goto Abort;
    }

    // write_ref(coin, $t61)
    call coin := $WriteRef(coin, $t61);
    if (true) { assume $DebugTrackLocal(16, 73340, 5, $Dereference(coin)); }
    if (true) { assume $DebugTrackLocal(16, 73340, 8, $Dereference(sender_account)); }
    if (true) { assume $DebugTrackLocal(16, 73340, 9, $Dereference(sender_balance)); }

    // pack_ref(coin)

    // write_back[Reference(sender_balance)](coin)
    call sender_balance := $WritebackToReference(coin, sender_balance);

    // pack_ref(sender_balance)

    // write_back[LibraAccount::Balance](sender_balance)
    call $LibraAccount_Balance_$memory := $WritebackToGlobal($LibraAccount_Balance_$memory, sender_balance);

    // TransactionFee::pay_fee<#0>($t62)
    call $TransactionFee_pay_fee($tv0, $t62);
    if ($abort_flag) {
      goto Abort;
    }

    // goto L12
    goto L12;

    // L12:
L12:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_epilogue_$direct_intra($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value) returns ()
{
    assume is#$Address(account);

    assume $IsValidU64(txn_sequence_number);

    assume $IsValidU64(txn_gas_price);

    assume $IsValidU64(txn_max_gas_units);

    assume $IsValidU64(gas_units_remaining);

    call $LibraAccount_epilogue_$def($tv0, account, txn_sequence_number, txn_gas_price, txn_max_gas_units, gas_units_remaining);
}


procedure {:inline 1} $LibraAccount_epilogue($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value) returns ()
{
    assume is#$Address(account);

    assume $IsValidU64(txn_sequence_number);

    assume $IsValidU64(txn_gas_price);

    assume $IsValidU64(txn_max_gas_units);

    assume $IsValidU64(gas_units_remaining);

    call $LibraAccount_epilogue_$def($tv0, account, txn_sequence_number, txn_gas_price, txn_max_gas_units, gas_units_remaining);
}


procedure {:inline 1} $LibraAccount_extract_key_rotation_capability_$def(account: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var account#1574: $Mutation; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var account_address: $Value; // $AddressType()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var tmp#$5: $Value; // $BooleanType()
    var tmp#$6: $Value; // $IntegerType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Mutation; // ReferenceType($Option_Option_type_value($LibraAccount_KeyRotationCapability_type_value()))
    var $t16: $Value; // $Option_Option_type_value($LibraAccount_KeyRotationCapability_type_value())
    var $t17: $Value; // $LibraAccount_KeyRotationCapability_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 34573, 0, account); }

    // bytecode translation starts here
    // $t7 := move(account)
    call $t7 := $CopyOrMoveValue(account);

    // account_address := Signer::address_of($t7)
    call account_address := $Signer_address_of($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 34723, $abort_code);
      goto Abort;
    }

    // $t8 := LibraAccount::delegated_key_rotation_capability(account_address)
    call $t8 := $LibraAccount_delegated_key_rotation_capability(account_address);
    if ($abort_flag) {
      goto Abort;
    }

    // $t9 := !($t8)
    call $t9 := $Not($t8);

    // $t10 := 9
    $t10 := $Integer(9);

    // $t11 := Errors::invalid_state($t10)
    call $t11 := $Errors_invalid_state($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 34939, $abort_code);
      goto Abort;
    }

    // if ($t9) goto L0 else goto L1
    if (b#$Boolean($t9)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t11)
    if (true) { assume $DebugTrackAbort(16, 34846, i#$Integer($t11)); }
    $abort_code := i#$Integer($t11);
    goto Abort;

    // L0:
L0:

    // $t12 := LibraAccount::exists_at(account_address)
    call $t12 := $LibraAccount_exists_at(account_address);
    if ($abort_flag) {
      goto Abort;
    }

    // $t13 := 0
    $t13 := $Integer(0);

    // $t14 := Errors::not_published($t13)
    call $t14 := $Errors_not_published($t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 35059, $abort_code);
      goto Abort;
    }

    // if ($t12) goto L2 else goto L3
    if (b#$Boolean($t12)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t14)
    if (true) { assume $DebugTrackAbort(16, 35016, i#$Integer($t14)); }
    $abort_code := i#$Integer($t14);
    goto Abort;

    // L2:
L2:

    // account#1574 := borrow_global<LibraAccount::LibraAccount>(account_address)
    call account#1574 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, account_address, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 35107, $abort_code);
      goto Abort;
    }

    // unpack_ref(account#1574)
    call $LibraAccount_LibraAccount_$unpack_ref($Dereference(account#1574));

    // $t15 := borrow_field<LibraAccount::LibraAccount>.key_rotation_capability(account#1574)
    call $t15 := $BorrowField(account#1574, $LibraAccount_LibraAccount_key_rotation_capability);

    // unpack_ref($t15)
    call $Option_Option_$unpack_ref($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t15));

    // $t16 := read_ref($t15)
    call $t16 := $ReadRef($t15);
    assert $Option_Option_$invariant_holds($t16);

    // ($t17, $t16) := Option::extract<LibraAccount::KeyRotationCapability>($t16)
    call $t17, $t16 := $Option_extract($LibraAccount_KeyRotationCapability_type_value(), $t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 35173, $abort_code);
      goto Abort;
    }

    // write_ref($t15, $t16)
    call $t15 := $WriteRef($t15, $t16);
    if (true) { assume $DebugTrackLocal(16, 35173, 1, $Dereference(account#1574)); }

    // pack_ref($t15)
    call $Option_Option_$pack_ref($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t15));

    // write_back[Reference(account#1574)]($t15)
    call account#1574 := $WritebackToReference($t15, account#1574);

    // pack_ref(account#1574)
    call $LibraAccount_LibraAccount_$pack_ref($Dereference(account#1574));

    // write_back[LibraAccount::LibraAccount](account#1574)
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, account#1574);

    // return $t17
    $ret0 := $t17;
    if (true) { assume $DebugTrackLocal(16, 35165, 18, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraAccount_extract_key_rotation_capability_$direct_inter(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $LibraAccount_extract_key_rotation_capability_$def(account);
}


procedure {:inline 1} $LibraAccount_extract_key_rotation_capability_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $LibraAccount_extract_key_rotation_capability_$def(account);
}


procedure {:inline 1} $LibraAccount_extract_key_rotation_capability(account: $Value) returns ($ret0: $Value)
{
    assume is#$Address(account);

    call $ret0 := $LibraAccount_extract_key_rotation_capability_$def(account);
}


procedure {:inline 1} $LibraAccount_extract_withdraw_capability_$def(sender: $Value, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
{
    // declare local variables
    var account: $Mutation; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var sender_addr: $Value; // $AddressType()
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var tmp#$5: $Value; // $BooleanType()
    var tmp#$6: $Value; // $IntegerType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Mutation; // ReferenceType($Option_Option_type_value($LibraAccount_WithdrawCapability_type_value()))
    var $t16: $Value; // $Option_Option_type_value($LibraAccount_WithdrawCapability_type_value())
    var $t17: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $LibraAccount_LibraAccount_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 27532, 0, sender); }
    $LibraAccount_LibraAccount_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address($LibraAccount_sender_addr$75(sender)) := true];

    // bytecode translation starts here
    // $t7 := move(sender)
    call $t7 := $CopyOrMoveValue(sender);

    // sender_addr := Signer::address_of($t7)
    call sender_addr := $Signer_address_of($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 27680, $abort_code);
      goto Abort;
    }

    // $t8 := LibraAccount::delegated_withdraw_capability(sender_addr)
    call $t8 := $LibraAccount_delegated_withdraw_capability(sender_addr);
    if ($abort_flag) {
      goto Abort;
    }

    // $t9 := !($t8)
    call $t9 := $Not($t8);

    // $t10 := 7
    $t10 := $Integer(7);

    // $t11 := Errors::invalid_state($t10)
    call $t11 := $Errors_invalid_state($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 27883, $abort_code);
      goto Abort;
    }

    // if ($t9) goto L0 else goto L1
    if (b#$Boolean($t9)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t11)
    if (true) { assume $DebugTrackAbort(16, 27798, i#$Integer($t11)); }
    $abort_code := i#$Integer($t11);
    goto Abort;

    // L0:
L0:

    // $t12 := LibraAccount::exists_at(sender_addr)
    call $t12 := $LibraAccount_exists_at(sender_addr);
    if ($abort_flag) {
      goto Abort;
    }

    // $t13 := 0
    $t13 := $Integer(0);

    // $t14 := Errors::not_published($t13)
    call $t14 := $Errors_not_published($t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 27997, $abort_code);
      goto Abort;
    }

    // if ($t12) goto L2 else goto L3
    if (b#$Boolean($t12)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t14)
    if (true) { assume $DebugTrackAbort(16, 27958, i#$Integer($t14)); }
    $abort_code := i#$Integer($t14);
    goto Abort;

    // L2:
L2:

    // account := borrow_global<LibraAccount::LibraAccount>(sender_addr)
    assert $LibraAccount_LibraAccount_$SelfDomain[$EmptyTypeValueArray, a#$Address(sender_addr)];
    call account := $BorrowGlobal($LibraAccount_LibraAccount_$memory, sender_addr, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 28045, $abort_code);
      goto Abort;
    }

    // unpack_ref(account)
    call $LibraAccount_LibraAccount_$unpack_ref($Dereference(account));

    // $t15 := borrow_field<LibraAccount::LibraAccount>.withdrawal_capability(account)
    call $t15 := $BorrowField(account, $LibraAccount_LibraAccount_withdrawal_capability);

    // unpack_ref($t15)
    call $Option_Option_$unpack_ref($LibraAccount_WithdrawCapability_type_value(), $Dereference($t15));

    // $t16 := read_ref($t15)
    call $t16 := $ReadRef($t15);
    assert $Option_Option_$invariant_holds($t16);

    // ($t17, $t16) := Option::extract<LibraAccount::WithdrawCapability>($t16)
    call $t17, $t16 := $Option_extract($LibraAccount_WithdrawCapability_type_value(), $t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 28107, $abort_code);
      goto Abort;
    }

    // write_ref($t15, $t16)
    call $t15 := $WriteRef($t15, $t16);
    if (true) { assume $DebugTrackLocal(16, 28107, 1, $Dereference(account)); }

    // pack_ref($t15)
    call $Option_Option_$pack_ref($LibraAccount_WithdrawCapability_type_value(), $Dereference($t15));

    // write_back[Reference(account)]($t15)
    call account := $WritebackToReference($t15, account);

    // pack_ref(account)
    call $LibraAccount_LibraAccount_$pack_ref($Dereference(account));

    // write_back[LibraAccount::LibraAccount](account)
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, account);

    // return $t17
    $ret0 := $t17;
    if (true) { assume $DebugTrackLocal(16, 28099, 18, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraAccount_extract_withdraw_capability_$direct_inter(sender: $Value, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
requires $LibraAccount_LibraAccount_$CallerDomain[$EmptyTypeValueArray, a#$Address($LibraAccount_sender_addr$75(sender))];
ensures b#$Boolean(old($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))))));
ensures $abort_flag ==> ((b#$Boolean(old($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $LibraAccount_sender_addr$75(sender))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, old($LibraAccount_spec_get_withdraw_cap($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $LibraAccount_WithdrawCapability_account_address), $LibraAccount_sender_addr$75(sender)))));
ensures !$abort_flag ==> (b#$Boolean($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraAccount_spec_get_key_rotation_cap_field($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)), old($LibraAccount_spec_get_key_rotation_cap_field($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))))));
ensures $LibraAccount_WithdrawCapability_$is_well_formed($ret0);
modifies $LibraAccount_LibraAccount_$memory;
ensures contents#$Memory($LibraAccount_LibraAccount_$memory) == old(contents#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_sender_addr$75(sender)) := contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_sender_addr$75(sender))]];
ensures domain#$Memory($LibraAccount_LibraAccount_$memory) == old(domain#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_sender_addr$75(sender)) := domain#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_sender_addr$75(sender))]];

procedure {:inline 1} $LibraAccount_extract_withdraw_capability_$direct_intra(sender: $Value, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
requires $LibraAccount_LibraAccount_$CallerDomain[$EmptyTypeValueArray, a#$Address($LibraAccount_sender_addr$75(sender))];
ensures b#$Boolean(old($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))))));
ensures $abort_flag ==> ((b#$Boolean(old($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $LibraAccount_sender_addr$75(sender))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, old($LibraAccount_spec_get_withdraw_cap($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $LibraAccount_WithdrawCapability_account_address), $LibraAccount_sender_addr$75(sender)))));
ensures !$abort_flag ==> (b#$Boolean($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraAccount_spec_get_key_rotation_cap_field($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)), old($LibraAccount_spec_get_key_rotation_cap_field($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1)))) || b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_key_rotation_cap($LibraAccount_LibraAccount_$memory, addr1))))))) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1)))) || b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_key_rotation_cap($LibraAccount_LibraAccount_$memory, addr1))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1)))) || b#$Boolean($Option_$is_none($LibraAccount_WithdrawCapability_type_value(), $SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1), $LibraAccount_LibraAccount_withdrawal_capability)))))) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1)))) || b#$Boolean($Option_$is_none($LibraAccount_WithdrawCapability_type_value(), $SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1), $LibraAccount_LibraAccount_withdrawal_capability)))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1), $LibraAccount_LibraAccount_authentication_key), old($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1), $LibraAccount_LibraAccount_authentication_key)))))))))));
ensures $LibraAccount_WithdrawCapability_$is_well_formed($ret0);
modifies $LibraAccount_LibraAccount_$memory;
ensures contents#$Memory($LibraAccount_LibraAccount_$memory) == old(contents#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_sender_addr$75(sender)) := contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_sender_addr$75(sender))]];
ensures domain#$Memory($LibraAccount_LibraAccount_$memory) == old(domain#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_sender_addr$75(sender)) := domain#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_sender_addr$75(sender))]];

procedure {:inline 1} $LibraAccount_extract_withdraw_capability(sender: $Value, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
requires $LibraAccount_LibraAccount_$CallerDomain[$EmptyTypeValueArray, a#$Address($LibraAccount_sender_addr$75(sender))];
ensures b#$Boolean(old($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))))));
ensures $abort_flag ==> ((b#$Boolean(old($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))))) &&
       $abort_code == i#$Integer($Integer(5))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $LibraAccount_sender_addr$75(sender))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, old($LibraAccount_spec_get_withdraw_cap($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $LibraAccount_WithdrawCapability_account_address), $LibraAccount_sender_addr$75(sender)))));
ensures !$abort_flag ==> (b#$Boolean($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraAccount_spec_get_key_rotation_cap_field($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)), old($LibraAccount_spec_get_key_rotation_cap_field($LibraAccount_LibraAccount_$memory, $LibraAccount_sender_addr$75(sender)))))));
ensures $LibraAccount_WithdrawCapability_$is_well_formed($ret0);
modifies $LibraAccount_LibraAccount_$memory;
ensures contents#$Memory($LibraAccount_LibraAccount_$memory) == old(contents#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_sender_addr$75(sender)) := contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_sender_addr$75(sender))]];
ensures domain#$Memory($LibraAccount_LibraAccount_$memory) == old(domain#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_sender_addr$75(sender)) := domain#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_sender_addr$75(sender))]];

procedure {:inline 1} $LibraAccount_has_published_account_limits_$def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 9708, 0, addr); }

    // bytecode translation starts here
    // $t2 := move(addr)
    call $t2 := $CopyOrMoveValue(addr);

    // $t3 := VASP::is_vasp($t2)
    call $t3 := $VASP_is_vasp($t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 9789, $abort_code);
      goto Abort;
    }

    // if ($t3) goto L0 else goto L1
    if (b#$Boolean($t3)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // tmp#$1 := VASP::has_account_limits<#0>($t2)
    call tmp#$1 := $VASP_has_account_limits($tv0, $t2);
    if ($abort_flag) {
      goto Abort;
    }

    // goto L3
    goto L3;

    // L2:
L2:

    // tmp#$1 := AccountLimits::has_window_published<#0>($t2)
    call tmp#$1 := $AccountLimits_has_window_published($tv0, $t2);
    if ($abort_flag) {
      goto Abort;
    }

    // goto L3
    goto L3;

    // L3:
L3:

    // return tmp#$1
    $ret0 := tmp#$1;
    if (true) { assume $DebugTrackLocal(16, 9779, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraAccount_has_published_account_limits_$direct_intra($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $LibraAccount_has_published_account_limits_$def($tv0, addr);
}


procedure {:inline 1} $LibraAccount_has_published_account_limits($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $LibraAccount_has_published_account_limits_$def($tv0, addr);
}


procedure {:inline 1} $LibraAccount_key_rotation_capability_address_$def(cap: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $LibraAccount_KeyRotationCapability_type_value()
    var $t2: $Value; // $AddressType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 57742, 0, cap); }

    // bytecode translation starts here
    // $t1 := move(cap)
    call $t1 := $CopyOrMoveValue(cap);

    // $t2 := get_field<LibraAccount::KeyRotationCapability>.account_address($t1)
    call $t2 := $GetFieldFromValue($t1, $LibraAccount_KeyRotationCapability_account_address);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(16, 57834, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraAccount_key_rotation_capability_address_$direct_inter(cap: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_KeyRotationCapability_$is_well_formed(cap);

    call $ret0 := $LibraAccount_key_rotation_capability_address_$def(cap);
}


procedure {:inline 1} $LibraAccount_key_rotation_capability_address_$direct_intra(cap: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_KeyRotationCapability_$is_well_formed(cap);

    call $ret0 := $LibraAccount_key_rotation_capability_address_$def(cap);
}


procedure {:inline 1} $LibraAccount_key_rotation_capability_address(cap: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_KeyRotationCapability_$is_well_formed(cap);

    call $ret0 := $LibraAccount_key_rotation_capability_address_$def(cap);
}


procedure {:inline 1} $LibraAccount_make_account_$def(new_account: $Value, auth_key_prefix: $Value) returns ()
{
    // declare local variables
    var authentication_key: $Value; // $Vector_type_value($IntegerType())
    var new_account_addr: $Value; // $AddressType()
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var tmp#$6: $Value; // $BooleanType()
    var tmp#$7: $Value; // $IntegerType()
    var tmp#$8: $Value; // $BooleanType()
    var tmp#$9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $Vector_type_value($IntegerType())
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Mutation; // ReferenceType($Vector_type_value($IntegerType()))
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $Vector_type_value($IntegerType())
    var $t19: $Value; // $Vector_type_value($IntegerType())
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $BooleanType()
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $AddressType()
    var $t26: $Value; // $BooleanType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $AddressType()
    var $t30: $Mutation; // ReferenceType($LibraAccount_AccountOperationsCapability_type_value())
    var $t31: $Mutation; // ReferenceType($Event_EventHandle_type_value($LibraAccount_CreateAccountEvent_type_value()))
    var $t32: $Value; // $IntegerType()
    var $t33: $Value; // $LibraAccount_CreateAccountEvent_type_value()
    var $t34: $Value; // $Event_EventHandle_type_value($LibraAccount_CreateAccountEvent_type_value())
    var $t35: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t36: $Value; // $Option_Option_type_value($LibraAccount_WithdrawCapability_type_value())
    var $t37: $Value; // $LibraAccount_KeyRotationCapability_type_value()
    var $t38: $Value; // $Option_Option_type_value($LibraAccount_KeyRotationCapability_type_value())
    var $t39: $Value; // $Event_EventHandle_type_value($LibraAccount_ReceivedPaymentEvent_type_value())
    var $t40: $Value; // $Event_EventHandle_type_value($LibraAccount_SentPaymentEvent_type_value())
    var $t41: $Value; // $IntegerType()
    var $t42: $Value; // $LibraAccount_LibraAccount_type_value()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 39465, 0, new_account); }
    if (true) { assume $DebugTrackLocal(16, 39465, 1, auth_key_prefix); }

    // bytecode translation starts here
    // $t10 := move(new_account)
    call $t10 := $CopyOrMoveValue(new_account);

    // $t11 := move(auth_key_prefix)
    call $t11 := $CopyOrMoveValue(auth_key_prefix);

    // new_account_addr := Signer::address_of($t10)
    call new_account_addr := $Signer_address_of($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 39752, $abort_code);
      goto Abort;
    }

    // $t12 := CoreAddresses::VM_RESERVED_ADDRESS()
    call $t12 := $CoreAddresses_VM_RESERVED_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t13 := !=(new_account_addr, $t12)
    $t13 := $Boolean(!$IsEqual(new_account_addr, $t12));

    // $t14 := 10
    $t14 := $Integer(10);

    // $t15 := Errors::invalid_argument($t14)
    call $t15 := $Errors_invalid_argument($t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 39948, $abort_code);
      goto Abort;
    }

    // if ($t13) goto L0 else goto L1
    if (b#$Boolean($t13)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t15)
    if (true) { assume $DebugTrackAbort(16, 39850, i#$Integer($t15)); }
    $abort_code := i#$Integer($t15);
    goto Abort;

    // L0:
L0:

    // authentication_key := $t11
    call authentication_key := $CopyOrMoveValue($t11);
    if (true) { assume $DebugTrackLocal(16, 40061, 2, authentication_key); }

    // $t16 := borrow_local(authentication_key)
    call $t16 := $BorrowLoc(2, authentication_key);

    // unpack_ref($t16)

    // $t17 := Signer::borrow_address($t10)
    call $t17 := $Signer_borrow_address($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 40182, $abort_code);
      goto Abort;
    }

    // $t18 := LCS::to_bytes<address>($t17)
    call $t18 := $LCS_to_bytes($AddressType(), $t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 40165, $abort_code);
      goto Abort;
    }

    // $t19 := read_ref($t16)
    call $t19 := $ReadRef($t16);

    // $t19 := Vector::append<u8>($t19, $t18)
    call $t19 := $Vector_append($IntegerType(), $t19, $t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 40115, $abort_code);
      goto Abort;
    }

    // write_ref($t16, $t19)
    call $t16 := $WriteRef($t16, $t19);

    // pack_ref($t16)

    // write_back[LocalRoot(authentication_key)]($t16)
    call authentication_key := $WritebackToValue($t16, 2, authentication_key);

    // $t20 := Vector::length<u8>(authentication_key)
    call $t20 := $Vector_length($IntegerType(), authentication_key);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 40259, $abort_code);
      goto Abort;
    }

    // $t21 := 32
    $t21 := $Integer(32);

    // $t22 := ==($t20, $t21)
    $t22 := $Boolean($IsEqual($t20, $t21));

    // $t23 := 8
    $t23 := $Integer(8);

    // $t24 := Errors::invalid_argument($t23)
    call $t24 := $Errors_invalid_argument($t23);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 40314, $abort_code);
      goto Abort;
    }

    // if ($t22) goto L2 else goto L3
    if (b#$Boolean($t22)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t24)
    if (true) { assume $DebugTrackAbort(16, 40231, i#$Integer($t24)); }
    $abort_code := i#$Integer($t24);
    goto Abort;

    // L2:
L2:

    // AccountFreezing::create($t10)
    call $AccountFreezing_create($t10);
    if ($abort_flag) {
      goto Abort;
    }

    // $t25 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t25 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t26 := exists<LibraAccount::AccountOperationsCapability>($t25)
    $t26 := $ResourceExists($LibraAccount_AccountOperationsCapability_$memory, $EmptyTypeValueArray, $t25);

    // $t27 := 22
    $t27 := $Integer(22);

    // $t28 := Errors::not_published($t27)
    call $t28 := $Errors_not_published($t27);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 40748, $abort_code);
      goto Abort;
    }

    // if ($t26) goto L4 else goto L5
    if (b#$Boolean($t26)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // abort($t28)
    if (true) { assume $DebugTrackAbort(16, 40634, i#$Integer($t28)); }
    $abort_code := i#$Integer($t28);
    goto Abort;

    // L4:
L4:

    // $t29 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t29 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t30 := borrow_global<LibraAccount::AccountOperationsCapability>($t29)
    call $t30 := $BorrowGlobal($LibraAccount_AccountOperationsCapability_$memory, $t29, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 40888, $abort_code);
      goto Abort;
    }

    // unpack_ref($t30)

    // $t31 := borrow_field<LibraAccount::AccountOperationsCapability>.creation_events($t30)
    call $t31 := $BorrowField($t30, $LibraAccount_AccountOperationsCapability_creation_events);

    // unpack_ref($t31)

    // $t32 := Roles::get_role_id(new_account_addr)
    call $t32 := $Roles_get_role_id(new_account_addr);
    if ($abort_flag) {
      goto Abort;
    }

    // $t33 := pack LibraAccount::CreateAccountEvent(new_account_addr, $t32)
    call $t33 := $LibraAccount_CreateAccountEvent_pack(0, 0, 0, new_account_addr, $t32);

    // $t34 := read_ref($t31)
    call $t34 := $ReadRef($t31);
    assert $Event_EventHandle_$invariant_holds($t34);

    // $t34 := Event::emit_event<LibraAccount::CreateAccountEvent>($t34, $t33)
    call $t34 := $Event_emit_event($LibraAccount_CreateAccountEvent_type_value(), $t34, $t33);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 40859, $abort_code);
      goto Abort;
    }

    // write_ref($t31, $t34)
    call $t31 := $WriteRef($t31, $t34);

    // pack_ref($t31)

    // write_back[Reference($t30)]($t31)
    call $t30 := $WritebackToReference($t31, $t30);

    // pack_ref($t30)

    // write_back[LibraAccount::AccountOperationsCapability]($t30)
    call $LibraAccount_AccountOperationsCapability_$memory := $WritebackToGlobal($LibraAccount_AccountOperationsCapability_$memory, $t30);

    // $t35 := pack LibraAccount::WithdrawCapability(new_account_addr)
    call $t35 := $LibraAccount_WithdrawCapability_pack(0, 0, 0, new_account_addr);

    // $t36 := Option::some<LibraAccount::WithdrawCapability>($t35)
    call $t36 := $Option_some($LibraAccount_WithdrawCapability_type_value(), $t35);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 41391, $abort_code);
      goto Abort;
    }

    // $t37 := pack LibraAccount::KeyRotationCapability(new_account_addr)
    call $t37 := $LibraAccount_KeyRotationCapability_pack(0, 0, 0, new_account_addr);

    // $t38 := Option::some<LibraAccount::KeyRotationCapability>($t37)
    call $t38 := $Option_some($LibraAccount_KeyRotationCapability_type_value(), $t37);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 41565, $abort_code);
      goto Abort;
    }

    // $t39 := Event::new_event_handle<LibraAccount::ReceivedPaymentEvent>($t10)
    call $t39 := $Event_new_event_handle($LibraAccount_ReceivedPaymentEvent_type_value(), $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 41733, $abort_code);
      goto Abort;
    }

    // $t40 := Event::new_event_handle<LibraAccount::SentPaymentEvent>($t10)
    call $t40 := $Event_new_event_handle($LibraAccount_SentPaymentEvent_type_value(), $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 41823, $abort_code);
      goto Abort;
    }

    // $t41 := 0
    $t41 := $Integer(0);

    // $t42 := pack LibraAccount::LibraAccount(authentication_key, $t36, $t38, $t39, $t40, $t41)
    call $t42 := $LibraAccount_LibraAccount_pack(0, 0, 0, authentication_key, $t36, $t38, $t39, $t40, $t41);

    // move_to<LibraAccount::LibraAccount>($t42, $t10)
    call $LibraAccount_LibraAccount_$memory := $MoveTo($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $t42, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 41246, $abort_code);
      goto Abort;
    }

    // LibraAccount::destroy_signer($t10)
    call $LibraAccount_destroy_signer($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 53406, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_make_account_$direct_intra(new_account: $Value, auth_key_prefix: $Value) returns ()
requires b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $LibraAccount_new_account_addr$79(new_account)));
{
    assume is#$Address(new_account);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    call $LibraAccount_make_account_$def(new_account, auth_key_prefix);
}


procedure {:inline 1} $LibraAccount_make_account(new_account: $Value, auth_key_prefix: $Value) returns ()
{
    assume is#$Address(new_account);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    call $LibraAccount_make_account_$def(new_account, auth_key_prefix);
}


procedure {:inline 1} $LibraAccount_module_prologue_$def($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time: $Value, chain_id: $Value) returns ()
{
    // declare local variables
    var tmp#$7: $Value; // $BooleanType()
    var tmp#$8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $Vector_type_value($IntegerType())
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 58284, 0, sender); }
    if (true) { assume $DebugTrackLocal(16, 58284, 1, txn_sequence_number); }
    if (true) { assume $DebugTrackLocal(16, 58284, 2, txn_public_key); }
    if (true) { assume $DebugTrackLocal(16, 58284, 3, txn_gas_price); }
    if (true) { assume $DebugTrackLocal(16, 58284, 4, txn_max_gas_units); }
    if (true) { assume $DebugTrackLocal(16, 58284, 5, txn_expiration_time); }
    if (true) { assume $DebugTrackLocal(16, 58284, 6, chain_id); }

    // bytecode translation starts here
    // $t9 := move(sender)
    call $t9 := $CopyOrMoveValue(sender);

    // $t10 := move(txn_sequence_number)
    call $t10 := $CopyOrMoveValue(txn_sequence_number);

    // $t11 := move(txn_public_key)
    call $t11 := $CopyOrMoveValue(txn_public_key);

    // $t12 := move(txn_gas_price)
    call $t12 := $CopyOrMoveValue(txn_gas_price);

    // $t13 := move(txn_max_gas_units)
    call $t13 := $CopyOrMoveValue(txn_max_gas_units);

    // $t14 := move(txn_expiration_time)
    call $t14 := $CopyOrMoveValue(txn_expiration_time);

    // $t15 := move(chain_id)
    call $t15 := $CopyOrMoveValue(chain_id);

    // $t16 := LibraTransactionPublishingOption::is_module_allowed($t9)
    call $t16 := $LibraTransactionPublishingOption_is_module_allowed($t9);
    if ($abort_flag) {
      goto Abort;
    }

    // $t17 := 1009
    $t17 := $Integer(1009);

    // $t18 := Errors::invalid_state($t17)
    call $t18 := $Errors_invalid_state($t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 58671, $abort_code);
      goto Abort;
    }

    // if ($t16) goto L0 else goto L1
    if (b#$Boolean($t16)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t9)

    // abort($t18)
    if (true) { assume $DebugTrackAbort(16, 58570, i#$Integer($t18)); }
    $abort_code := i#$Integer($t18);
    goto Abort;

    // L0:
L0:

    // LibraAccount::prologue_common<#0>($t9, $t10, $t11, $t12, $t13, $t14, $t15)
    call $LibraAccount_prologue_common($tv0, $t9, $t10, $t11, $t12, $t13, $t14, $t15);
    if ($abort_flag) {
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_module_prologue_$direct_intra($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time: $Value, chain_id: $Value) returns ()
{
    assume is#$Address(sender);

    assume $IsValidU64(txn_sequence_number);

    assume $Vector_$is_well_formed(txn_public_key) && (forall $$0: int :: {$select_vector(txn_public_key,$$0)} $$0 >= 0 && $$0 < $vlen(txn_public_key) ==> $IsValidU8($select_vector(txn_public_key,$$0)));

    assume $IsValidU64(txn_gas_price);

    assume $IsValidU64(txn_max_gas_units);

    assume $IsValidU64(txn_expiration_time);

    assume $IsValidU8(chain_id);

    call $LibraAccount_module_prologue_$def($tv0, sender, txn_sequence_number, txn_public_key, txn_gas_price, txn_max_gas_units, txn_expiration_time, chain_id);
}


procedure {:inline 1} $LibraAccount_module_prologue($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time: $Value, chain_id: $Value) returns ()
{
    assume is#$Address(sender);

    assume $IsValidU64(txn_sequence_number);

    assume $Vector_$is_well_formed(txn_public_key) && (forall $$0: int :: {$select_vector(txn_public_key,$$0)} $$0 >= 0 && $$0 < $vlen(txn_public_key) ==> $IsValidU8($select_vector(txn_public_key,$$0)));

    assume $IsValidU64(txn_gas_price);

    assume $IsValidU64(txn_max_gas_units);

    assume $IsValidU64(txn_expiration_time);

    assume $IsValidU8(chain_id);

    call $LibraAccount_module_prologue_$def($tv0, sender, txn_sequence_number, txn_public_key, txn_gas_price, txn_max_gas_units, txn_expiration_time, chain_id);
}


procedure {:inline 1} $LibraAccount_pay_from_$def($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, metadata_signature: $Value, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool, $LibraAccount_Balance_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var $t5: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $Vector_type_value($IntegerType())
    var $t9: $Value; // $Vector_type_value($IntegerType())
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $Libra_Libra_type_value($tv0)
    var $LibraAccount_LibraAccount_$SelfDomain: [$TypeValueArray, int]bool;
    var $LibraAccount_Balance_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 30445, 0, cap); }
    if (true) { assume $DebugTrackLocal(16, 30445, 1, payee); }
    if (true) { assume $DebugTrackLocal(16, 30445, 2, amount); }
    if (true) { assume $DebugTrackLocal(16, 30445, 3, metadata); }
    if (true) { assume $DebugTrackLocal(16, 30445, 4, metadata_signature); }
    $LibraAccount_LibraAccount_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$77($tv0, cap)) := true][$EmptyTypeValueArray, a#$Address(payee) := true];
    $LibraAccount_Balance_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($LibraAccount_payer$77($tv0, cap)) := true][$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee) := true];

    // bytecode translation starts here
    // $t5 := move(cap)
    call $t5 := $CopyOrMoveValue(cap);

    // $t6 := move(payee)
    call $t6 := $CopyOrMoveValue(payee);

    // $t7 := move(amount)
    call $t7 := $CopyOrMoveValue(amount);

    // $t8 := move(metadata)
    call $t8 := $CopyOrMoveValue(metadata);

    // $t9 := move(metadata_signature)
    call $t9 := $CopyOrMoveValue(metadata_signature);

    // $t10 := get_field<LibraAccount::WithdrawCapability>.account_address($t5)
    call $t10 := $GetFieldFromValue($t5, $LibraAccount_WithdrawCapability_account_address);

    // $t11 := LibraAccount::withdraw_from<#0>($t5, $t6, $t7, $t8)
    call $t11 := $LibraAccount_withdraw_from($tv0, $t5, $t6, $t7, $t8, $LibraAccount_LibraAccount_$SelfDomain, $LibraAccount_Balance_$SelfDomain);
    if ($abort_flag) {
      goto Abort;
    }

    // LibraAccount::deposit<#0>($t10, $t6, $t11, $t8, $t9)
    call $LibraAccount_deposit($tv0, $t10, $t6, $t11, $t8, $t9, $ConstMemoryDomain(true), $LibraAccount_LibraAccount_$SelfDomain, $LibraAccount_Balance_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 11829, $abort_code);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_pay_from_$direct_inter($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, metadata_signature: $Value, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool, $LibraAccount_Balance_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraAccount_LibraAccount_$CallerDomain[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$77($tv0, cap))];
requires $LibraAccount_LibraAccount_$CallerDomain[$EmptyTypeValueArray, a#$Address(payee)];
requires $LibraAccount_Balance_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($LibraAccount_payer$77($tv0, cap))];
requires $LibraAccount_Balance_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee)];
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, payee))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean($IsEqual(amount, $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(amount, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, metadata_signature, metadata, amount))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_limit_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, payee))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$57($tv0, cap)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)), $LibraAccount_Balance_coin), $Libra_Libra_value)) < i#$Integer(amount)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, $LibraAccount_payer$57($tv0, cap)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_limit_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, payee)))))
    || b#$Boolean(old($Boolean($IsEqual(amount, $Integer(0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(amount, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, metadata_signature, metadata, amount)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_limit_address))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, payee)))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$57($tv0, cap))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))))))))))
    || b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)), $LibraAccount_Balance_coin), $Libra_Libra_value)) < i#$Integer(amount))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, $LibraAccount_payer$57($tv0, cap))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_limit_address))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, payee))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean($IsEqual(amount, $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(amount, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, metadata_signature, metadata, amount))))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_limit_address)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, payee))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$57($tv0, cap)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)), $LibraAccount_Balance_coin), $Libra_Libra_value)) < i#$Integer(amount)))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, $LibraAccount_payer$57($tv0, cap)))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_limit_address)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$77($tv0, cap))));
ensures !$abort_flag ==> (b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, payee)));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$77($tv0, cap))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $LibraAccount_payer$77($tv0, cap)), $LibraAccount_LibraAccount_withdrawal_capability), old($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $LibraAccount_payer$77($tv0, cap)), $LibraAccount_LibraAccount_withdrawal_capability))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual($LibraAccount_payer$77($tv0, cap), payee))) ==> b#$Boolean($Boolean($IsEqual($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, $LibraAccount_payer$77($tv0, cap)), old($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, $LibraAccount_payer$77($tv0, cap)))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($LibraAccount_payer$77($tv0, cap), payee))) ==> b#$Boolean($Boolean($IsEqual($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, $LibraAccount_payer$77($tv0, cap)), $Integer(i#$Integer(old($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, $LibraAccount_payer$77($tv0, cap)))) - i#$Integer(amount))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($LibraAccount_payer$77($tv0, cap), payee))) ==> b#$Boolean($Boolean($IsEqual($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, payee), $Integer(i#$Integer(old($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, payee))) + i#$Integer(amount))))))));
modifies $AccountLimits_Window_$memory;
modifies $LibraAccount_LibraAccount_$memory;
ensures contents#$Memory($LibraAccount_LibraAccount_$memory) == old(contents#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$77($tv0, cap)) := contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$77($tv0, cap))]][$EmptyTypeValueArray, a#$Address(payee) := contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address(payee)]];
ensures domain#$Memory($LibraAccount_LibraAccount_$memory) == old(domain#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$77($tv0, cap)) := domain#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$77($tv0, cap))]][$EmptyTypeValueArray, a#$Address(payee) := domain#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address(payee)]];
modifies $LibraAccount_Balance_$memory;
ensures contents#$Memory($LibraAccount_Balance_$memory) == old(contents#$Memory($LibraAccount_Balance_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($LibraAccount_payer$77($tv0, cap)) := contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($LibraAccount_payer$77($tv0, cap))]][$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee) := contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee)]];
ensures domain#$Memory($LibraAccount_Balance_$memory) == old(domain#$Memory($LibraAccount_Balance_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($LibraAccount_payer$77($tv0, cap)) := domain#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($LibraAccount_payer$77($tv0, cap))]][$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee) := domain#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee)]];

procedure {:inline 1} $LibraAccount_pay_from_$direct_intra($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, metadata_signature: $Value, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool, $LibraAccount_Balance_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraAccount_LibraAccount_$CallerDomain[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$77($tv0, cap))];
requires $LibraAccount_LibraAccount_$CallerDomain[$EmptyTypeValueArray, a#$Address(payee)];
requires $LibraAccount_Balance_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($LibraAccount_payer$77($tv0, cap))];
requires $LibraAccount_Balance_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee)];
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, payee))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean($IsEqual(amount, $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(amount, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, metadata_signature, metadata, amount))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_limit_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, payee))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$57($tv0, cap)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)), $LibraAccount_Balance_coin), $Libra_Libra_value)) < i#$Integer(amount)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, $LibraAccount_payer$57($tv0, cap)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_limit_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, payee)))))
    || b#$Boolean(old($Boolean($IsEqual(amount, $Integer(0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(amount, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, metadata_signature, metadata, amount)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_limit_address))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, payee)))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$57($tv0, cap))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))))))))))
    || b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)), $LibraAccount_Balance_coin), $Libra_Libra_value)) < i#$Integer(amount))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, $LibraAccount_payer$57($tv0, cap))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_limit_address))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, payee))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean($IsEqual(amount, $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(amount, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, metadata_signature, metadata, amount))))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_limit_address)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, payee))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$57($tv0, cap)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)), $LibraAccount_Balance_coin), $Libra_Libra_value)) < i#$Integer(amount)))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, $LibraAccount_payer$57($tv0, cap)))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_limit_address)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$77($tv0, cap))));
ensures !$abort_flag ==> (b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, payee)));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$77($tv0, cap))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $LibraAccount_payer$77($tv0, cap)), $LibraAccount_LibraAccount_withdrawal_capability), old($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $LibraAccount_payer$77($tv0, cap)), $LibraAccount_LibraAccount_withdrawal_capability))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual($LibraAccount_payer$77($tv0, cap), payee))) ==> b#$Boolean($Boolean($IsEqual($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, $LibraAccount_payer$77($tv0, cap)), old($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, $LibraAccount_payer$77($tv0, cap)))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($LibraAccount_payer$77($tv0, cap), payee))) ==> b#$Boolean($Boolean($IsEqual($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, $LibraAccount_payer$77($tv0, cap)), $Integer(i#$Integer(old($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, $LibraAccount_payer$77($tv0, cap)))) - i#$Integer(amount))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($LibraAccount_payer$77($tv0, cap), payee))) ==> b#$Boolean($Boolean($IsEqual($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, payee), $Integer(i#$Integer(old($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, payee))) + i#$Integer(amount))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1), $LibraAccount_LibraAccount_authentication_key), old($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1), $LibraAccount_LibraAccount_authentication_key)))))))))));
modifies $AccountLimits_Window_$memory;
modifies $LibraAccount_LibraAccount_$memory;
ensures contents#$Memory($LibraAccount_LibraAccount_$memory) == old(contents#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$77($tv0, cap)) := contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$77($tv0, cap))]][$EmptyTypeValueArray, a#$Address(payee) := contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address(payee)]];
ensures domain#$Memory($LibraAccount_LibraAccount_$memory) == old(domain#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$77($tv0, cap)) := domain#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$77($tv0, cap))]][$EmptyTypeValueArray, a#$Address(payee) := domain#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address(payee)]];
modifies $LibraAccount_Balance_$memory;
ensures contents#$Memory($LibraAccount_Balance_$memory) == old(contents#$Memory($LibraAccount_Balance_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($LibraAccount_payer$77($tv0, cap)) := contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($LibraAccount_payer$77($tv0, cap))]][$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee) := contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee)]];
ensures domain#$Memory($LibraAccount_Balance_$memory) == old(domain#$Memory($LibraAccount_Balance_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($LibraAccount_payer$77($tv0, cap)) := domain#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($LibraAccount_payer$77($tv0, cap))]][$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee) := domain#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee)]];

procedure {:inline 1} $LibraAccount_pay_from($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, metadata_signature: $Value, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool, $LibraAccount_Balance_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraAccount_LibraAccount_$CallerDomain[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$77($tv0, cap))];
requires $LibraAccount_LibraAccount_$CallerDomain[$EmptyTypeValueArray, a#$Address(payee)];
requires $LibraAccount_Balance_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($LibraAccount_payer$77($tv0, cap))];
requires $LibraAccount_Balance_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee)];
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, payee))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean($IsEqual(amount, $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(amount, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, metadata_signature, metadata, amount))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_limit_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, payee))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$57($tv0, cap)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)), $LibraAccount_Balance_coin), $Libra_Libra_value)) < i#$Integer(amount)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, $LibraAccount_payer$57($tv0, cap)))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_limit_address)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64)))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, payee)))))
    || b#$Boolean(old($Boolean($IsEqual(amount, $Integer(0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(amount, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, metadata_signature, metadata, amount)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_limit_address))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, payee)))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$57($tv0, cap))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))))))))))
    || b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)), $LibraAccount_Balance_coin), $Libra_Libra_value)) < i#$Integer(amount))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, $LibraAccount_payer$57($tv0, cap))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_limit_address))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64)))))))))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual($SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, payee))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean($IsEqual(amount, $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(0)))) && b#$Boolean($Boolean(i#$Integer($FixedPoint32_spec_multiply_u64(amount, $Libra_lbr_exchange_rate$59($Libra_CurrencyInfo_$memory, $tv0))) > i#$Integer($Integer(18446744073709551615))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Vector_$is_empty($IntegerType(), $DualAttestation_spec_compliance_public_key($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_signature_is_valid($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Credential_$memory, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, metadata_signature, metadata, amount))))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($vlen_value(metadata_signature), $Integer(0)))) || b#$Boolean($DualAttestation_spec_dual_attestation_required($Libra_CurrencyInfo_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $DualAttestation_Limit_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, amount)))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, $DualAttestation_spec_credential_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_limit_address)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_window_inflow)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_Window_tracked_balance)) + i#$Integer(amount))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $SelectField(cap, $LibraAccount_WithdrawCapability_account_address), payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payee)))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, payee))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$57($tv0, cap)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($LibraAccount_AccountOperationsCapability_$memory)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_withdrawal_limits($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $AccountLimits_Window_$memory, $tv0, amount, $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$57($tv0, cap)), $LibraAccount_Balance_coin), $Libra_Libra_value)) < i#$Integer(amount)))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($AccountFreezing_spec_account_is_frozen($AccountFreezing_FreezingBit_$memory, $LibraAccount_payer$57($tv0, cap)))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($AccountLimits_LimitsDefinition_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_limit_address)))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($AccountLimits_spec_window_reset($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_Window_window_outflow)) + i#$Integer(amount))) > i#$Integer($Integer(18446744073709551615))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))), $AccountLimits_Window_window_start)) + i#$Integer($SelectField($AccountLimits_spec_window_limits($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap)))), $AccountLimits_LimitsDefinition_time_period)))) > i#$Integer($Integer($MAX_U64))))))))) &&
       $abort_code == i#$Integer($Integer(8)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, $LibraAccount_payer$57($tv0, cap), payee, $Boolean(true))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_window_unrestricted($AccountLimits_LimitsDefinition_$memory, $tv0, $ResourceValue($AccountLimits_Window_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $LibraAccount_payer$57($tv0, cap))))))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_payer$77($tv0, cap))));
ensures !$abort_flag ==> (b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, payee)));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $LibraAccount_payer$77($tv0, cap))));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payee)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $LibraAccount_payer$77($tv0, cap)), $LibraAccount_LibraAccount_withdrawal_capability), old($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, $LibraAccount_payer$77($tv0, cap)), $LibraAccount_LibraAccount_withdrawal_capability))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual($LibraAccount_payer$77($tv0, cap), payee))) ==> b#$Boolean($Boolean($IsEqual($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, $LibraAccount_payer$77($tv0, cap)), old($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, $LibraAccount_payer$77($tv0, cap)))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($LibraAccount_payer$77($tv0, cap), payee))) ==> b#$Boolean($Boolean($IsEqual($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, $LibraAccount_payer$77($tv0, cap)), $Integer(i#$Integer(old($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, $LibraAccount_payer$77($tv0, cap)))) - i#$Integer(amount))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!$IsEqual($LibraAccount_payer$77($tv0, cap), payee))) ==> b#$Boolean($Boolean($IsEqual($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, payee), $Integer(i#$Integer(old($LibraAccount_$balance($LibraAccount_Balance_$memory, $tv0, payee))) + i#$Integer(amount))))))));
modifies $AccountLimits_Window_$memory;
modifies $LibraAccount_LibraAccount_$memory;
ensures contents#$Memory($LibraAccount_LibraAccount_$memory) == old(contents#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$77($tv0, cap)) := contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$77($tv0, cap))]][$EmptyTypeValueArray, a#$Address(payee) := contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address(payee)]];
ensures domain#$Memory($LibraAccount_LibraAccount_$memory) == old(domain#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$77($tv0, cap)) := domain#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$77($tv0, cap))]][$EmptyTypeValueArray, a#$Address(payee) := domain#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address(payee)]];
modifies $LibraAccount_Balance_$memory;
ensures contents#$Memory($LibraAccount_Balance_$memory) == old(contents#$Memory($LibraAccount_Balance_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($LibraAccount_payer$77($tv0, cap)) := contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($LibraAccount_payer$77($tv0, cap))]][$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee) := contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee)]];
ensures domain#$Memory($LibraAccount_Balance_$memory) == old(domain#$Memory($LibraAccount_Balance_$memory))[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($LibraAccount_payer$77($tv0, cap)) := domain#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($LibraAccount_payer$77($tv0, cap))]][$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee) := domain#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payee)]];

procedure {:inline 1} $LibraAccount_prologue_common_$def($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time_seconds: $Value, chain_id: $Value) returns ()
{
    // declare local variables
    var balance_amount: $Value; // $IntegerType()
    var max_transaction_fee: $Value; // $IntegerType()
    var sender_account: $Value; // $LibraAccount_LibraAccount_type_value()
    var tmp#$10: $Value; // $BooleanType()
    var tmp#$11: $Value; // $IntegerType()
    var tmp#$12: $Value; // $BooleanType()
    var tmp#$13: $Value; // $IntegerType()
    var tmp#$14: $Value; // $BooleanType()
    var tmp#$15: $Value; // $IntegerType()
    var tmp#$16: $Value; // $BooleanType()
    var tmp#$17: $Value; // $IntegerType()
    var tmp#$18: $Value; // $BooleanType()
    var tmp#$19: $Value; // $IntegerType()
    var tmp#$20: $Value; // $BooleanType()
    var tmp#$21: $Value; // $IntegerType()
    var tmp#$22: $Value; // $BooleanType()
    var tmp#$23: $Value; // $IntegerType()
    var tmp#$24: $Value; // $BooleanType()
    var tmp#$25: $Value; // $IntegerType()
    var tmp#$26: $Value; // $BooleanType()
    var tmp#$27: $Value; // $IntegerType()
    var tmp#$28: $Value; // $BooleanType()
    var tmp#$29: $Value; // $IntegerType()
    var transaction_sender: $Value; // $AddressType()
    var $t31: $Value; // $AddressType()
    var $t32: $Value; // $IntegerType()
    var $t33: $Value; // $Vector_type_value($IntegerType())
    var $t34: $Value; // $IntegerType()
    var $t35: $Value; // $IntegerType()
    var $t36: $Value; // $IntegerType()
    var $t37: $Value; // $IntegerType()
    var $t38: $Value; // $IntegerType()
    var $t39: $Value; // $BooleanType()
    var $t40: $Value; // $IntegerType()
    var $t41: $Value; // $IntegerType()
    var $t42: $Value; // $BooleanType()
    var $t43: $Value; // $IntegerType()
    var $t44: $Value; // $IntegerType()
    var $t45: $Value; // $BooleanType()
    var $t46: $Value; // $BooleanType()
    var $t47: $Value; // $IntegerType()
    var $t48: $Value; // $IntegerType()
    var $t49: $Value; // $Vector_type_value($IntegerType())
    var $t50: $Value; // $Vector_type_value($IntegerType())
    var $t51: $Value; // $BooleanType()
    var $t52: $Value; // $IntegerType()
    var $t53: $Value; // $IntegerType()
    var $t54: $Value; // $IntegerType()
    var $t55: $Value; // $IntegerType()
    var $t56: $Value; // $IntegerType()
    var $t57: $Value; // $IntegerType()
    var $t58: $Value; // $BooleanType()
    var $t59: $Value; // $IntegerType()
    var $t60: $Value; // $IntegerType()
    var $t61: $Value; // $IntegerType()
    var $t62: $Value; // $BooleanType()
    var $t63: $Value; // $BooleanType()
    var $t64: $Value; // $IntegerType()
    var $t65: $Value; // $IntegerType()
    var $t66: $Value; // $BooleanType()
    var $t67: $Value; // $IntegerType()
    var $t68: $Value; // $IntegerType()
    var $t69: $Value; // $IntegerType()
    var $t70: $Value; // $BooleanType()
    var $t71: $Value; // $IntegerType()
    var $t72: $Value; // $IntegerType()
    var $t73: $Value; // $IntegerType()
    var $t74: $Value; // $BooleanType()
    var $t75: $Value; // $IntegerType()
    var $t76: $Value; // $IntegerType()
    var $t77: $Value; // $IntegerType()
    var $t78: $Value; // $BooleanType()
    var $t79: $Value; // $IntegerType()
    var $t80: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 64772, 0, sender); }
    if (true) { assume $DebugTrackLocal(16, 64772, 1, txn_sequence_number); }
    if (true) { assume $DebugTrackLocal(16, 64772, 2, txn_public_key); }
    if (true) { assume $DebugTrackLocal(16, 64772, 3, txn_gas_price); }
    if (true) { assume $DebugTrackLocal(16, 64772, 4, txn_max_gas_units); }
    if (true) { assume $DebugTrackLocal(16, 64772, 5, txn_expiration_time_seconds); }
    if (true) { assume $DebugTrackLocal(16, 64772, 6, chain_id); }

    // bytecode translation starts here
    // $t31 := move(sender)
    call $t31 := $CopyOrMoveValue(sender);

    // $t32 := move(txn_sequence_number)
    call $t32 := $CopyOrMoveValue(txn_sequence_number);

    // $t33 := move(txn_public_key)
    call $t33 := $CopyOrMoveValue(txn_public_key);

    // $t34 := move(txn_gas_price)
    call $t34 := $CopyOrMoveValue(txn_gas_price);

    // $t35 := move(txn_max_gas_units)
    call $t35 := $CopyOrMoveValue(txn_max_gas_units);

    // $t36 := move(txn_expiration_time_seconds)
    call $t36 := $CopyOrMoveValue(txn_expiration_time_seconds);

    // $t37 := move(chain_id)
    call $t37 := $CopyOrMoveValue(chain_id);

    // transaction_sender := Signer::address_of($t31)
    call transaction_sender := $Signer_address_of($t31);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 65099, $abort_code);
      goto Abort;
    }

    // $t38 := ChainId::get()
    call $t38 := $ChainId_get();
    if ($abort_flag) {
      goto Abort;
    }

    // $t39 := ==($t38, $t37)
    $t39 := $Boolean($IsEqual($t38, $t37));

    // $t40 := 1007
    $t40 := $Integer(1007);

    // $t41 := Errors::invalid_argument($t40)
    call $t41 := $Errors_invalid_argument($t40);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 65280, $abort_code);
      goto Abort;
    }

    // if ($t39) goto L0 else goto L1
    if (b#$Boolean($t39)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t41)
    if (true) { assume $DebugTrackAbort(16, 65237, i#$Integer($t41)); }
    $abort_code := i#$Integer($t41);
    goto Abort;

    // L0:
L0:

    // $t42 := LibraAccount::exists_at(transaction_sender)
    call $t42 := $LibraAccount_exists_at(transaction_sender);
    if ($abort_flag) {
      goto Abort;
    }

    // $t43 := 1004
    $t43 := $Integer(1004);

    // $t44 := Errors::invalid_argument($t43)
    call $t44 := $Errors_invalid_argument($t43);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 65449, $abort_code);
      goto Abort;
    }

    // if ($t42) goto L2 else goto L3
    if (b#$Boolean($t42)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t44)
    if (true) { assume $DebugTrackAbort(16, 65403, i#$Integer($t44)); }
    $abort_code := i#$Integer($t44);
    goto Abort;

    // L2:
L2:

    // $t45 := AccountFreezing::account_is_frozen(transaction_sender)
    call $t45 := $AccountFreezing_account_is_frozen(transaction_sender);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 65643, $abort_code);
      goto Abort;
    }

    // $t46 := !($t45)
    call $t46 := $Not($t45);

    // $t47 := 1000
    $t47 := $Integer(1000);

    // $t48 := Errors::invalid_state($t47)
    call $t48 := $Errors_invalid_state($t47);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 65702, $abort_code);
      goto Abort;
    }

    // if ($t46) goto L4 else goto L5
    if (b#$Boolean($t46)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // abort($t48)
    if (true) { assume $DebugTrackAbort(16, 65605, i#$Integer($t48)); }
    $abort_code := i#$Integer($t48);
    goto Abort;

    // L4:
L4:

    // sender_account := get_global<LibraAccount::LibraAccount>(transaction_sender)
    call sender_account := $GetGlobal($LibraAccount_LibraAccount_$memory, transaction_sender, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 65832, $abort_code);
      goto Abort;
    }
    if (true) { assume $DebugTrackLocal(16, 65832, 9, sender_account); }

    // $t49 := Hash::sha3_256($t33)
    call $t49 := $Hash_sha3_256($t33);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 66018, $abort_code);
      goto Abort;
    }

    // $t50 := get_field<LibraAccount::LibraAccount>.authentication_key(sender_account)
    call $t50 := $GetFieldFromValue(sender_account, $LibraAccount_LibraAccount_authentication_key);

    // $t51 := ==($t49, $t50)
    $t51 := $Boolean($IsEqual($t49, $t50));

    // $t52 := 1001
    $t52 := $Integer(1001);

    // $t53 := Errors::invalid_argument($t52)
    call $t53 := $Errors_invalid_argument($t52);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 66103, $abort_code);
      goto Abort;
    }

    // if ($t51) goto L6 else goto L7
    if (b#$Boolean($t51)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // destroy(sender_account)

    // abort($t53)
    if (true) { assume $DebugTrackAbort(16, 65992, i#$Integer($t53)); }
    $abort_code := i#$Integer($t53);
    goto Abort;

    // L6:
L6:

    // $t54 := (u128)($t34)
    call $t54 := $CastU128($t34);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 66277, $abort_code);
      goto Abort;
    }

    // $t55 := (u128)($t35)
    call $t55 := $CastU128($t35);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 66303, $abort_code);
      goto Abort;
    }

    // $t56 := *($t54, $t55)
    call $t56 := $MulU128($t54, $t55);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 66301, $abort_code);
      goto Abort;
    }

    // $t57 := 18446744073709551615
    $t57 := $Integer(18446744073709551615);

    // $t58 := <=($t56, $t57)
    call $t58 := $Le($t56, $t57);

    // $t59 := 1005
    $t59 := $Integer(1005);

    // $t60 := Errors::invalid_argument($t59)
    call $t60 := $Errors_invalid_argument($t59);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 66363, $abort_code);
      goto Abort;
    }

    // if ($t58) goto L8 else goto L9
    if (b#$Boolean($t58)) { goto L8; } else { goto L9; }

    // L9:
L9:

    // destroy(sender_account)

    // abort($t60)
    if (true) { assume $DebugTrackAbort(16, 66257, i#$Integer($t60)); }
    $abort_code := i#$Integer($t60);
    goto Abort;

    // L8:
L8:

    // max_transaction_fee := *($t34, $t35)
    call max_transaction_fee := $MulU64($t34, $t35);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 66473, $abort_code);
      goto Abort;
    }
    if (true) { assume $DebugTrackLocal(16, 66473, 8, max_transaction_fee); }

    // $t61 := 0
    $t61 := $Integer(0);

    // $t62 := >(max_transaction_fee, $t61)
    call $t62 := $Gt(max_transaction_fee, $t61);

    // if ($t62) goto L10 else goto L11
    if (b#$Boolean($t62)) { goto L10; } else { goto L11; }

    // L11:
L11:

    // goto L12
    goto L12;

    // L10:
L10:

    // $t63 := exists<LibraAccount::Balance<#0>>(transaction_sender)
    $t63 := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), transaction_sender);

    // $t64 := 1005
    $t64 := $Integer(1005);

    // $t65 := Errors::invalid_argument($t64)
    call $t65 := $Errors_invalid_argument($t64);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 66780, $abort_code);
      goto Abort;
    }

    // if ($t63) goto L13 else goto L14
    if (b#$Boolean($t63)) { goto L13; } else { goto L14; }

    // L14:
L14:

    // destroy(sender_account)

    // abort($t65)
    if (true) { assume $DebugTrackAbort(16, 66688, i#$Integer($t65)); }
    $abort_code := i#$Integer($t65);
    goto Abort;

    // L13:
L13:

    // balance_amount := LibraAccount::balance<#0>(transaction_sender)
    call balance_amount := $LibraAccount_balance($tv0, transaction_sender);
    if ($abort_flag) {
      goto Abort;
    }

    // $t66 := >=(balance_amount, max_transaction_fee)
    call $t66 := $Ge(balance_amount, max_transaction_fee);

    // $t67 := 1005
    $t67 := $Integer(1005);

    // $t68 := Errors::invalid_argument($t67)
    call $t68 := $Errors_invalid_argument($t67);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 67096, $abort_code);
      goto Abort;
    }

    // if ($t66) goto L12 else goto L15
    if (b#$Boolean($t66)) { goto L12; } else { goto L15; }

    // L15:
L15:

    // destroy(sender_account)

    // abort($t68)
    if (true) { assume $DebugTrackAbort(16, 67009, i#$Integer($t68)); }
    $abort_code := i#$Integer($t68);
    goto Abort;

    // L12:
L12:

    // $t69 := get_field<LibraAccount::LibraAccount>.sequence_number(sender_account)
    call $t69 := $GetFieldFromValue(sender_account, $LibraAccount_LibraAccount_sequence_number);

    // $t70 := >=($t32, $t69)
    call $t70 := $Ge($t32, $t69);

    // $t71 := 1002
    $t71 := $Integer(1002);

    // $t72 := Errors::invalid_argument($t71)
    call $t72 := $Errors_invalid_argument($t71);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 67366, $abort_code);
      goto Abort;
    }

    // if ($t70) goto L16 else goto L17
    if (b#$Boolean($t70)) { goto L16; } else { goto L17; }

    // L17:
L17:

    // destroy(sender_account)

    // abort($t72)
    if (true) { assume $DebugTrackAbort(16, 67271, i#$Integer($t72)); }
    $abort_code := i#$Integer($t72);
    goto Abort;

    // L16:
L16:

    // $t73 := get_field<LibraAccount::LibraAccount>.sequence_number(sender_account)
    call $t73 := $GetFieldFromValue(sender_account, $LibraAccount_LibraAccount_sequence_number);

    // $t74 := ==($t32, $t73)
    $t74 := $Boolean($IsEqual($t32, $t73));

    // $t75 := 1003
    $t75 := $Integer(1003);

    // $t76 := Errors::invalid_argument($t75)
    call $t76 := $Errors_invalid_argument($t75);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 67693, $abort_code);
      goto Abort;
    }

    // if ($t74) goto L18 else goto L19
    if (b#$Boolean($t74)) { goto L18; } else { goto L19; }

    // L19:
L19:

    // abort($t76)
    if (true) { assume $DebugTrackAbort(16, 67598, i#$Integer($t76)); }
    $abort_code := i#$Integer($t76);
    goto Abort;

    // L18:
L18:

    // $t77 := LibraTimestamp::now_seconds()
    call $t77 := $LibraTimestamp_now_seconds();
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 67863, $abort_code);
      goto Abort;
    }

    // $t78 := <($t77, $t36)
    call $t78 := $Lt($t77, $t36);

    // $t79 := 1006
    $t79 := $Integer(1006);

    // $t80 := Errors::invalid_argument($t79)
    call $t80 := $Errors_invalid_argument($t79);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 67928, $abort_code);
      goto Abort;
    }

    // if ($t78) goto L20 else goto L21
    if (b#$Boolean($t78)) { goto L20; } else { goto L21; }

    // L21:
L21:

    // abort($t80)
    if (true) { assume $DebugTrackAbort(16, 67827, i#$Integer($t80)); }
    $abort_code := i#$Integer($t80);
    goto Abort;

    // L20:
L20:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_prologue_common_$direct_intra($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time_seconds: $Value, chain_id: $Value) returns ()
{
    assume is#$Address(sender);

    assume $IsValidU64(txn_sequence_number);

    assume $Vector_$is_well_formed(txn_public_key) && (forall $$0: int :: {$select_vector(txn_public_key,$$0)} $$0 >= 0 && $$0 < $vlen(txn_public_key) ==> $IsValidU8($select_vector(txn_public_key,$$0)));

    assume $IsValidU64(txn_gas_price);

    assume $IsValidU64(txn_max_gas_units);

    assume $IsValidU64(txn_expiration_time_seconds);

    assume $IsValidU8(chain_id);

    call $LibraAccount_prologue_common_$def($tv0, sender, txn_sequence_number, txn_public_key, txn_gas_price, txn_max_gas_units, txn_expiration_time_seconds, chain_id);
}


procedure {:inline 1} $LibraAccount_prologue_common($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time_seconds: $Value, chain_id: $Value) returns ()
{
    assume is#$Address(sender);

    assume $IsValidU64(txn_sequence_number);

    assume $Vector_$is_well_formed(txn_public_key) && (forall $$0: int :: {$select_vector(txn_public_key,$$0)} $$0 >= 0 && $$0 < $vlen(txn_public_key) ==> $IsValidU8($select_vector(txn_public_key,$$0)));

    assume $IsValidU64(txn_gas_price);

    assume $IsValidU64(txn_max_gas_units);

    assume $IsValidU64(txn_expiration_time_seconds);

    assume $IsValidU8(chain_id);

    call $LibraAccount_prologue_common_$def($tv0, sender, txn_sequence_number, txn_public_key, txn_gas_price, txn_max_gas_units, txn_expiration_time_seconds, chain_id);
}


procedure {:inline 1} $LibraAccount_restore_key_rotation_capability_$def(cap: $Value) returns ()
{
    // declare local variables
    var account: $Mutation; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var $t4: $Value; // $LibraAccount_KeyRotationCapability_type_value()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Mutation; // ReferenceType($Option_Option_type_value($LibraAccount_KeyRotationCapability_type_value()))
    var $t11: $Value; // $Option_Option_type_value($LibraAccount_KeyRotationCapability_type_value())

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 36118, 0, cap); }

    // bytecode translation starts here
    // $t4 := move(cap)
    call $t4 := $CopyOrMoveValue(cap);

    // $t5 := get_field<LibraAccount::KeyRotationCapability>.account_address($t4)
    call $t5 := $GetFieldFromValue($t4, $LibraAccount_KeyRotationCapability_account_address);

    // $t6 := LibraAccount::exists_at($t5)
    call $t6 := $LibraAccount_exists_at($t5);
    if ($abort_flag) {
      goto Abort;
    }

    // $t7 := 0
    $t7 := $Integer(0);

    // $t8 := Errors::not_published($t7)
    call $t8 := $Errors_not_published($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 36272, $abort_code);
      goto Abort;
    }

    // if ($t6) goto L0 else goto L1
    if (b#$Boolean($t6)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t8)
    if (true) { assume $DebugTrackAbort(16, 36225, i#$Integer($t8)); }
    $abort_code := i#$Integer($t8);
    goto Abort;

    // L0:
L0:

    // $t9 := get_field<LibraAccount::KeyRotationCapability>.account_address($t4)
    call $t9 := $GetFieldFromValue($t4, $LibraAccount_KeyRotationCapability_account_address);

    // account := borrow_global<LibraAccount::LibraAccount>($t9)
    call account := $BorrowGlobal($LibraAccount_LibraAccount_$memory, $t9, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 36320, $abort_code);
      goto Abort;
    }

    // unpack_ref(account)
    call $LibraAccount_LibraAccount_$unpack_ref($Dereference(account));

    // $t10 := borrow_field<LibraAccount::LibraAccount>.key_rotation_capability(account)
    call $t10 := $BorrowField(account, $LibraAccount_LibraAccount_key_rotation_capability);

    // unpack_ref($t10)
    call $Option_Option_$unpack_ref($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t10));

    // $t11 := read_ref($t10)
    call $t11 := $ReadRef($t10);
    assert $Option_Option_$invariant_holds($t11);

    // $t11 := Option::fill<LibraAccount::KeyRotationCapability>($t11, $t4)
    call $t11 := $Option_fill($LibraAccount_KeyRotationCapability_type_value(), $t11, $t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 36390, $abort_code);
      goto Abort;
    }

    // write_ref($t10, $t11)
    call $t10 := $WriteRef($t10, $t11);
    if (true) { assume $DebugTrackLocal(16, 36390, 1, $Dereference(account)); }

    // pack_ref($t10)
    call $Option_Option_$pack_ref($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t10));

    // write_back[Reference(account)]($t10)
    call account := $WritebackToReference($t10, account);

    // pack_ref(account)
    call $LibraAccount_LibraAccount_$pack_ref($Dereference(account));

    // write_back[LibraAccount::LibraAccount](account)
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, account);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_restore_key_rotation_capability_$direct_inter(cap: $Value) returns ()
{
    assume $LibraAccount_KeyRotationCapability_$is_well_formed(cap);

    call $LibraAccount_restore_key_rotation_capability_$def(cap);
}


procedure {:inline 1} $LibraAccount_restore_key_rotation_capability_$direct_intra(cap: $Value) returns ()
{
    assume $LibraAccount_KeyRotationCapability_$is_well_formed(cap);

    call $LibraAccount_restore_key_rotation_capability_$def(cap);
}


procedure {:inline 1} $LibraAccount_restore_key_rotation_capability(cap: $Value) returns ()
{
    assume $LibraAccount_KeyRotationCapability_$is_well_formed(cap);

    call $LibraAccount_restore_key_rotation_capability_$def(cap);
}


procedure {:inline 1} $LibraAccount_restore_withdraw_capability_$def(cap: $Value, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool) returns ()
{
    // declare local variables
    var account: $Mutation; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var tmp#$2: $Value; // $BooleanType()
    var tmp#$3: $Value; // $IntegerType()
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $IntegerType()
    var $t6: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $AddressType()
    var $t16: $Mutation; // ReferenceType($Option_Option_type_value($LibraAccount_WithdrawCapability_type_value()))
    var $t17: $Value; // $Option_Option_type_value($LibraAccount_WithdrawCapability_type_value())
    var $LibraAccount_LibraAccount_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 29071, 0, cap); }
    $LibraAccount_LibraAccount_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address($LibraAccount_cap_addr$76(cap)) := true];

    // bytecode translation starts here
    // $t6 := move(cap)
    call $t6 := $CopyOrMoveValue(cap);

    // $t7 := get_field<LibraAccount::WithdrawCapability>.account_address($t6)
    call $t7 := $GetFieldFromValue($t6, $LibraAccount_WithdrawCapability_account_address);

    // $t8 := LibraAccount::exists_at($t7)
    call $t8 := $LibraAccount_exists_at($t7);
    if ($abort_flag) {
      goto Abort;
    }

    // $t9 := 0
    $t9 := $Integer(0);

    // $t10 := Errors::not_published($t9)
    call $t10 := $Errors_not_published($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 29218, $abort_code);
      goto Abort;
    }

    // if ($t8) goto L0 else goto L1
    if (b#$Boolean($t8)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t10)
    if (true) { assume $DebugTrackAbort(16, 29171, i#$Integer($t10)); }
    $abort_code := i#$Integer($t10);
    goto Abort;

    // L0:
L0:

    // $t11 := get_field<LibraAccount::WithdrawCapability>.account_address($t6)
    call $t11 := $GetFieldFromValue($t6, $LibraAccount_WithdrawCapability_account_address);

    // $t12 := LibraAccount::delegated_withdraw_capability($t11)
    call $t12 := $LibraAccount_delegated_withdraw_capability($t11);
    if ($abort_flag) {
      goto Abort;
    }

    // $t13 := 11
    $t13 := $Integer(11);

    // $t14 := Errors::invalid_state($t13)
    call $t14 := $Errors_invalid_state($t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 29489, $abort_code);
      goto Abort;
    }

    // if ($t12) goto L2 else goto L3
    if (b#$Boolean($t12)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t14)
    if (true) { assume $DebugTrackAbort(16, 29397, i#$Integer($t14)); }
    $abort_code := i#$Integer($t14);
    goto Abort;

    // L2:
L2:

    // $t15 := get_field<LibraAccount::WithdrawCapability>.account_address($t6)
    call $t15 := $GetFieldFromValue($t6, $LibraAccount_WithdrawCapability_account_address);

    // account := borrow_global<LibraAccount::LibraAccount>($t15)
    assert $LibraAccount_LibraAccount_$SelfDomain[$EmptyTypeValueArray, a#$Address($t15)];
    call account := $BorrowGlobal($LibraAccount_LibraAccount_$memory, $t15, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 29574, $abort_code);
      goto Abort;
    }

    // unpack_ref(account)
    call $LibraAccount_LibraAccount_$unpack_ref($Dereference(account));

    // $t16 := borrow_field<LibraAccount::LibraAccount>.withdrawal_capability(account)
    call $t16 := $BorrowField(account, $LibraAccount_LibraAccount_withdrawal_capability);

    // unpack_ref($t16)
    call $Option_Option_$unpack_ref($LibraAccount_WithdrawCapability_type_value(), $Dereference($t16));

    // $t17 := read_ref($t16)
    call $t17 := $ReadRef($t16);
    assert $Option_Option_$invariant_holds($t17);

    // $t17 := Option::fill<LibraAccount::WithdrawCapability>($t17, $t6)
    call $t17 := $Option_fill($LibraAccount_WithdrawCapability_type_value(), $t17, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 29644, $abort_code);
      goto Abort;
    }

    // write_ref($t16, $t17)
    call $t16 := $WriteRef($t16, $t17);
    if (true) { assume $DebugTrackLocal(16, 29644, 1, $Dereference(account)); }

    // pack_ref($t16)
    call $Option_Option_$pack_ref($LibraAccount_WithdrawCapability_type_value(), $Dereference($t16));

    // write_back[Reference(account)]($t16)
    call account := $WritebackToReference($t16, account);

    // pack_ref(account)
    call $LibraAccount_LibraAccount_$pack_ref($Dereference(account));

    // write_back[LibraAccount::LibraAccount](account)
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, account);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_restore_withdraw_capability_$direct_inter(cap: $Value, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraAccount_LibraAccount_$CallerDomain[$EmptyTypeValueArray, a#$Address($LibraAccount_cap_addr$76(cap))];
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap)))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap)))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap)))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($LibraAccount_spec_holds_own_withdraw_cap($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap))));
modifies $LibraAccount_LibraAccount_$memory;
ensures contents#$Memory($LibraAccount_LibraAccount_$memory) == old(contents#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_cap_addr$76(cap)) := contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_cap_addr$76(cap))]];
ensures domain#$Memory($LibraAccount_LibraAccount_$memory) == old(domain#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_cap_addr$76(cap)) := domain#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_cap_addr$76(cap))]];

procedure {:inline 1} $LibraAccount_restore_withdraw_capability_$direct_intra(cap: $Value, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraAccount_LibraAccount_$CallerDomain[$EmptyTypeValueArray, a#$Address($LibraAccount_cap_addr$76(cap))];
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap)))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap)))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap)))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($LibraAccount_spec_holds_own_withdraw_cap($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1)))) || b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_key_rotation_cap($LibraAccount_LibraAccount_$memory, addr1))))))) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1)))) || b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_key_rotation_cap($LibraAccount_LibraAccount_$memory, addr1))))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1), $LibraAccount_LibraAccount_authentication_key), old($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1), $LibraAccount_LibraAccount_authentication_key)))))))))));
modifies $LibraAccount_LibraAccount_$memory;
ensures contents#$Memory($LibraAccount_LibraAccount_$memory) == old(contents#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_cap_addr$76(cap)) := contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_cap_addr$76(cap))]];
ensures domain#$Memory($LibraAccount_LibraAccount_$memory) == old(domain#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_cap_addr$76(cap)) := domain#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_cap_addr$76(cap))]];

procedure {:inline 1} $LibraAccount_restore_withdraw_capability(cap: $Value, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool) returns ()
;
modifies $abort_flag, $abort_code;
requires $LibraAccount_LibraAccount_$CallerDomain[$EmptyTypeValueArray, a#$Address($LibraAccount_cap_addr$76(cap))];
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap)))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap))))))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap)))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap)))))) &&
       $abort_code == i#$Integer($Integer(1))));
ensures !$abort_flag ==> (b#$Boolean($LibraAccount_spec_holds_own_withdraw_cap($LibraAccount_LibraAccount_$memory, $LibraAccount_cap_addr$76(cap))));
modifies $LibraAccount_LibraAccount_$memory;
ensures contents#$Memory($LibraAccount_LibraAccount_$memory) == old(contents#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_cap_addr$76(cap)) := contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_cap_addr$76(cap))]];
ensures domain#$Memory($LibraAccount_LibraAccount_$memory) == old(domain#$Memory($LibraAccount_LibraAccount_$memory))[$EmptyTypeValueArray, a#$Address($LibraAccount_cap_addr$76(cap)) := domain#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, a#$Address($LibraAccount_cap_addr$76(cap))]];

procedure {:inline 1} $LibraAccount_rotate_authentication_key_$def(cap: $Value, new_authentication_key: $Value) returns ()
{
    // declare local variables
    var sender_account_resource: $Mutation; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $IntegerType()
    var tmp#$5: $Value; // $BooleanType()
    var tmp#$6: $Value; // $IntegerType()
    var $t7: $Value; // $LibraAccount_KeyRotationCapability_type_value()
    var $t8: $Value; // $Vector_type_value($IntegerType())
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Mutation; // ReferenceType($Vector_type_value($IntegerType()))

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 32866, 0, cap); }
    if (true) { assume $DebugTrackLocal(16, 32866, 1, new_authentication_key); }

    // bytecode translation starts here
    // $t7 := move(cap)
    call $t7 := $CopyOrMoveValue(cap);

    // $t8 := move(new_authentication_key)
    call $t8 := $CopyOrMoveValue(new_authentication_key);

    // $t9 := get_field<LibraAccount::KeyRotationCapability>.account_address($t7)
    call $t9 := $GetFieldFromValue($t7, $LibraAccount_KeyRotationCapability_account_address);

    // $t10 := LibraAccount::exists_at($t9)
    call $t10 := $LibraAccount_exists_at($t9);
    if ($abort_flag) {
      goto Abort;
    }

    // $t11 := 0
    $t11 := $Integer(0);

    // $t12 := Errors::not_published($t11)
    call $t12 := $Errors_not_published($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 33071, $abort_code);
      goto Abort;
    }

    // if ($t10) goto L0 else goto L1
    if (b#$Boolean($t10)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t7)

    // abort($t12)
    if (true) { assume $DebugTrackAbort(16, 33024, i#$Integer($t12)); }
    $abort_code := i#$Integer($t12);
    goto Abort;

    // L0:
L0:

    // $t13 := get_field<LibraAccount::KeyRotationCapability>.account_address($t7)
    call $t13 := $GetFieldFromValue($t7, $LibraAccount_KeyRotationCapability_account_address);

    // sender_account_resource := borrow_global<LibraAccount::LibraAccount>($t13)
    call sender_account_resource := $BorrowGlobal($LibraAccount_LibraAccount_$memory, $t13, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 33135, $abort_code);
      goto Abort;
    }

    // unpack_ref(sender_account_resource)
    call $LibraAccount_LibraAccount_$unpack_ref($Dereference(sender_account_resource));

    // $t14 := Vector::length<u8>($t8)
    call $t14 := $Vector_length($IntegerType(), $t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 33280, $abort_code);
      goto Abort;
    }

    // $t15 := 32
    $t15 := $Integer(32);

    // $t16 := ==($t14, $t15)
    $t16 := $Boolean($IsEqual($t14, $t15));

    // $t17 := 8
    $t17 := $Integer(8);

    // $t18 := Errors::invalid_argument($t17)
    call $t18 := $Errors_invalid_argument($t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 33339, $abort_code);
      goto Abort;
    }

    // if ($t16) goto L2 else goto L3
    if (b#$Boolean($t16)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // destroy(sender_account_resource)

    // pack_ref(sender_account_resource)
    call $LibraAccount_LibraAccount_$pack_ref($Dereference(sender_account_resource));

    // abort($t18)
    if (true) { assume $DebugTrackAbort(16, 33252, i#$Integer($t18)); }
    $abort_code := i#$Integer($t18);
    goto Abort;

    // L2:
L2:

    // $t19 := borrow_field<LibraAccount::LibraAccount>.authentication_key(sender_account_resource)
    call $t19 := $BorrowField(sender_account_resource, $LibraAccount_LibraAccount_authentication_key);

    // unpack_ref($t19)

    // write_ref($t19, $t8)
    call $t19 := $WriteRef($t19, $t8);
    if (true) { assume $DebugTrackLocal(16, 33406, 2, $Dereference(sender_account_resource)); }

    // pack_ref($t19)

    // write_back[Reference(sender_account_resource)]($t19)
    call sender_account_resource := $WritebackToReference($t19, sender_account_resource);

    // pack_ref(sender_account_resource)
    call $LibraAccount_LibraAccount_$pack_ref($Dereference(sender_account_resource));

    // write_back[LibraAccount::LibraAccount](sender_account_resource)
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, sender_account_resource);

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_rotate_authentication_key_$direct_inter(cap: $Value, new_authentication_key: $Value) returns ()
{
    assume $LibraAccount_KeyRotationCapability_$is_well_formed(cap);

    assume $Vector_$is_well_formed(new_authentication_key) && (forall $$0: int :: {$select_vector(new_authentication_key,$$0)} $$0 >= 0 && $$0 < $vlen(new_authentication_key) ==> $IsValidU8($select_vector(new_authentication_key,$$0)));

    call $LibraAccount_rotate_authentication_key_$def(cap, new_authentication_key);
}


procedure {:inline 1} $LibraAccount_rotate_authentication_key_$direct_intra(cap: $Value, new_authentication_key: $Value) returns ()
{
    assume $LibraAccount_KeyRotationCapability_$is_well_formed(cap);

    assume $Vector_$is_well_formed(new_authentication_key) && (forall $$0: int :: {$select_vector(new_authentication_key,$$0)} $$0 >= 0 && $$0 < $vlen(new_authentication_key) ==> $IsValidU8($select_vector(new_authentication_key,$$0)));

    call $LibraAccount_rotate_authentication_key_$def(cap, new_authentication_key);
}


procedure {:inline 1} $LibraAccount_rotate_authentication_key(cap: $Value, new_authentication_key: $Value) returns ()
{
    assume $LibraAccount_KeyRotationCapability_$is_well_formed(cap);

    assume $Vector_$is_well_formed(new_authentication_key) && (forall $$0: int :: {$select_vector(new_authentication_key,$$0)} $$0 >= 0 && $$0 < $vlen(new_authentication_key) ==> $IsValidU8($select_vector(new_authentication_key,$$0)));

    call $LibraAccount_rotate_authentication_key_$def(cap, new_authentication_key);
}


procedure {:inline 1} $LibraAccount_script_prologue_$def($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time: $Value, chain_id: $Value, script_hash: $Value) returns ()
{
    // declare local variables
    var tmp#$8: $Value; // $BooleanType()
    var tmp#$9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $Vector_type_value($IntegerType())
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $Vector_type_value($IntegerType())
    var $t18: $Value; // $BooleanType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 60355, 0, sender); }
    if (true) { assume $DebugTrackLocal(16, 60355, 1, txn_sequence_number); }
    if (true) { assume $DebugTrackLocal(16, 60355, 2, txn_public_key); }
    if (true) { assume $DebugTrackLocal(16, 60355, 3, txn_gas_price); }
    if (true) { assume $DebugTrackLocal(16, 60355, 4, txn_max_gas_units); }
    if (true) { assume $DebugTrackLocal(16, 60355, 5, txn_expiration_time); }
    if (true) { assume $DebugTrackLocal(16, 60355, 6, chain_id); }
    if (true) { assume $DebugTrackLocal(16, 60355, 7, script_hash); }

    // bytecode translation starts here
    // $t10 := move(sender)
    call $t10 := $CopyOrMoveValue(sender);

    // $t11 := move(txn_sequence_number)
    call $t11 := $CopyOrMoveValue(txn_sequence_number);

    // $t12 := move(txn_public_key)
    call $t12 := $CopyOrMoveValue(txn_public_key);

    // $t13 := move(txn_gas_price)
    call $t13 := $CopyOrMoveValue(txn_gas_price);

    // $t14 := move(txn_max_gas_units)
    call $t14 := $CopyOrMoveValue(txn_max_gas_units);

    // $t15 := move(txn_expiration_time)
    call $t15 := $CopyOrMoveValue(txn_expiration_time);

    // $t16 := move(chain_id)
    call $t16 := $CopyOrMoveValue(chain_id);

    // $t17 := move(script_hash)
    call $t17 := $CopyOrMoveValue(script_hash);

    // $t18 := LibraTransactionPublishingOption::is_script_allowed($t10, $t17)
    call $t18 := $LibraTransactionPublishingOption_is_script_allowed($t10, $t17);
    if ($abort_flag) {
      goto Abort;
    }

    // $t19 := 1008
    $t19 := $Integer(1008);

    // $t20 := Errors::invalid_state($t19)
    call $t20 := $Errors_invalid_state($t19);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 60789, $abort_code);
      goto Abort;
    }

    // if ($t18) goto L0 else goto L1
    if (b#$Boolean($t18)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t10)

    // abort($t20)
    if (true) { assume $DebugTrackAbort(16, 60674, i#$Integer($t20)); }
    $abort_code := i#$Integer($t20);
    goto Abort;

    // L0:
L0:

    // LibraAccount::prologue_common<#0>($t10, $t11, $t12, $t13, $t14, $t15, $t16)
    call $LibraAccount_prologue_common($tv0, $t10, $t11, $t12, $t13, $t14, $t15, $t16);
    if ($abort_flag) {
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_script_prologue_$direct_intra($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time: $Value, chain_id: $Value, script_hash: $Value) returns ()
{
    assume is#$Address(sender);

    assume $IsValidU64(txn_sequence_number);

    assume $Vector_$is_well_formed(txn_public_key) && (forall $$0: int :: {$select_vector(txn_public_key,$$0)} $$0 >= 0 && $$0 < $vlen(txn_public_key) ==> $IsValidU8($select_vector(txn_public_key,$$0)));

    assume $IsValidU64(txn_gas_price);

    assume $IsValidU64(txn_max_gas_units);

    assume $IsValidU64(txn_expiration_time);

    assume $IsValidU8(chain_id);

    assume $Vector_$is_well_formed(script_hash) && (forall $$0: int :: {$select_vector(script_hash,$$0)} $$0 >= 0 && $$0 < $vlen(script_hash) ==> $IsValidU8($select_vector(script_hash,$$0)));

    call $LibraAccount_script_prologue_$def($tv0, sender, txn_sequence_number, txn_public_key, txn_gas_price, txn_max_gas_units, txn_expiration_time, chain_id, script_hash);
}


procedure {:inline 1} $LibraAccount_script_prologue($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time: $Value, chain_id: $Value, script_hash: $Value) returns ()
{
    assume is#$Address(sender);

    assume $IsValidU64(txn_sequence_number);

    assume $Vector_$is_well_formed(txn_public_key) && (forall $$0: int :: {$select_vector(txn_public_key,$$0)} $$0 >= 0 && $$0 < $vlen(txn_public_key) ==> $IsValidU8($select_vector(txn_public_key,$$0)));

    assume $IsValidU64(txn_gas_price);

    assume $IsValidU64(txn_max_gas_units);

    assume $IsValidU64(txn_expiration_time);

    assume $IsValidU8(chain_id);

    assume $Vector_$is_well_formed(script_hash) && (forall $$0: int :: {$select_vector(script_hash,$$0)} $$0 >= 0 && $$0 < $vlen(script_hash) ==> $IsValidU8($select_vector(script_hash,$$0)));

    call $LibraAccount_script_prologue_$def($tv0, sender, txn_sequence_number, txn_public_key, txn_gas_price, txn_max_gas_units, txn_expiration_time, chain_id, script_hash);
}


procedure {:inline 1} $LibraAccount_sequence_number_$def(addr: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$1: $Value; // $BooleanType()
    var tmp#$2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $LibraAccount_LibraAccount_type_value()
    var $t8: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 56276, 0, addr); }

    // bytecode translation starts here
    // $t3 := move(addr)
    call $t3 := $CopyOrMoveValue(addr);

    // $t4 := LibraAccount::exists_at($t3)
    call $t4 := $LibraAccount_exists_at($t3);
    if ($abort_flag) {
      goto Abort;
    }

    // $t5 := 0
    $t5 := $Integer(0);

    // $t6 := Errors::not_published($t5)
    call $t6 := $Errors_not_published($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 56387, $abort_code);
      goto Abort;
    }

    // if ($t4) goto L0 else goto L1
    if (b#$Boolean($t4)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t6)
    if (true) { assume $DebugTrackAbort(16, 56355, i#$Integer($t6)); }
    $abort_code := i#$Integer($t6);
    goto Abort;

    // L0:
L0:

    // $t7 := get_global<LibraAccount::LibraAccount>($t3)
    call $t7 := $GetGlobal($LibraAccount_LibraAccount_$memory, $t3, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 56449, $abort_code);
      goto Abort;
    }

    // $t8 := LibraAccount::sequence_number_for_account($t7)
    call $t8 := $LibraAccount_sequence_number_for_account($t7);
    if ($abort_flag) {
      goto Abort;
    }

    // return $t8
    $ret0 := $t8;
    if (true) { assume $DebugTrackLocal(16, 56421, 9, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraAccount_sequence_number_$direct_inter(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $LibraAccount_sequence_number_$def(addr);
}


procedure {:inline 1} $LibraAccount_sequence_number_$direct_intra(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $LibraAccount_sequence_number_$def(addr);
}


procedure {:inline 1} $LibraAccount_sequence_number(addr: $Value) returns ($ret0: $Value)
{
    assume is#$Address(addr);

    call $ret0 := $LibraAccount_sequence_number_$def(addr);
}


procedure {:inline 1} $LibraAccount_sequence_number_for_account_$def(account: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $LibraAccount_LibraAccount_type_value()
    var $t2: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 56117, 0, account); }

    // bytecode translation starts here
    // $t1 := move(account)
    call $t1 := $CopyOrMoveValue(account);

    // $t2 := get_field<LibraAccount::LibraAccount>.sequence_number($t1)
    call $t2 := $GetFieldFromValue($t1, $LibraAccount_LibraAccount_sequence_number);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(16, 56188, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraAccount_sequence_number_for_account_$direct_intra(account: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_LibraAccount_$is_well_formed(account);

    call $ret0 := $LibraAccount_sequence_number_for_account_$def(account);
}


procedure {:inline 1} $LibraAccount_sequence_number_for_account(account: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_LibraAccount_$is_well_formed(account);

    call $ret0 := $LibraAccount_sequence_number_for_account_$def(account);
}


procedure {:inline 1} $LibraAccount_should_track_limits_for_account_$def($tv0: $TypeValue, payer: $Value, payee: $Value, is_withdrawal: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var tmp#$3: $Value; // $BooleanType()
    var tmp#$4: $Value; // $BooleanType()
    var tmp#$5: $Value; // $BooleanType()
    var tmp#$6: $Value; // $BooleanType()
    var tmp#$7: $Value; // $BooleanType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $BooleanType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 10262, 0, payer); }
    if (true) { assume $DebugTrackLocal(16, 10262, 1, payee); }
    if (true) { assume $DebugTrackLocal(16, 10262, 2, is_withdrawal); }

    // bytecode translation starts here
    // $t8 := move(payer)
    call $t8 := $CopyOrMoveValue(payer);

    // $t9 := move(payee)
    call $t9 := $CopyOrMoveValue(payee);

    // $t10 := move(is_withdrawal)
    call $t10 := $CopyOrMoveValue(is_withdrawal);

    // if ($t10) goto L0 else goto L1
    if (b#$Boolean($t10)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t11 := LibraAccount::has_published_account_limits<#0>($t8)
    call $t11 := $LibraAccount_has_published_account_limits($tv0, $t8);
    if ($abort_flag) {
      goto Abort;
    }

    // if ($t11) goto L3 else goto L4
    if (b#$Boolean($t11)) { goto L3; } else { goto L4; }

    // L4:
L4:

    // goto L5
    goto L5;

    // L3:
L3:

    // tmp#$3 := VASP::is_vasp($t8)
    call tmp#$3 := $VASP_is_vasp($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 10485, $abort_code);
      goto Abort;
    }

    // goto L6
    goto L6;

    // L5:
L5:

    // $t12 := false
    $t12 := $Boolean(false);

    // tmp#$3 := $t12
    call tmp#$3 := $CopyOrMoveValue($t12);
    if (true) { assume $DebugTrackLocal(16, 10421, 3, tmp#$3); }

    // goto L6
    goto L6;

    // L6:
L6:

    // if (tmp#$3) goto L7 else goto L8
    if (b#$Boolean(tmp#$3)) { goto L7; } else { goto L8; }

    // L8:
L8:

    // goto L9
    goto L9;

    // L7:
L7:

    // $t13 := VASP::is_same_vasp($t8, $t9)
    call $t13 := $VASP_is_same_vasp($t8, $t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 10522, $abort_code);
      goto Abort;
    }

    // tmp#$4 := !($t13)
    call tmp#$4 := $Not($t13);
    if (true) { assume $DebugTrackLocal(16, 10515, 4, tmp#$4); }

    // goto L10
    goto L10;

    // L9:
L9:

    // $t14 := false
    $t14 := $Boolean(false);

    // tmp#$4 := $t14
    call tmp#$4 := $CopyOrMoveValue($t14);
    if (true) { assume $DebugTrackLocal(16, 10421, 4, tmp#$4); }

    // goto L10
    goto L10;

    // L10:
L10:

    // tmp#$7 := tmp#$4
    call tmp#$7 := $CopyOrMoveValue(tmp#$4);
    if (true) { assume $DebugTrackLocal(16, 10388, 7, tmp#$7); }

    // goto L11
    goto L11;

    // L2:
L2:

    // $t15 := LibraAccount::has_published_account_limits<#0>($t9)
    call $t15 := $LibraAccount_has_published_account_limits($tv0, $t9);
    if ($abort_flag) {
      goto Abort;
    }

    // if ($t15) goto L12 else goto L13
    if (b#$Boolean($t15)) { goto L12; } else { goto L13; }

    // L13:
L13:

    // goto L14
    goto L14;

    // L12:
L12:

    // tmp#$5 := VASP::is_vasp($t9)
    call tmp#$5 := $VASP_is_vasp($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 10642, $abort_code);
      goto Abort;
    }

    // goto L15
    goto L15;

    // L14:
L14:

    // $t16 := false
    $t16 := $Boolean(false);

    // tmp#$5 := $t16
    call tmp#$5 := $CopyOrMoveValue($t16);
    if (true) { assume $DebugTrackLocal(16, 10578, 5, tmp#$5); }

    // goto L15
    goto L15;

    // L15:
L15:

    // if (tmp#$5) goto L16 else goto L17
    if (b#$Boolean(tmp#$5)) { goto L16; } else { goto L17; }

    // L17:
L17:

    // goto L18
    goto L18;

    // L16:
L16:

    // $t17 := VASP::is_same_vasp($t9, $t8)
    call $t17 := $VASP_is_same_vasp($t9, $t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 10679, $abort_code);
      goto Abort;
    }

    // tmp#$6 := !($t17)
    call tmp#$6 := $Not($t17);
    if (true) { assume $DebugTrackLocal(16, 10672, 6, tmp#$6); }

    // goto L19
    goto L19;

    // L18:
L18:

    // $t18 := false
    $t18 := $Boolean(false);

    // tmp#$6 := $t18
    call tmp#$6 := $CopyOrMoveValue($t18);
    if (true) { assume $DebugTrackLocal(16, 10578, 6, tmp#$6); }

    // goto L19
    goto L19;

    // L19:
L19:

    // tmp#$7 := tmp#$6
    call tmp#$7 := $CopyOrMoveValue(tmp#$6);
    if (true) { assume $DebugTrackLocal(16, 10388, 7, tmp#$7); }

    // goto L11
    goto L11;

    // L11:
L11:

    // return tmp#$7
    $ret0 := tmp#$7;
    if (true) { assume $DebugTrackLocal(16, 10388, 19, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraAccount_should_track_limits_for_account_$direct_intra($tv0: $TypeValue, payer: $Value, payee: $Value, is_withdrawal: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, is_withdrawal)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, addr1))) ==> b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1), $LibraAccount_LibraAccount_authentication_key), old($SelectField($ResourceValue($LibraAccount_LibraAccount_$memory, $EmptyTypeValueArray, addr1), $LibraAccount_LibraAccount_authentication_key)))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr1))) ==> b#$Boolean($Boolean(i#$Integer($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr1), $LibraAccount_Balance_coin), $Libra_Libra_value)) >= i#$Integer(old($SelectField($SelectField($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr1), $LibraAccount_Balance_coin), $Libra_Libra_value)))))))))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $LibraAccount_should_track_limits_for_account($tv0: $TypeValue, payer: $Value, payee: $Value, is_withdrawal: $Value) returns ($ret0: $Value)
;
modifies $abort_flag, $abort_code;
ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(false))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $LibraAccount_spec_should_track_limits_for_account($AccountLimits_Window_$memory, $VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, $tv0, payer, payee, is_withdrawal)))));
ensures is#$Boolean($ret0);

procedure {:inline 1} $LibraAccount_withdraw_capability_address_$def(cap: $Value) returns ($ret0: $Value)
{
    // declare local variables
    var $t1: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t2: $Value; // $AddressType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 57533, 0, cap); }

    // bytecode translation starts here
    // $t1 := move(cap)
    call $t1 := $CopyOrMoveValue(cap);

    // $t2 := get_field<LibraAccount::WithdrawCapability>.account_address($t1)
    call $t2 := $GetFieldFromValue($t1, $LibraAccount_WithdrawCapability_account_address);

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(16, 57618, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraAccount_withdraw_capability_address_$direct_inter(cap: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_WithdrawCapability_$is_well_formed(cap);

    call $ret0 := $LibraAccount_withdraw_capability_address_$def(cap);
}


procedure {:inline 1} $LibraAccount_withdraw_capability_address_$direct_intra(cap: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_WithdrawCapability_$is_well_formed(cap);

    call $ret0 := $LibraAccount_withdraw_capability_address_$def(cap);
}


procedure {:inline 1} $LibraAccount_withdraw_capability_address(cap: $Value) returns ($ret0: $Value)
{
    assume $LibraAccount_WithdrawCapability_$is_well_formed(cap);

    call $ret0 := $LibraAccount_withdraw_capability_address_$def(cap);
}


procedure {:inline 1} $LibraAccount_withdraw_from_$def($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool, $LibraAccount_Balance_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
{
    // declare local variables
    var account_balance: $Mutation; // ReferenceType($LibraAccount_Balance_type_value($tv0))
    var payer: $Value; // $AddressType()
    var tmp#$6: $Value; // $BooleanType()
    var tmp#$7: $Value; // $IntegerType()
    var tmp#$8: $Value; // $BooleanType()
    var tmp#$9: $Value; // $IntegerType()
    var $t10: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $Vector_type_value($IntegerType())
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $BooleanType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Mutation; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t22: $Mutation; // ReferenceType($Event_EventHandle_type_value($LibraAccount_SentPaymentEvent_type_value()))
    var $t23: $Value; // $Vector_type_value($IntegerType())
    var $t24: $Value; // $LibraAccount_SentPaymentEvent_type_value()
    var $t25: $Value; // $Event_EventHandle_type_value($LibraAccount_SentPaymentEvent_type_value())
    var $t26: $Value; // $LibraAccount_Balance_type_value($tv0)
    var $t27: $Value; // $Libra_Libra_type_value($tv0)
    var $LibraAccount_LibraAccount_$SelfDomain: [$TypeValueArray, int]bool;
    var $LibraAccount_Balance_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 23270, 0, cap); }
    if (true) { assume $DebugTrackLocal(16, 23270, 1, payee); }
    if (true) { assume $DebugTrackLocal(16, 23270, 2, amount); }
    if (true) { assume $DebugTrackLocal(16, 23270, 3, metadata); }
    $LibraAccount_LibraAccount_$SelfDomain := $ConstMemoryDomain(false)[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$72($tv0, cap)) := true];
    $LibraAccount_Balance_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($LibraAccount_payer$72($tv0, cap)) := true];

    // bytecode translation starts here
    // $t10 := move(cap)
    call $t10 := $CopyOrMoveValue(cap);

    // $t11 := move(payee)
    call $t11 := $CopyOrMoveValue(payee);

    // $t12 := move(amount)
    call $t12 := $CopyOrMoveValue(amount);

    // $t13 := move(metadata)
    call $t13 := $CopyOrMoveValue(metadata);

    // LibraTimestamp::assert_operating()
    call $LibraTimestamp_assert_operating();
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 23511, $abort_code);
      goto Abort;
    }

    // $t14 := get_field<LibraAccount::WithdrawCapability>.account_address($t10)
    call $t14 := $GetFieldFromValue($t10, $LibraAccount_WithdrawCapability_account_address);

    // payer := $t14
    call payer := $CopyOrMoveValue($t14);
    if (true) { assume $DebugTrackLocal(16, 23543, 5, payer); }

    // $t15 := LibraAccount::exists_at(payer)
    call $t15 := $LibraAccount_exists_at(payer);
    if ($abort_flag) {
      goto Abort;
    }

    // $t16 := 0
    $t16 := $Integer(0);

    // $t17 := Errors::not_published($t16)
    call $t17 := $Errors_not_published($t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 23613, $abort_code);
      goto Abort;
    }

    // if ($t15) goto L0 else goto L1
    if (b#$Boolean($t15)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t17)
    if (true) { assume $DebugTrackAbort(16, 23580, i#$Integer($t17)); }
    $abort_code := i#$Integer($t17);
    goto Abort;

    // L0:
L0:

    // $t18 := exists<LibraAccount::Balance<#0>>(payer)
    $t18 := $ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), payer);

    // $t19 := 19
    $t19 := $Integer(19);

    // $t20 := Errors::not_published($t19)
    call $t20 := $Errors_not_published($t19);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 23693, $abort_code);
      goto Abort;
    }

    // if ($t18) goto L2 else goto L3
    if (b#$Boolean($t18)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // abort($t20)
    if (true) { assume $DebugTrackAbort(16, 23647, i#$Integer($t20)); }
    $abort_code := i#$Integer($t20);
    goto Abort;

    // L2:
L2:

    // account_balance := borrow_global<LibraAccount::Balance<#0>>(payer)
    assert $LibraAccount_Balance_$SelfDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address(payer)];
    call account_balance := $BorrowGlobal($LibraAccount_Balance_$memory, payer, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1));
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 23768, $abort_code);
      goto Abort;
    }

    // unpack_ref(account_balance)

    // $t21 := borrow_global<LibraAccount::LibraAccount>(payer)
    assert $LibraAccount_LibraAccount_$SelfDomain[$EmptyTypeValueArray, a#$Address(payer)];
    call $t21 := $BorrowGlobal($LibraAccount_LibraAccount_$memory, payer, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 23951, $abort_code);
      goto Abort;
    }

    // unpack_ref($t21)
    call $LibraAccount_LibraAccount_$unpack_ref($Dereference($t21));

    // $t22 := borrow_field<LibraAccount::LibraAccount>.sent_events($t21)
    call $t22 := $BorrowField($t21, $LibraAccount_LibraAccount_sent_events);

    // unpack_ref($t22)

    // $t23 := Libra::currency_code<#0>()
    call $t23 := $Libra_currency_code($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 24096, $abort_code);
      goto Abort;
    }

    // $t24 := pack LibraAccount::SentPaymentEvent($t12, $t23, $t11, $t13)
    call $t24 := $LibraAccount_SentPaymentEvent_pack(0, 0, 0, $t12, $t23, $t11, $t13);

    // $t25 := read_ref($t22)
    call $t25 := $ReadRef($t22);
    assert $Event_EventHandle_$invariant_holds($t25);

    // $t25 := Event::emit_event<LibraAccount::SentPaymentEvent>($t25, $t24)
    call $t25 := $Event_emit_event($LibraAccount_SentPaymentEvent_type_value(), $t25, $t24);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 23904, $abort_code);
      goto Abort;
    }

    // write_ref($t22, $t25)
    call $t22 := $WriteRef($t22, $t25);
    if (true) { assume $DebugTrackLocal(16, 23904, 4, $Dereference(account_balance)); }

    // pack_ref($t22)

    // write_back[Reference($t21)]($t22)
    call $t21 := $WritebackToReference($t22, $t21);

    // pack_ref($t21)
    call $LibraAccount_LibraAccount_$pack_ref($Dereference($t21));

    // write_back[LibraAccount::LibraAccount]($t21)
    call $LibraAccount_LibraAccount_$memory := $WritebackToGlobal($LibraAccount_LibraAccount_$memory, $t21);

    // $t26 := read_ref(account_balance)
    call $t26 := $ReadRef(account_balance);
    assert $LibraAccount_Balance_$invariant_holds($t26);

    // ($t27, $t26) := LibraAccount::withdraw_from_balance<#0>(payer, $t11, $t26, $t12)
    call $t27, $t26 := $LibraAccount_withdraw_from_balance($tv0, payer, $t11, $t26, $t12, $ConstMemoryDomain(true));
    if ($abort_flag) {
      goto Abort;
    }

    // write_ref(account_balance, $t26)
    call account_balance := $WriteRef(account_balance, $t26);
    if (true) { assume $DebugTrackLocal(16, 20395, 4, $Dereference(account_balance)); }

    // pack_ref(account_balance)

    // write_back[LibraAccount::Balance](account_balance)
    call $LibraAccount_Balance_$memory := $WritebackToGlobal($LibraAccount_Balance_$memory, account_balance);

    // return $t27
    $ret0 := $t27;
    if (true) { assume $DebugTrackLocal(16, 24202, 28, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
}

procedure {:inline 1} $LibraAccount_withdraw_from_$direct_intra($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool, $LibraAccount_Balance_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
requires $LibraAccount_LibraAccount_$CallerDomain[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$72($tv0, cap))];
requires $LibraAccount_Balance_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($LibraAccount_payer$72($tv0, cap))];
{
    assume $LibraAccount_WithdrawCapability_$is_well_formed(cap);

    assume is#$Address(payee);

    assume $IsValidU64(amount);

    assume $Vector_$is_well_formed(metadata) && (forall $$0: int :: {$select_vector(metadata,$$0)} $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata,$$0)));

    call $ret0 := $LibraAccount_withdraw_from_$def($tv0, cap, payee, amount, metadata, $LibraAccount_LibraAccount_$CallerDomain, $LibraAccount_Balance_$CallerDomain);
}


procedure {:inline 1} $LibraAccount_withdraw_from($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, $LibraAccount_LibraAccount_$CallerDomain: [$TypeValueArray, int]bool, $LibraAccount_Balance_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value)
requires $LibraAccount_LibraAccount_$CallerDomain[$EmptyTypeValueArray, a#$Address($LibraAccount_payer$72($tv0, cap))];
requires $LibraAccount_Balance_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($LibraAccount_payer$72($tv0, cap))];
{
    assume $LibraAccount_WithdrawCapability_$is_well_formed(cap);

    assume is#$Address(payee);

    assume $IsValidU64(amount);

    assume $Vector_$is_well_formed(metadata) && (forall $$0: int :: {$select_vector(metadata,$$0)} $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata,$$0)));

    call $ret0 := $LibraAccount_withdraw_from_$def($tv0, cap, payee, amount, metadata, $LibraAccount_LibraAccount_$CallerDomain, $LibraAccount_Balance_$CallerDomain);
}


procedure {:inline 1} $LibraAccount_withdraw_from_balance_$def($tv0: $TypeValue, payer: $Value, payee: $Value, balance: $Value, amount: $Value, $AccountLimits_Window_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value, $ret1: $Value)
{
    // declare local variables
    var can_withdraw: $Value; // $BooleanType()
    var coin: $Mutation; // ReferenceType($Libra_Libra_type_value($tv0))
    var tmp#$6: $Value; // $BooleanType()
    var tmp#$7: $Value; // $IntegerType()
    var tmp#$8: $Value; // $BooleanType()
    var tmp#$9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $LibraAccount_Balance_type_value($tv0)
    var $t13: $Value; // $IntegerType()
    var $t14: $Mutation; // ReferenceType($LibraAccount_Balance_type_value($tv0))
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $LibraAccount_AccountOperationsCapability_type_value()
    var $t20: $Value; // $AccountLimits_AccountLimitMutationCapability_type_value()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $Libra_Libra_type_value($tv0)
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $BooleanType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $Libra_Libra_type_value($tv0)
    var $t29: $Value; // $Libra_Libra_type_value($tv0)
    var $AccountLimits_Window_$SelfDomain: [$TypeValueArray, int]bool;

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 20391, 0, payer); }
    if (true) { assume $DebugTrackLocal(16, 20391, 1, payee); }
    if (true) { assume $DebugTrackLocal(16, 20391, 2, balance); }
    if (true) { assume $DebugTrackLocal(16, 20391, 3, amount); }
    $AccountLimits_Window_$SelfDomain := $ConstMemoryDomain(false)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer)) := true];

    // bytecode translation starts here
    // $t10 := move(payer)
    call $t10 := $CopyOrMoveValue(payer);

    // $t11 := move(payee)
    call $t11 := $CopyOrMoveValue(payee);

    // $t12 := move(balance)
    call $t12 := $CopyOrMoveValue(balance);

    // $t13 := move(amount)
    call $t13 := $CopyOrMoveValue(amount);

    // $t14 := borrow_local($t12)
    call $t14 := $BorrowLoc(12, $t12);

    // LibraTimestamp::assert_operating()
    call $LibraTimestamp_assert_operating();
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 20614, $abort_code);
      goto Abort;
    }

    // AccountFreezing::assert_not_frozen($t10)
    call $AccountFreezing_assert_not_frozen($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 20659, $abort_code);
      goto Abort;
    }

    // $t15 := true
    $t15 := $Boolean(true);

    // $t16 := LibraAccount::should_track_limits_for_account<#0>($t10, $t11, $t15)
    call $t16 := $LibraAccount_should_track_limits_for_account($tv0, $t10, $t11, $t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 10266, $abort_code);
      goto Abort;
    }

    // if ($t16) goto L0 else goto L1
    if (b#$Boolean($t16)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t17 := VASP::parent_address($t10)
    call $t17 := $VASP_parent_address($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 21020, $abort_code);
      goto Abort;
    }

    // $t18 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t18 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t19 := get_global<LibraAccount::AccountOperationsCapability>($t18)
    call $t19 := $GetGlobal($LibraAccount_AccountOperationsCapability_$memory, $t18, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 21064, $abort_code);
      goto Abort;
    }

    // $t20 := get_field<LibraAccount::AccountOperationsCapability>.limits_cap($t19)
    call $t20 := $GetFieldFromValue($t19, $LibraAccount_AccountOperationsCapability_limits_cap);

    // can_withdraw := AccountLimits::update_withdrawal_limits<#0>($t13, $t17, $t20)
    call can_withdraw := $AccountLimits_update_withdrawal_limits($tv0, $t13, $t17, $t20, $AccountLimits_Window_$SelfDomain);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 20933, $abort_code);
      goto Abort;
    }

    // $t21 := 6
    $t21 := $Integer(6);

    // $t22 := Errors::limit_exceeded($t21)
    call $t22 := $Errors_limit_exceeded($t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 21211, $abort_code);
      goto Abort;
    }

    // if (can_withdraw) goto L2 else goto L3
    if (b#$Boolean(can_withdraw)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // destroy($t14)

    // abort($t22)
    if (true) { assume $DebugTrackAbort(16, 21182, i#$Integer($t22)); }
    $abort_code := i#$Integer($t22);
    goto Abort;

    // L2:
L2:

    // coin := borrow_field<LibraAccount::Balance<#0>>.coin($t14)
    call coin := $BorrowField($t14, $LibraAccount_Balance_coin);

    // $t23 := read_ref(coin)
    call $t23 := $ReadRef(coin);
    assert $Libra_Libra_$invariant_holds($t23);

    // $t24 := Libra::value<#0>($t23)
    call $t24 := $Libra_value($tv0, $t23);
    if ($abort_flag) {
      goto Abort;
    }

    // $t25 := >=($t24, $t13)
    call $t25 := $Ge($t24, $t13);

    // $t26 := 5
    $t26 := $Integer(5);

    // $t27 := Errors::limit_exceeded($t26)
    call $t27 := $Errors_limit_exceeded($t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 21439, $abort_code);
      goto Abort;
    }

    // if ($t25) goto L4 else goto L5
    if (b#$Boolean($t25)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // destroy(coin)

    // abort($t27)
    if (true) { assume $DebugTrackAbort(16, 21394, i#$Integer($t27)); }
    $abort_code := i#$Integer($t27);
    goto Abort;

    // L4:
L4:

    // $t28 := read_ref(coin)
    call $t28 := $ReadRef(coin);
    assert $Libra_Libra_$invariant_holds($t28);

    // ($t29, $t28) := Libra::withdraw<#0>($t28, $t13)
    call $t29, $t28 := $Libra_withdraw($tv0, $t28, $t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 21494, $abort_code);
      goto Abort;
    }

    // write_ref(coin, $t28)
    call coin := $WriteRef(coin, $t28);
    if (true) { assume $DebugTrackLocal(16, 21494, 5, $Dereference(coin)); }

    // write_back[Reference($t14)](coin)
    call $t14 := $WritebackToReference(coin, $t14);

    // write_back[LocalRoot($t12)]($t14)
    call $t12 := $WritebackToValue($t14, 12, $t12);

    // return ($t29, $t12)
    $ret0 := $t29;
    if (true) { assume $DebugTrackLocal(16, 21487, 30, $ret0); }
    $ret1 := $t12;
    if (true) { assume $DebugTrackLocal(16, 21487, 31, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}

procedure {:inline 1} $LibraAccount_withdraw_from_balance_$direct_intra($tv0: $TypeValue, payer: $Value, payee: $Value, balance: $Value, amount: $Value, $AccountLimits_Window_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value, $ret1: $Value)
requires $AccountLimits_Window_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer))];
{
    assume is#$Address(payer);

    assume is#$Address(payee);

    assume $LibraAccount_Balance_$is_well_typed(balance);

    assume $IsValidU64(amount);

    call $ret0, $ret1 := $LibraAccount_withdraw_from_balance_$def($tv0, payer, payee, balance, amount, $AccountLimits_Window_$CallerDomain);
}


procedure {:inline 1} $LibraAccount_withdraw_from_balance($tv0: $TypeValue, payer: $Value, payee: $Value, balance: $Value, amount: $Value, $AccountLimits_Window_$CallerDomain: [$TypeValueArray, int]bool) returns ($ret0: $Value, $ret1: $Value)
requires $AccountLimits_Window_$CallerDomain[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), a#$Address($VASP_spec_parent_address($VASP_ChildVASP_$memory, $VASP_ParentVASP_$memory, payer))];
{
    assume is#$Address(payer);

    assume is#$Address(payee);

    assume $LibraAccount_Balance_$is_well_typed(balance);

    assume $IsValidU64(amount);

    call $ret0, $ret1 := $LibraAccount_withdraw_from_balance_$def($tv0, payer, payee, balance, amount, $AccountLimits_Window_$CallerDomain);
}


procedure {:inline 1} $LibraAccount_writeset_epilogue_$def(lr_account: $Value, writeset_payload: $Value, txn_sequence_number: $Value, should_trigger_reconfiguration: $Value) returns ()
{
    // declare local variables
    var writeset_events_ref: $Mutation; // ReferenceType($LibraAccount_LibraWriteSetManager_type_value())
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $Vector_type_value($IntegerType())
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $AddressType()
    var $t10: $Mutation; // ReferenceType($Event_EventHandle_type_value($LibraAccount_UpgradeEvent_type_value()))
    var $t11: $Value; // $LibraAccount_UpgradeEvent_type_value()
    var $t12: $Value; // $Event_EventHandle_type_value($LibraAccount_UpgradeEvent_type_value())
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 73443, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(16, 73443, 1, writeset_payload); }
    if (true) { assume $DebugTrackLocal(16, 73443, 2, txn_sequence_number); }
    if (true) { assume $DebugTrackLocal(16, 73443, 3, should_trigger_reconfiguration); }

    // bytecode translation starts here
    // $t5 := move(lr_account)
    call $t5 := $CopyOrMoveValue(lr_account);

    // $t6 := move(writeset_payload)
    call $t6 := $CopyOrMoveValue(writeset_payload);

    // $t7 := move(txn_sequence_number)
    call $t7 := $CopyOrMoveValue(txn_sequence_number);

    // $t8 := move(should_trigger_reconfiguration)
    call $t8 := $CopyOrMoveValue(should_trigger_reconfiguration);

    // $t9 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t9 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // writeset_events_ref := borrow_global<LibraAccount::LibraWriteSetManager>($t9)
    call writeset_events_ref := $BorrowGlobal($LibraAccount_LibraWriteSetManager_$memory, $t9, $EmptyTypeValueArray);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 73708, $abort_code);
      goto Abort;
    }

    // unpack_ref(writeset_events_ref)

    // $t10 := borrow_field<LibraAccount::LibraWriteSetManager>.upgrade_events(writeset_events_ref)
    call $t10 := $BorrowField(writeset_events_ref, $LibraAccount_LibraWriteSetManager_upgrade_events);

    // unpack_ref($t10)

    // $t11 := pack LibraAccount::UpgradeEvent($t6)
    call $t11 := $LibraAccount_UpgradeEvent_pack(0, 0, 0, $t6);

    // $t12 := read_ref($t10)
    call $t12 := $ReadRef($t10);
    assert $Event_EventHandle_$invariant_holds($t12);

    // $t12 := Event::emit_event<LibraAccount::UpgradeEvent>($t12, $t11)
    call $t12 := $Event_emit_event($LibraAccount_UpgradeEvent_type_value(), $t12, $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 73801, $abort_code);
      goto Abort;
    }

    // write_ref($t10, $t12)
    call $t10 := $WriteRef($t10, $t12);
    if (true) { assume $DebugTrackLocal(16, 73801, 4, $Dereference(writeset_events_ref)); }

    // pack_ref($t10)

    // write_back[Reference(writeset_events_ref)]($t10)
    call writeset_events_ref := $WritebackToReference($t10, writeset_events_ref);

    // pack_ref(writeset_events_ref)

    // write_back[LibraAccount::LibraWriteSetManager](writeset_events_ref)
    call $LibraAccount_LibraWriteSetManager_$memory := $WritebackToGlobal($LibraAccount_LibraWriteSetManager_$memory, writeset_events_ref);

    // $t13 := 0
    $t13 := $Integer(0);

    // $t14 := 0
    $t14 := $Integer(0);

    // $t15 := 0
    $t15 := $Integer(0);

    // LibraAccount::epilogue<Coin1::Coin1>($t5, $t7, $t13, $t14, $t15)
    call $LibraAccount_epilogue($Coin1_Coin1_type_value(), $t5, $t7, $t13, $t14, $t15);
    if ($abort_flag) {
      goto Abort;
    }

    // if ($t8) goto L0 else goto L1
    if (b#$Boolean($t8)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // LibraConfig::reconfigure($t5)
    call $LibraConfig_reconfigure($t5, $ConstMemoryDomain(true));
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 74136, $abort_code);
      goto Abort;
    }

    // goto L3
    goto L3;

    // L2:
L2:

    // destroy($t5)

    // goto L3
    goto L3;

    // L3:
L3:

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_writeset_epilogue_$direct_intra(lr_account: $Value, writeset_payload: $Value, txn_sequence_number: $Value, should_trigger_reconfiguration: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(writeset_payload) && (forall $$0: int :: {$select_vector(writeset_payload,$$0)} $$0 >= 0 && $$0 < $vlen(writeset_payload) ==> $IsValidU8($select_vector(writeset_payload,$$0)));

    assume $IsValidU64(txn_sequence_number);

    assume is#$Boolean(should_trigger_reconfiguration);

    call $LibraAccount_writeset_epilogue_$def(lr_account, writeset_payload, txn_sequence_number, should_trigger_reconfiguration);
}


procedure {:inline 1} $LibraAccount_writeset_epilogue(lr_account: $Value, writeset_payload: $Value, txn_sequence_number: $Value, should_trigger_reconfiguration: $Value) returns ()
{
    assume is#$Address(lr_account);

    assume $Vector_$is_well_formed(writeset_payload) && (forall $$0: int :: {$select_vector(writeset_payload,$$0)} $$0 >= 0 && $$0 < $vlen(writeset_payload) ==> $IsValidU8($select_vector(writeset_payload,$$0)));

    assume $IsValidU64(txn_sequence_number);

    assume is#$Boolean(should_trigger_reconfiguration);

    call $LibraAccount_writeset_epilogue_$def(lr_account, writeset_payload, txn_sequence_number, should_trigger_reconfiguration);
}


procedure {:inline 1} $LibraAccount_writeset_prologue_$def(sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_expiration_time: $Value, chain_id: $Value) returns ()
{
    // declare local variables
    var tmp#$5: $Value; // $BooleanType()
    var tmp#$6: $Value; // $IntegerType()
    var tmp#$7: $Value; // $BooleanType()
    var tmp#$8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $Vector_type_value($IntegerType())
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $IntegerType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 62655, 0, sender); }
    if (true) { assume $DebugTrackLocal(16, 62655, 1, txn_sequence_number); }
    if (true) { assume $DebugTrackLocal(16, 62655, 2, txn_public_key); }
    if (true) { assume $DebugTrackLocal(16, 62655, 3, txn_expiration_time); }
    if (true) { assume $DebugTrackLocal(16, 62655, 4, chain_id); }

    // bytecode translation starts here
    // $t9 := move(sender)
    call $t9 := $CopyOrMoveValue(sender);

    // $t10 := move(txn_sequence_number)
    call $t10 := $CopyOrMoveValue(txn_sequence_number);

    // $t11 := move(txn_public_key)
    call $t11 := $CopyOrMoveValue(txn_public_key);

    // $t12 := move(txn_expiration_time)
    call $t12 := $CopyOrMoveValue(txn_expiration_time);

    // $t13 := move(chain_id)
    call $t13 := $CopyOrMoveValue(chain_id);

    // $t14 := Signer::address_of($t9)
    call $t14 := $Signer_address_of($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 62904, $abort_code);
      goto Abort;
    }

    // $t15 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t15 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      goto Abort;
    }

    // $t16 := ==($t14, $t15)
    $t16 := $Boolean($IsEqual($t14, $t15));

    // $t17 := 1010
    $t17 := $Integer(1010);

    // $t18 := Errors::invalid_argument($t17)
    call $t18 := $Errors_invalid_argument($t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 62983, $abort_code);
      goto Abort;
    }

    // if ($t16) goto L0 else goto L1
    if (b#$Boolean($t16)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // destroy($t9)

    // abort($t18)
    if (true) { assume $DebugTrackAbort(16, 62876, i#$Integer($t18)); }
    $abort_code := i#$Integer($t18);
    goto Abort;

    // L0:
L0:

    // $t19 := Roles::has_libra_root_role($t9)
    call $t19 := $Roles_has_libra_root_role($t9);
    if ($abort_flag) {
      goto Abort;
    }

    // $t20 := 1010
    $t20 := $Integer(1010);

    // $t21 := Errors::invalid_argument($t20)
    call $t21 := $Errors_invalid_argument($t20);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 63104, $abort_code);
      goto Abort;
    }

    // if ($t19) goto L2 else goto L3
    if (b#$Boolean($t19)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // destroy($t9)

    // abort($t21)
    if (true) { assume $DebugTrackAbort(16, 63053, i#$Integer($t21)); }
    $abort_code := i#$Integer($t21);
    goto Abort;

    // L2:
L2:

    // $t22 := 0
    $t22 := $Integer(0);

    // $t23 := 0
    $t23 := $Integer(0);

    // LibraAccount::prologue_common<Coin1::Coin1>($t9, $t10, $t11, $t22, $t23, $t12, $t13)
    call $LibraAccount_prologue_common($Coin1_Coin1_type_value(), $t9, $t10, $t11, $t22, $t23, $t12, $t13);
    if ($abort_flag) {
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $LibraAccount_writeset_prologue_$direct_intra(sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_expiration_time: $Value, chain_id: $Value) returns ()
{
    assume is#$Address(sender);

    assume $IsValidU64(txn_sequence_number);

    assume $Vector_$is_well_formed(txn_public_key) && (forall $$0: int :: {$select_vector(txn_public_key,$$0)} $$0 >= 0 && $$0 < $vlen(txn_public_key) ==> $IsValidU8($select_vector(txn_public_key,$$0)));

    assume $IsValidU64(txn_expiration_time);

    assume $IsValidU8(chain_id);

    call $LibraAccount_writeset_prologue_$def(sender, txn_sequence_number, txn_public_key, txn_expiration_time, chain_id);
}


procedure {:inline 1} $LibraAccount_writeset_prologue(sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_expiration_time: $Value, chain_id: $Value) returns ()
{
    assume is#$Address(sender);

    assume $IsValidU64(txn_sequence_number);

    assume $Vector_$is_well_formed(txn_public_key) && (forall $$0: int :: {$select_vector(txn_public_key,$$0)} $$0 >= 0 && $$0 < $vlen(txn_public_key) ==> $IsValidU8($select_vector(txn_public_key,$$0)));

    assume $IsValidU64(txn_expiration_time);

    assume $IsValidU8(chain_id);

    call $LibraAccount_writeset_prologue_$def(sender, txn_sequence_number, txn_public_key, txn_expiration_time, chain_id);
}




// ** spec vars of module create_designated_dealer



// ** spec funs of module create_designated_dealer



// ** structs of module create_designated_dealer



// ** functions of module create_designated_dealer

procedure {:inline 1} $create_designated_dealer_create_designated_dealer_$def($tv0: $TypeValue, tc_account: $Value, sliding_nonce: $Value, addr: $Value, auth_key_prefix: $Value, human_name: $Value, add_all_currencies: $Value) returns ()
{
    // declare local variables
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $Vector_type_value($IntegerType())
    var $t10: $Value; // $Vector_type_value($IntegerType())
    var $t11: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(31, 4503, 0, tc_account); }
    if (true) { assume $DebugTrackLocal(31, 4503, 1, sliding_nonce); }
    if (true) { assume $DebugTrackLocal(31, 4503, 2, addr); }
    if (true) { assume $DebugTrackLocal(31, 4503, 3, auth_key_prefix); }
    if (true) { assume $DebugTrackLocal(31, 4503, 4, human_name); }
    if (true) { assume $DebugTrackLocal(31, 4503, 5, add_all_currencies); }

    // bytecode translation starts here
    // $t6 := move(tc_account)
    call $t6 := $CopyOrMoveValue(tc_account);

    // $t7 := move(sliding_nonce)
    call $t7 := $CopyOrMoveValue(sliding_nonce);

    // $t8 := move(addr)
    call $t8 := $CopyOrMoveValue(addr);

    // $t9 := move(auth_key_prefix)
    call $t9 := $CopyOrMoveValue(auth_key_prefix);

    // $t10 := move(human_name)
    call $t10 := $CopyOrMoveValue(human_name);

    // $t11 := move(add_all_currencies)
    call $t11 := $CopyOrMoveValue(add_all_currencies);

    // SlidingNonce::record_nonce_or_abort($t6, $t7)
    call $SlidingNonce_record_nonce_or_abort($t6, $t7);
    if ($abort_flag) {
      goto Abort;
    }

    // LibraAccount::create_designated_dealer<#0>($t6, $t8, $t9, $t10, $t11)
    call $LibraAccount_create_designated_dealer($tv0, $t6, $t8, $t9, $t10, $t11);
    if ($abort_flag) {
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:inline 1} $create_designated_dealer_create_designated_dealer_$direct_inter($tv0: $TypeValue, tc_account: $Value, sliding_nonce: $Value, addr: $Value, auth_key_prefix: $Value, human_name: $Value, add_all_currencies: $Value) returns ()
requires b#$Boolean($LibraAccount_prologue_guarantees($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountFreezing_FreezingBit_$memory, $LibraAccount_LibraAccount_$memory, tc_account));
{
    assume is#$Address(tc_account);

    assume $IsValidU64(sliding_nonce);

    assume is#$Address(addr);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    assume is#$Boolean(add_all_currencies);

    call $create_designated_dealer_create_designated_dealer_$def($tv0, tc_account, sliding_nonce, addr, auth_key_prefix, human_name, add_all_currencies);
}


procedure {:inline 1} $create_designated_dealer_create_designated_dealer_$direct_intra($tv0: $TypeValue, tc_account: $Value, sliding_nonce: $Value, addr: $Value, auth_key_prefix: $Value, human_name: $Value, add_all_currencies: $Value) returns ()
requires b#$Boolean($LibraAccount_prologue_guarantees($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountFreezing_FreezingBit_$memory, $LibraAccount_LibraAccount_$memory, tc_account));
{
    assume is#$Address(tc_account);

    assume $IsValidU64(sliding_nonce);

    assume is#$Address(addr);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    assume is#$Boolean(add_all_currencies);

    call $create_designated_dealer_create_designated_dealer_$def($tv0, tc_account, sliding_nonce, addr, auth_key_prefix, human_name, add_all_currencies);
}


procedure {:inline 1} $create_designated_dealer_create_designated_dealer($tv0: $TypeValue, tc_account: $Value, sliding_nonce: $Value, addr: $Value, auth_key_prefix: $Value, human_name: $Value, add_all_currencies: $Value) returns ()
{
    assume is#$Address(tc_account);

    assume $IsValidU64(sliding_nonce);

    assume is#$Address(addr);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    assume is#$Boolean(add_all_currencies);

    call $create_designated_dealer_create_designated_dealer_$def($tv0, tc_account, sliding_nonce, addr, auth_key_prefix, human_name, add_all_currencies);
}


procedure {:inline 1} $create_designated_dealer_create_designated_dealer_$def_verify($tv0: $TypeValue, tc_account: $Value, sliding_nonce: $Value, addr: $Value, auth_key_prefix: $Value, human_name: $Value, add_all_currencies: $Value) returns ()
{
    // declare local variables
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $Vector_type_value($IntegerType())
    var $t10: $Value; // $Vector_type_value($IntegerType())
    var $t11: $Value; // $BooleanType()

    // initialize function execution
    assume !$abort_flag;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(31, 4503, 0, tc_account); }
    if (true) { assume $DebugTrackLocal(31, 4503, 1, sliding_nonce); }
    if (true) { assume $DebugTrackLocal(31, 4503, 2, addr); }
    if (true) { assume $DebugTrackLocal(31, 4503, 3, auth_key_prefix); }
    if (true) { assume $DebugTrackLocal(31, 4503, 4, human_name); }
    if (true) { assume $DebugTrackLocal(31, 4503, 5, add_all_currencies); }

    // bytecode translation starts here
    // $t6 := move(tc_account)
    call $t6 := $CopyOrMoveValue(tc_account);

    // $t7 := move(sliding_nonce)
    call $t7 := $CopyOrMoveValue(sliding_nonce);

    // $t8 := move(addr)
    call $t8 := $CopyOrMoveValue(addr);

    // $t9 := move(auth_key_prefix)
    call $t9 := $CopyOrMoveValue(auth_key_prefix);

    // $t10 := move(human_name)
    call $t10 := $CopyOrMoveValue(human_name);

    // $t11 := move(add_all_currencies)
    call $t11 := $CopyOrMoveValue(add_all_currencies);

    // SlidingNonce::record_nonce_or_abort($t6, $t7)
    call $SlidingNonce_record_nonce_or_abort_$direct_inter($t6, $t7);
    if ($abort_flag) {
      goto Abort;
    }

    // LibraAccount::create_designated_dealer<#0>($t6, $t8, $t9, $t10, $t11)
    call $LibraAccount_create_designated_dealer_$direct_inter($tv0, $t6, $t8, $t9, $t10, $t11);
    if ($abort_flag) {
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
}

procedure {:timeLimit 40} $create_designated_dealer_create_designated_dealer_$verify($tv0: $TypeValue, tc_account: $Value, sliding_nonce: $Value, addr: $Value, auth_key_prefix: $Value, human_name: $Value, add_all_currencies: $Value) returns ()
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($SlidingNonce_SlidingNonce_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SlidingNonce_spec_try_record_nonce(tc_account, sliding_nonce), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) ==> $abort_flag;
ensures b#$Boolean(old($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, addr))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value()))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value()))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) ==> $abort_flag;
ensures b#$Boolean(old($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), addr)))))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value()))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $LBR_LBR_type_value()], 1), addr)))))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $LBR_LBR_type_value()))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean($IsEqual(addr, $CoreAddresses_$VM_RESERVED_ADDRESS())))) ==> $abort_flag;
ensures b#$Boolean(old($ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, addr))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraAccount_AccountOperationsCapability_$memory, $EmptyTypeValueArray, $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!$IsEqual($Integer(i#$Integer($Vector_$length($IntegerType(), auth_key_prefix)) + i#$Integer($Vector_$length($IntegerType(), $LCS_serialize($AddressType(), addr)))), $Integer(32))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($SlidingNonce_SlidingNonce_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(tc_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SlidingNonce_spec_try_record_nonce(tc_account, sliding_nonce), $Integer(0)))))
    || b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr)))
    || b#$Boolean(old($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, addr)))
    || b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))
    || b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account))))))
    || b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1)))))
    || b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS()))))
    || b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), addr)))))
    || b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value())))))
    || b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), addr)))))
    || b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value())))))))
    || b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)))))))
    || b#$Boolean(old($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)))
    || b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0)))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), addr)))))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value())))))))
    || b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $LBR_LBR_type_value()], 1), addr)))))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $LBR_LBR_type_value())))))))
    || b#$Boolean(old($Boolean($IsEqual(addr, $CoreAddresses_$VM_RESERVED_ADDRESS()))))
    || b#$Boolean(old($ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, addr)))
    || b#$Boolean(old($Boolean(b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraAccount_AccountOperationsCapability_$memory, $EmptyTypeValueArray, $CoreAddresses_$LIBRA_ROOT_ADDRESS())))))))
    || b#$Boolean(old($Boolean(!$IsEqual($Integer(i#$Integer($Vector_$length($IntegerType(), auth_key_prefix)) + i#$Integer($Vector_$length($IntegerType(), $LCS_serialize($AddressType(), addr)))), $Integer(32))))));
ensures $abort_flag ==> ((b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($SlidingNonce_SlidingNonce_$memory, $EmptyTypeValueArray, $Signer_spec_address_of(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SlidingNonce_spec_try_record_nonce(tc_account, sliding_nonce), $Integer(0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, addr))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($SelectField($ResourceValue($Roles_RoleId_$memory, $EmptyTypeValueArray, $Roles_addr$37(tc_account)), $Roles_RoleId_role_id), $Integer(1))))) &&
       $abort_code == i#$Integer($Integer(3)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of(tc_account), $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(2)))
    ||(b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), addr))))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value()))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), addr))))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value()))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($DesignatedDealer_TierInfo_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Libra_$is_synthetic_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(!b#$Boolean(add_all_currencies))) && b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory))))))) &&
       $abort_code == i#$Integer($Integer(1)))
    ||(b#$Boolean(old($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $tv0))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), addr)))))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value()))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $LBR_LBR_type_value()], 1), addr)))))) && b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($Libra_CurrencyInfo_$memory, $LBR_LBR_type_value()))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean($IsEqual(addr, $CoreAddresses_$VM_RESERVED_ADDRESS())))) &&
       $abort_code == i#$Integer($Integer(7)))
    ||(b#$Boolean(old($ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, addr))) &&
       $abort_code == i#$Integer($Integer(6)))
    ||(b#$Boolean(old($Boolean(b#$Boolean($LibraTimestamp_$is_genesis($LibraTimestamp_CurrentTimeMicroseconds_$memory)) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraAccount_AccountOperationsCapability_$memory, $EmptyTypeValueArray, $CoreAddresses_$LIBRA_ROOT_ADDRESS()))))))) &&
       $abort_code == i#$Integer($Integer(5)))
    ||(b#$Boolean(old($Boolean(!$IsEqual($Integer(i#$Integer($Vector_$length($IntegerType(), auth_key_prefix)) + i#$Integer($Vector_$length($IntegerType(), $LCS_serialize($AddressType(), addr)))), $Integer(32))))) &&
       $abort_code == i#$Integer($Integer(7))));
ensures $abort_flag ==> ($abort_code == i#$Integer($Integer(7)) || $abort_code == i#$Integer($Integer(2)) || $abort_code == i#$Integer($Integer(5)) || $abort_code == i#$Integer($Integer(6)) || $abort_code == i#$Integer($Integer(3)));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($DesignatedDealer_Dealer_$memory, $EmptyTypeValueArray, addr)));
ensures !$abort_flag ==> (b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, addr)));
ensures !$abort_flag ==> (b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr)));
ensures !$abort_flag ==> (b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr)));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), addr), $Vector($ExtendValueArray($EmptyValueArray(), $Vector($ExtendValueArray($EmptyValueArray(), $Integer(0)))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), addr)))))) ==> b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), addr)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), addr)))))) ==> b#$Boolean($Boolean($IsEqual($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Coin1_Coin1_type_value()], 1), addr), $Vector($ExtendValueArray($EmptyValueArray(), $Vector($ExtendValueArray($EmptyValueArray(), $Integer(0)))))))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $LBR_LBR_type_value()], 1), addr)))))) ==> b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $LBR_LBR_type_value()], 1), addr)))));
ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean(add_all_currencies) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $LBR_LBR_type_value()], 1), addr)))))) ==> b#$Boolean($Boolean($IsEqual($ResourceValue($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $LBR_LBR_type_value()], 1), addr), $Vector($ExtendValueArray($EmptyValueArray(), $Vector($ExtendValueArray($EmptyValueArray(), $Integer(0)))))))))));
{
    assume is#$Address(tc_account);

    assume $IsValidU64(sliding_nonce);

    assume is#$Address(addr);

    assume $Vector_$is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));

    assume $Vector_$is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));

    assume is#$Boolean(add_all_currencies);

    call $InitVerification();
    assume (forall $inv_addr: int :: {contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr]}
        $LibraTimestamp_CurrentTimeMicroseconds_$is_well_formed(contents#$Memory($LibraTimestamp_CurrentTimeMicroseconds_$memory)[$EmptyTypeValueArray, $inv_addr])
    );
    assume (forall $inv_addr: int :: {contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr]}
        $Roles_RoleId_$is_well_formed(contents#$Memory($Roles_RoleId_$memory)[$EmptyTypeValueArray, $inv_addr])
    );
    assume (forall $inv_addr: int :: {contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr]}
        $AccountFreezing_FreezingBit_$is_well_formed(contents#$Memory($AccountFreezing_FreezingBit_$memory)[$EmptyTypeValueArray, $inv_addr])
    );
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]}
        $Libra_CurrencyInfo_$is_well_formed(contents#$Memory($Libra_CurrencyInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr])
    );
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {contents#$Memory($Libra_Preburn_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]}
        $Libra_Preburn_$is_well_formed(contents#$Memory($Libra_Preburn_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr])
    );
    assume (forall $inv_addr: int :: {contents#$Memory($DesignatedDealer_Dealer_$memory)[$EmptyTypeValueArray, $inv_addr]}
        $DesignatedDealer_Dealer_$is_well_formed(contents#$Memory($DesignatedDealer_Dealer_$memory)[$EmptyTypeValueArray, $inv_addr])
    );
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]}
        $DesignatedDealer_TierInfo_$is_well_formed(contents#$Memory($DesignatedDealer_TierInfo_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr])
    );
    assume (forall $inv_addr: int :: {contents#$Memory($DualAttestation_Credential_$memory)[$EmptyTypeValueArray, $inv_addr]}
        $DualAttestation_Credential_$is_well_formed(contents#$Memory($DualAttestation_Credential_$memory)[$EmptyTypeValueArray, $inv_addr])
    );
    assume (forall $inv_addr: int :: {contents#$Memory($SlidingNonce_SlidingNonce_$memory)[$EmptyTypeValueArray, $inv_addr]}
        $SlidingNonce_SlidingNonce_$is_well_formed(contents#$Memory($SlidingNonce_SlidingNonce_$memory)[$EmptyTypeValueArray, $inv_addr])
    );
    assume (forall $inv_addr: int :: {contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr]}
        $LibraAccount_LibraAccount_$is_well_formed(contents#$Memory($LibraAccount_LibraAccount_$memory)[$EmptyTypeValueArray, $inv_addr])
    );
    assume (forall $inv_addr: int :: {contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr]}
        $LibraAccount_AccountOperationsCapability_$is_well_formed(contents#$Memory($LibraAccount_AccountOperationsCapability_$memory)[$EmptyTypeValueArray, $inv_addr])
    );
    assume (forall $inv_addr: int, $inv_tv0: $TypeValue :: {contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr]}
        $LibraAccount_Balance_$is_well_formed(contents#$Memory($LibraAccount_Balance_$memory)[$TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $inv_tv0], 1), $inv_addr])
    );
    assume b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) ==> b#$Boolean($ResourceExists($AccountFreezing_FreezeEventsHolder_$memory, $EmptyTypeValueArray, $CoreAddresses_$LIBRA_ROOT_ADDRESS()))));
    assume b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) ==> b#$Boolean($AccountFreezing_spec_account_is_not_frozen($AccountFreezing_FreezingBit_$memory, $CoreAddresses_$LIBRA_ROOT_ADDRESS()))));
    assume b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) ==> b#$Boolean($AccountFreezing_spec_account_is_not_frozen($AccountFreezing_FreezingBit_$memory, $CoreAddresses_$TREASURY_COMPLIANCE_ADDRESS()))));
    assume b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) ==> b#$Boolean($ResourceExists($ChainId_ChainId_$memory, $EmptyTypeValueArray, $CoreAddresses_$LIBRA_ROOT_ADDRESS()))));
    assume b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) ==> b#$Boolean($LibraConfig_spec_has_config($LibraConfig_Configuration_$memory))));
    assume b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) ==> b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $RegisteredCurrencies_RegisteredCurrencies_type_value()))));
    assume b#$Boolean($Boolean((forall coin_type: $Value :: is#$Type(coin_type) ==> b#$Boolean($Boolean((forall mint_cap_owner: $Value :: is#$Address(mint_cap_owner) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_MintCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), mint_cap_owner)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, mint_cap_owner))))))))));
    assume b#$Boolean($Boolean((forall coin_type: $Value :: is#$Type(coin_type) ==> b#$Boolean($Boolean((forall addr3: $Value :: is#$Address(addr3) ==> b#$Boolean($Boolean(b#$Boolean($Libra_spec_has_mint_capability($Libra_MintCapability_$memory, t#$Type(coin_type), addr3)) ==> b#$Boolean($Libra_spec_is_SCS_currency($Libra_CurrencyInfo_$memory, t#$Type(coin_type)))))))))));
    assume b#$Boolean($Boolean((forall coin_type: $Value :: is#$Type(coin_type) ==> b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_BurnCapability_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) ==> b#$Boolean($Roles_spec_has_treasury_compliance_role_addr($Roles_RoleId_$memory, addr1))))))))));
    assume b#$Boolean($Boolean((forall coin_type: $Value :: is#$Type(coin_type) ==> b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($Libra_Preburn_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(coin_type)], 1), addr1)) ==> b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr1))))))))));
    assume b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) ==> b#$Boolean($Libra_$is_currency($Libra_CurrencyInfo_$memory, $Coin1_Coin1_type_value()))));
    assume b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) ==> b#$Boolean($Boolean(b#$Boolean($LBR_reserve_exists($LBR_Reserve_$memory)) && b#$Boolean($Libra_$is_currency($Libra_CurrencyInfo_$memory, $LBR_LBR_type_value()))))));
    assume b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) ==> b#$Boolean($DualAttestation_spec_is_published($DualAttestation_Limit_$memory))));
    assume b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean($DualAttestation_spec_has_credential($DualAttestation_Credential_$memory, addr1)) ==> b#$Boolean($Boolean(b#$Boolean($Roles_spec_has_parent_VASP_role_addr($Roles_RoleId_$memory, addr1)) || b#$Boolean($Roles_spec_has_designated_dealer_role_addr($Roles_RoleId_$memory, addr1)))))))));
    assume b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($ValidatorOperatorConfig_$has_validator_operator_config($ValidatorOperatorConfig_ValidatorOperatorConfig_$memory, addr)) ==> b#$Boolean($Roles_spec_has_validator_operator_role_addr($Roles_RoleId_$memory, addr)))))));
    assume b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr1)) ==> b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr1)))))));
    assume b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean($ValidatorConfig_$exists_config($ValidatorConfig_ValidatorConfig_$memory, addr1)) ==> b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr1)))))));
    assume b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean($ValidatorConfig_$is_valid($ValidatorConfig_ValidatorConfig_$memory, addr1)) ==> b#$Boolean($Roles_spec_has_validator_role_addr($Roles_RoleId_$memory, addr1)))))));
    assume b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) ==> b#$Boolean($TransactionFee_$is_initialized($TransactionFee_TransactionFee_$memory))));
    assume b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) ==> b#$Boolean($LibraConfig_spec_is_published($LibraConfig_LibraConfig_$memory, $LibraTransactionPublishingOption_LibraTransactionPublishingOption_type_value()))));
    assume b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, addr1)) ==> b#$Boolean($Boolean(b#$Boolean($LibraAccount_$delegated_key_rotation_capability($LibraAccount_LibraAccount_$memory, addr1)) || b#$Boolean($LibraAccount_spec_holds_own_key_rotation_cap($LibraAccount_LibraAccount_$memory, addr1)))))))));
    assume b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, addr1)) ==> b#$Boolean($Boolean(b#$Boolean($LibraAccount_$delegated_withdraw_capability($LibraAccount_LibraAccount_$memory, addr1)) || b#$Boolean($LibraAccount_spec_holds_own_withdraw_cap($LibraAccount_LibraAccount_$memory, addr1)))))))));
    assume b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, addr1)) ==> b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr1)))))));
    assume b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) ==> b#$Boolean($ResourceExists($LibraAccount_AccountOperationsCapability_$memory, $EmptyTypeValueArray, $CoreAddresses_$LIBRA_ROOT_ADDRESS()))));
    assume b#$Boolean($Boolean(b#$Boolean($LibraTimestamp_$is_operating($LibraTimestamp_CurrentTimeMicroseconds_$memory)) ==> b#$Boolean($ResourceExists($LibraAccount_LibraWriteSetManager_$memory, $EmptyTypeValueArray, $CoreAddresses_$LIBRA_ROOT_ADDRESS()))));
    assume b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, addr1)) ==> b#$Boolean($ResourceExists($Roles_RoleId_$memory, $EmptyTypeValueArray, addr1)))))));
    assume b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean($LibraAccount_$exists_at($LibraAccount_LibraAccount_$memory, addr1)) ==> b#$Boolean($ResourceExists($AccountFreezing_FreezingBit_$memory, $EmptyTypeValueArray, addr1)))))));
    assume b#$Boolean($Boolean((forall t: $Value :: is#$Type(t) ==> b#$Boolean($Boolean((forall addr1: $Value :: is#$Address(addr1) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($LibraAccount_Balance_$memory, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := t#$Type(t)], 1), addr1)) ==> b#$Boolean($Roles_spec_can_hold_balance_addr($Roles_RoleId_$memory, addr1))))))))));
    assume b#$Boolean($LibraAccount_prologue_guarantees($LibraTimestamp_CurrentTimeMicroseconds_$memory, $AccountFreezing_FreezingBit_$memory, $LibraAccount_LibraAccount_$memory, tc_account));
    call $create_designated_dealer_create_designated_dealer_$def_verify($tv0, tc_account, sliding_nonce, addr, auth_key_prefix, human_name, add_all_currencies);
}
